var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { jsx as jsx$1, jsxs, Fragment } from "react/jsx-runtime";
import * as React$1 from "react";
import React__default, { useRef, useEffect, useCallback, useState, useId as useId$1, useLayoutEffect, useMemo, forwardRef as forwardRef$1, useContext, createContext, useReducer, createElement, useInsertionEffect, cloneElement, Children, isValidElement as isValidElement$1, memo, useSyncExternalStore as useSyncExternalStore$1, Fragment as Fragment$1, StrictMode } from "react";
import ReactDOMServer, { renderToStaticMarkup } from "react-dom/server";
import { StaticRouter } from "react-router-dom/server.mjs";
import { createUploadLink } from "apollo-upload-client";
import { accordionAnatomy, alertAnatomy, avatarAnatomy, cardAnatomy, checkboxAnatomy, editableAnatomy, inputAnatomy, menuAnatomy, radioAnatomy } from "@chakra-ui/anatomy";
import { theme as theme$1, isChakraTheme } from "@chakra-ui/theme";
import { getOwnerWindow, getActiveElement, isTabbable, isObject, mergeWith, runIfFn, toMediaQueryString, omit, pick, walkObject, analyzeBreakpoints, isBrowser as isBrowser$2, createContext as createContext$1, memoizedGet as memoizedGet$1, interopDefault, splitProps, assignAfter, compact as compact$1, cx, callAllHandlers, warn, dataAttr, ariaAttr, callAll, isArray as isArray$1, getAllFocusable, mapResponsive, getValidChildren, breakpoints, arrayToObjectNotation, lazyDisclosure, split, getScrollParent } from "@chakra-ui/utils";
import { StyleSheet } from "@emotion/sheet";
import { stringify as stringify$1, rulesheet, middleware, RULESET, combine, match, serialize, copy as copy$1, replace, WEBKIT, MOZ, MS, KEYFRAMES, DECLARATION, compile, dealloc, alloc, hash, charat, strlen, indexof, next, token, from, peek, delimit, slice, position as position$1 } from "stylis";
import weakMemoize from "@emotion/weak-memoize";
import memoize$1 from "@emotion/memoize";
import _extends from "@babel/runtime/helpers/esm/extends";
import { serializeStyles } from "@emotion/serialize";
import { useInsertionEffectAlwaysWithSyncFallback, useInsertionEffectWithLayoutFallback } from "@emotion/use-insertion-effect-with-fallbacks";
import "@babel/runtime/helpers/extends";
import "hoist-non-react-statics";
import { omit as omit$1, isEqual as isEqual$1, unescape, debounce, isEmpty as isEmpty$1 } from "lodash";
import Cookies from "js-cookie";
import { passwordStrength } from "check-password-strength";
import { useNavigate, Link as Link$1, useSearchParams, useParams, useLocation, useRoutes, Navigate } from "react-router-dom";
import { FiSearch, FiXCircle, FiEdit2, FiDelete, FiSave, FiPlusCircle, FiCalendar, FiUser, FiFolder, FiX, FiRefreshCcw, FiSun, FiMoon, FiMenu, FiHome, FiCompass, FiStar, FiSettings, FiHelpCircle, FiLogOut, FiLink, FiBriefcase, FiMinusCircle, FiShare2, FiEdit3, FiExternalLink, FiZoomIn, FiDownload, FiLinkedin, FiFacebook, FiInstagram, FiMapPin, FiCheckCircle, FiAlertCircle, FiMap, FiMail, FiPhone, FiGlobe, FiCheck, FiTrash2, FiEyeOff, FiEye, FiPlus, FiArrowUpCircle, FiArrowDownCircle, FiVideo, FiImage, FiUpload, FiArrowDown, FiCopy, FiFlag, FiDollarSign } from "react-icons/fi/index.esm.js";
import { __assign, __spreadArray, __extends, __awaiter, __generator, __rest } from "tslib";
import { invariant as invariant$1, InvariantError } from "ts-invariant";
import * as React from "rehackt";
import equal, { equal as equal$1 } from "@wry/equality";
import { WeakCache, StrongCache } from "@wry/caches";
import { gql } from "graphql-tag";
import isEqual from "react-fast-compare";
import { invariant as invariant$2, warning } from "hey-listen";
import { trackFocusVisible } from "@zag-js/focus-visible";
import { createContext as createContext$2 } from "@chakra-ui/utils/context";
import { createPopper } from "@popperjs/core";
import { createPortal } from "react-dom";
import { hideOthers } from "aria-hidden";
import { RemoveScroll } from "react-remove-scroll";
import ReactFocusLock from "react-focus-lock";
import DatePicker from "react-datepicker";
import { AutoComplete, AutoCompleteInput, AutoCompleteList, AutoCompleteGroup, AutoCompleteGroupTitle, AutoCompleteItem } from "@choc-ui/chakra-autocomplete";
import copy from "copy-to-clipboard";
import parse$1 from "html-react-parser";
import ReactPlayer from "react-player";
import { useDropzone } from "react-dropzone";
import { visit, BREAK, Kind, print as print$1, isSelectionNode } from "graphql";
import { Observable } from "zen-observable-ts";
import "symbol-observable";
import { Trie } from "@wry/trie";
import { wrap as wrap$2, Slot, dep } from "optimism";
var version$1 = "3.12.6";
function maybe(thunk) {
  try {
    return thunk();
  } catch (_a) {
  }
}
var global$1 = maybe(function() {
  return globalThis;
}) || maybe(function() {
  return window;
}) || maybe(function() {
  return self;
}) || maybe(function() {
  return global;
}) || // We don't expect the Function constructor ever to be invoked at runtime, as
// long as at least one of globalThis, window, self, or global is defined, so
// we are under no obligation to make it easy for static analysis tools to
// detect syntactic usage of the Function constructor. If you think you can
// improve your static analysis to detect this obfuscation, think again. This
// is an arms race you cannot win, at least not in JavaScript.
maybe(function() {
  return maybe.constructor("return this")();
});
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix2) {
  var count = prefixCounts.get(prefix2) || 1;
  prefixCounts.set(prefix2, count + 1);
  return "".concat(prefix2, ":").concat(count, ":").concat(Math.random().toString(36).slice(2));
}
function stringifyForDisplay(value, space2) {
  if (space2 === void 0) {
    space2 = 0;
  }
  var undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, function(key, value2) {
    return value2 === void 0 ? undefId : value2;
  }, space2).split(JSON.stringify(undefId)).join("<undefined>");
}
function wrap$1(fn) {
  return function(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof message === "number") {
      var arg0 = message;
      message = getHandledErrorMsg(arg0);
      if (!message) {
        message = getFallbackErrorMsg(arg0, args);
        args = [];
      }
    }
    fn.apply(void 0, [message].concat(args));
  };
}
var invariant = Object.assign(function invariant2(condition, message) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (!condition) {
    invariant$1(condition, getHandledErrorMsg(message, args) || getFallbackErrorMsg(message, args));
  }
}, {
  debug: wrap$1(invariant$1.debug),
  log: wrap$1(invariant$1.log),
  warn: wrap$1(invariant$1.warn),
  error: wrap$1(invariant$1.error)
});
function newInvariantError(message) {
  var optionalParams = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    optionalParams[_i - 1] = arguments[_i];
  }
  return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version$1);
function stringify(arg) {
  if (typeof arg == "string") {
    return arg;
  }
  try {
    return stringifyForDisplay(arg, 2).slice(0, 1e3);
  } catch (_a) {
    return "<non-serializable>";
  }
}
function getHandledErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return global$1[ApolloErrorMessageHandler] && global$1[ApolloErrorMessageHandler](message, messageArgs.map(stringify));
}
function getFallbackErrorMsg(message, messageArgs) {
  if (messageArgs === void 0) {
    messageArgs = [];
  }
  if (!message)
    return;
  return "An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#".concat(encodeURIComponent(JSON.stringify({
    version: version$1,
    message,
    args: messageArgs.map(stringify)
  })));
}
function shouldInclude(_a, variables) {
  var directives = _a.directives;
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(function(_a2) {
    var directive = _a2.directive, ifArgument = _a2.ifArgument;
    var evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      invariant(evaledValue !== void 0, 78, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function hasDirectives(names, root, all) {
  var nameSet = new Set(names);
  var uniqueCount = nameSet.size;
  visit(root, {
    Directive: function(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}
function hasClientExports(document2) {
  return document2 && hasDirectives(["client", "export"], document2, true);
}
function isInclusionDirective(_a) {
  var value = _a.name.value;
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  var result = [];
  if (directives && directives.length) {
    directives.forEach(function(directive) {
      if (!isInclusionDirective(directive))
        return;
      var directiveArguments = directive.arguments;
      var directiveName = directive.name.value;
      invariant(directiveArguments && directiveArguments.length === 1, 79, directiveName);
      var ifArgument = directiveArguments[0];
      invariant(ifArgument.name && ifArgument.name.value === "if", 80, directiveName);
      var ifValue = ifArgument.value;
      invariant(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 81, directiveName);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}
function getFragmentMaskMode(fragment) {
  var _a, _b;
  var directive = (_a = fragment.directives) === null || _a === void 0 ? void 0 : _a.find(function(_a2) {
    var name2 = _a2.name;
    return name2.value === "unmask";
  });
  if (!directive) {
    return "mask";
  }
  var modeArg = (_b = directive.arguments) === null || _b === void 0 ? void 0 : _b.find(function(_a2) {
    var name2 = _a2.name;
    return name2.value === "mode";
  });
  if (globalThis.__DEV__ !== false) {
    if (modeArg) {
      if (modeArg.value.kind === Kind.VARIABLE) {
        globalThis.__DEV__ !== false && invariant.warn(82);
      } else if (modeArg.value.kind !== Kind.STRING) {
        globalThis.__DEV__ !== false && invariant.warn(83);
      } else if (modeArg.value.value !== "migrate") {
        globalThis.__DEV__ !== false && invariant.warn(84, modeArg.value.value);
      }
    }
  }
  if (modeArg && "value" in modeArg.value && modeArg.value.value === "migrate") {
    return "migrate";
  }
  return "unmask";
}
var isReactNative = maybe(function() {
  return navigator.product;
}) == "ReactNative";
var canUseWeakMap = typeof WeakMap === "function" && !(isReactNative && !global.HermesInternal);
var canUseWeakSet = typeof WeakSet === "function";
var canUseSymbol = typeof Symbol === "function" && typeof Symbol.for === "function";
var canUseAsyncIteratorSymbol = canUseSymbol && Symbol.asyncIterator;
var canUseDOM = typeof maybe(function() {
  return window.document.createElement;
}) === "function";
var usingJSDOM = (
  // Following advice found in this comment from @domenic (maintainer of jsdom):
  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327
  //
  // Since we control the version of Jest and jsdom used when running Apollo
  // Client tests, and that version is recent enought to include " jsdom/x.y.z"
  // at the end of the user agent string, I believe this case is all we need to
  // check. Testing for "Node.js" was recommended for backwards compatibility
  // with older version of jsdom, but we don't have that problem.
  maybe(function() {
    return navigator.userAgent.indexOf("jsdom") >= 0;
  }) || false
);
var canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}
function getFragmentQueryDocument(document2, fragmentName) {
  var actualFragmentName = fragmentName;
  var fragments = [];
  document2.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      throw newInvariantError(
        85,
        definition.operation,
        definition.name ? " named '".concat(definition.name.value, "'") : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    invariant(fragments.length === 1, 86, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  var query = __assign(__assign({}, document2), { definitions: __spreadArray([
    {
      kind: "OperationDefinition",
      // OperationTypeNode is an enum
      operation: "query",
      selectionSet: {
        kind: "SelectionSet",
        selections: [
          {
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: actualFragmentName
            }
          }
        ]
      }
    }
  ], document2.definitions, true) });
  return query;
}
function createFragmentMap(fragments) {
  if (fragments === void 0) {
    fragments = [];
  }
  var symTable = {};
  fragments.forEach(function(fragment) {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      var fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      var fragment = fragmentMap && fragmentMap[fragmentName];
      invariant(fragment, 87, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}
function isFullyUnmaskedOperation(document2) {
  var isUnmasked = true;
  visit(document2, {
    FragmentSpread: function(node) {
      isUnmasked = !!node.directives && node.directives.some(function(directive) {
        return directive.name.value === "unmask";
      });
      if (!isUnmasked) {
        return BREAK;
      }
    }
  });
  return isUnmasked;
}
var scheduledCleanup = /* @__PURE__ */ new WeakSet();
function schedule(cache2) {
  if (cache2.size <= (cache2.max || -1)) {
    return;
  }
  if (!scheduledCleanup.has(cache2)) {
    scheduledCleanup.add(cache2);
    setTimeout(function() {
      cache2.clean();
      scheduledCleanup.delete(cache2);
    }, 100);
  }
}
var AutoCleanedWeakCache = function(max, dispose) {
  var cache2 = new WeakCache(max, dispose);
  cache2.set = function(key, value) {
    var ret = WeakCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};
var AutoCleanedStrongCache = function(max, dispose) {
  var cache2 = new StrongCache(max, dispose);
  cache2.set = function(key, value) {
    var ret = StrongCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache2;
};
var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
var cacheSizes = __assign({}, global$1[cacheSizeSymbol]);
var globalCaches = {};
function registerGlobalCache(name2, getSize) {
  globalCaches[name2] = getSize;
}
var getApolloClientMemoryInternals = globalThis.__DEV__ !== false ? _getApolloClientMemoryInternals : void 0;
var getInMemoryCacheMemoryInternals = globalThis.__DEV__ !== false ? _getInMemoryCacheMemoryInternals : void 0;
var getApolloCacheMemoryInternals = globalThis.__DEV__ !== false ? _getApolloCacheMemoryInternals : void 0;
function getCurrentCacheSizes() {
  var defaults = {
    parser: 1e3,
    canonicalStringify: 1e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(defaults).map(function(_a) {
    var k2 = _a[0], v2 = _a[1];
    return [
      k2,
      cacheSizes[k2] || v2
    ];
  }));
}
function _getApolloClientMemoryInternals() {
  var _a, _b, _c, _d, _e;
  if (!(globalThis.__DEV__ !== false))
    throw new Error("only supported in development mode");
  return {
    limits: getCurrentCacheSizes(),
    sizes: __assign({ print: (_a = globalCaches.print) === null || _a === void 0 ? void 0 : _a.call(globalCaches), parser: (_b = globalCaches.parser) === null || _b === void 0 ? void 0 : _b.call(globalCaches), canonicalStringify: (_c = globalCaches.canonicalStringify) === null || _c === void 0 ? void 0 : _c.call(globalCaches), links: linkInfo(this.link), queryManager: {
      getDocumentInfo: this["queryManager"]["transformCache"].size,
      documentTransforms: transformInfo(this["queryManager"].documentTransform)
    } }, (_e = (_d = this.cache).getMemoryInternals) === null || _e === void 0 ? void 0 : _e.call(_d))
  };
}
function _getApolloCacheMemoryInternals() {
  return {
    cache: {
      fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
    }
  };
}
function _getInMemoryCacheMemoryInternals() {
  var fragments = this.config.fragments;
  return __assign(__assign({}, _getApolloCacheMemoryInternals.apply(this)), { addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]), inMemoryCache: {
    executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
    executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
    maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
  }, fragmentRegistry: {
    findFragmentSpreads: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.findFragmentSpreads),
    lookup: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.lookup),
    transform: getWrapperInformation(fragments === null || fragments === void 0 ? void 0 : fragments.transform)
  } });
}
function isWrapper(f2) {
  return !!f2 && "dirtyKey" in f2;
}
function getWrapperInformation(f2) {
  return isWrapper(f2) ? f2.size : void 0;
}
function isDefined(value) {
  return value != null;
}
function transformInfo(transform2) {
  return recurseTransformInfo(transform2).map(function(cache2) {
    return { cache: cache2 };
  });
}
function recurseTransformInfo(transform2) {
  return transform2 ? __spreadArray(__spreadArray([
    getWrapperInformation(transform2 === null || transform2 === void 0 ? void 0 : transform2["performWork"])
  ], recurseTransformInfo(transform2 === null || transform2 === void 0 ? void 0 : transform2["left"]), true), recurseTransformInfo(transform2 === null || transform2 === void 0 ? void 0 : transform2["right"]), true).filter(isDefined) : [];
}
function linkInfo(link) {
  var _a;
  return link ? __spreadArray(__spreadArray([
    (_a = link === null || link === void 0 ? void 0 : link.getMemoryInternals) === null || _a === void 0 ? void 0 : _a.call(link)
  ], linkInfo(link === null || link === void 0 ? void 0 : link.left), true), linkInfo(link === null || link === void 0 ? void 0 : link.right), true).filter(isDefined) : [];
}
var canonicalStringify = Object.assign(function canonicalStringify2(value) {
  return JSON.stringify(value, stableObjectReplacer);
}, {
  reset: function() {
    sortingMap = new AutoCleanedStrongCache(
      cacheSizes.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("canonicalStringify", function() {
    return sortingMap.size;
  });
}
var sortingMap;
canonicalStringify.reset();
function stableObjectReplacer(key, value) {
  if (value && typeof value === "object") {
    var proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
      var keys = Object.keys(value);
      if (keys.every(everyKeyInOrder))
        return value;
      var unsortedKey = JSON.stringify(keys);
      var sortedKeys = sortingMap.get(unsortedKey);
      if (!sortedKeys) {
        keys.sort();
        var sortedKey = JSON.stringify(keys);
        sortedKeys = sortingMap.get(sortedKey) || keys;
        sortingMap.set(unsortedKey, sortedKeys);
        sortingMap.set(sortedKey, sortedKeys);
      }
      var sortedObject_1 = Object.create(proto);
      sortedKeys.forEach(function(key2) {
        sortedObject_1[key2] = value[key2];
      });
      return sortedObject_1;
    }
  }
  return value;
}
function everyKeyInOrder(key, i, keys) {
  return i === 0 || keys[i - 1] <= key;
}
function makeReference(id2) {
  return { __ref: String(id2) };
}
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}
function isStringValue(value) {
  return value.kind === "StringValue";
}
function isBooleanValue(value) {
  return value.kind === "BooleanValue";
}
function isIntValue(value) {
  return value.kind === "IntValue";
}
function isFloatValue(value) {
  return value.kind === "FloatValue";
}
function isVariable(value) {
  return value.kind === "Variable";
}
function isObjectValue(value) {
  return value.kind === "ObjectValue";
}
function isListValue(value) {
  return value.kind === "ListValue";
}
function isEnumValue(value) {
  return value.kind === "EnumValue";
}
function isNullValue(value) {
  return value.kind === "NullValue";
}
function valueToObjectRepresentation(argObj, name2, value, variables) {
  if (isIntValue(value) || isFloatValue(value)) {
    argObj[name2.value] = Number(value.value);
  } else if (isBooleanValue(value) || isStringValue(value)) {
    argObj[name2.value] = value.value;
  } else if (isObjectValue(value)) {
    var nestedArgObj_1 = {};
    value.fields.map(function(obj) {
      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);
    });
    argObj[name2.value] = nestedArgObj_1;
  } else if (isVariable(value)) {
    var variableValue = (variables || {})[value.name.value];
    argObj[name2.value] = variableValue;
  } else if (isListValue(value)) {
    argObj[name2.value] = value.values.map(function(listValue) {
      var nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name2, listValue, variables);
      return nestedArgArrayObj[name2.value];
    });
  } else if (isEnumValue(value)) {
    argObj[name2.value] = value.value;
  } else if (isNullValue(value)) {
    argObj[name2.value] = null;
  } else {
    throw newInvariantError(96, name2.value, value.kind);
  }
}
function storeKeyNameFromField(field, variables) {
  var directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach(function(directive) {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(function(_a) {
          var name2 = _a.name, value = _a.value;
          return valueToObjectRepresentation(directivesObj[directive.name.value], name2, value, variables);
        });
      }
    });
  }
  var argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(function(_a) {
      var name2 = _a.name, value = _a.value;
      return valueToObjectRepresentation(argObj, name2, value, variables);
    });
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
];
var storeKeyNameStringify = canonicalStringify;
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      var filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      var filteredArgs_1 = {};
      filterKeys.forEach(function(key) {
        filteredArgs_1[key] = args[key];
      });
      return "".concat(directives["connection"]["key"], "(").concat(storeKeyNameStringify(filteredArgs_1), ")");
    } else {
      return directives["connection"]["key"];
    }
  }
  var completeFieldName = fieldName;
  if (args) {
    var stringifiedArgs = storeKeyNameStringify(args);
    completeFieldName += "(".concat(stringifiedArgs, ")");
  }
  if (directives) {
    Object.keys(directives).forEach(function(key) {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += "@".concat(key, "(").concat(storeKeyNameStringify(directives[key]), ")");
      } else {
        completeFieldName += "@".concat(key);
      }
    });
  }
  return completeFieldName;
}, {
  setStringify: function(s) {
    var previous = storeKeyNameStringify;
    storeKeyNameStringify = s;
    return previous;
  }
});
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    var argObj_1 = {};
    field.arguments.forEach(function(_a) {
      var name2 = _a.name, value = _a.value;
      return valueToObjectRepresentation(argObj_1, name2, value, variables);
    });
    return argObj_1;
  }
  return null;
}
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  var fragments;
  for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {
    var selection = _a[_i];
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  if (fragments) {
    for (var _b = 0, fragments_1 = fragments; _b < fragments_1.length; _b++) {
      var selection = fragments_1[_b];
      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}
function isField(selection) {
  return selection.kind === "Field";
}
function isInlineFragment(selection) {
  return selection.kind === "InlineFragment";
}
function checkDocument(doc) {
  invariant(doc && doc.kind === "Document", 88);
  var operations = doc.definitions.filter(function(d) {
    return d.kind !== "FragmentDefinition";
  }).map(function(definition) {
    if (definition.kind !== "OperationDefinition") {
      throw newInvariantError(89, definition.kind);
    }
    return definition;
  });
  invariant(operations.length <= 1, 90, operations.length);
  return doc;
}
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition";
  })[0];
}
function getOperationName(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "OperationDefinition" && !!definition.name;
  }).map(function(x2) {
    return x2.name.value;
  })[0] || null;
}
function getFragmentDefinitions(doc) {
  return doc.definitions.filter(function(definition) {
    return definition.kind === "FragmentDefinition";
  });
}
function getQueryDefinition(doc) {
  var queryDef = getOperationDefinition(doc);
  invariant(queryDef && queryDef.operation === "query", 91);
  return queryDef;
}
function getFragmentDefinition(doc) {
  invariant(doc.kind === "Document", 92);
  invariant(doc.definitions.length <= 1, 93);
  var fragmentDef = doc.definitions[0];
  invariant(fragmentDef.kind === "FragmentDefinition", 94);
  return fragmentDef;
}
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  var fragmentDefinition;
  for (var _i = 0, _a = queryDoc.definitions; _i < _a.length; _i++) {
    var definition = _a[_i];
    if (definition.kind === "OperationDefinition") {
      var operation = definition.operation;
      if (operation === "query" || operation === "mutation" || operation === "subscription") {
        return definition;
      }
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw newInvariantError(95);
}
function getDefaultValues(definition) {
  var defaultValues = /* @__PURE__ */ Object.create(null);
  var defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach(function(def) {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}
function identity(document2) {
  return document2;
}
var DocumentTransform = (
  /** @class */
  function() {
    function DocumentTransform2(transform2, options) {
      if (options === void 0) {
        options = /* @__PURE__ */ Object.create(null);
      }
      this.resultCache = canUseWeakSet ? /* @__PURE__ */ new WeakSet() : /* @__PURE__ */ new Set();
      this.transform = transform2;
      if (options.getCacheKey) {
        this.getCacheKey = options.getCacheKey;
      }
      this.cached = options.cache !== false;
      this.resetCache();
    }
    DocumentTransform2.prototype.getCacheKey = function(document2) {
      return [document2];
    };
    DocumentTransform2.identity = function() {
      return new DocumentTransform2(identity, { cache: false });
    };
    DocumentTransform2.split = function(predicate, left, right) {
      if (right === void 0) {
        right = DocumentTransform2.identity();
      }
      return Object.assign(new DocumentTransform2(
        function(document2) {
          var documentTransform = predicate(document2) ? left : right;
          return documentTransform.transformDocument(document2);
        },
        // Reasonably assume both `left` and `right` transforms handle their own caching
        { cache: false }
      ), { left, right });
    };
    DocumentTransform2.prototype.resetCache = function() {
      var _this = this;
      if (this.cached) {
        var stableCacheKeys_1 = new Trie(canUseWeakMap);
        this.performWork = wrap$2(DocumentTransform2.prototype.performWork.bind(this), {
          makeCacheKey: function(document2) {
            var cacheKeys = _this.getCacheKey(document2);
            if (cacheKeys) {
              invariant(Array.isArray(cacheKeys), 77);
              return stableCacheKeys_1.lookupArray(cacheKeys);
            }
          },
          max: cacheSizes["documentTransform.cache"],
          cache: WeakCache
        });
      }
    };
    DocumentTransform2.prototype.performWork = function(document2) {
      checkDocument(document2);
      return this.transform(document2);
    };
    DocumentTransform2.prototype.transformDocument = function(document2) {
      if (this.resultCache.has(document2)) {
        return document2;
      }
      var transformedDocument = this.performWork(document2);
      this.resultCache.add(transformedDocument);
      return transformedDocument;
    };
    DocumentTransform2.prototype.concat = function(otherTransform) {
      var _this = this;
      return Object.assign(new DocumentTransform2(
        function(document2) {
          return otherTransform.transformDocument(_this.transformDocument(document2));
        },
        // Reasonably assume both transforms handle their own caching
        { cache: false }
      ), {
        left: this,
        right: otherTransform
      });
    };
    return DocumentTransform2;
  }()
);
var printCache;
var print = Object.assign(function(ast) {
  var result = printCache.get(ast);
  if (!result) {
    result = print$1(ast);
    printCache.set(ast, result);
  }
  return result;
}, {
  reset: function() {
    printCache = new AutoCleanedWeakCache(
      cacheSizes.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
print.reset();
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("print", function() {
    return printCache ? printCache.size : 0;
  });
}
var isArray = Array.isArray;
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}
var TYPENAME_FIELD = {
  kind: Kind.FIELD,
  name: {
    kind: Kind.NAME,
    value: "__typename"
  }
};
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every(function(selection) {
    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);
  });
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}
function getDirectiveMatcher(configs) {
  var names = /* @__PURE__ */ new Map();
  var tests = /* @__PURE__ */ new Map();
  configs.forEach(function(directive) {
    if (directive) {
      if (directive.name) {
        names.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return function(directive) {
    var config2 = names.get(directive.name.value);
    if (!config2 && tests.size) {
      tests.forEach(function(testConfig, test2) {
        if (test2(directive)) {
          config2 = testConfig;
        }
      });
    }
    return config2;
  };
}
function makeInUseGetterFunction(defaultKey) {
  var map = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key) {
    if (key === void 0) {
      key = defaultKey;
    }
    var inUse = map.get(key);
    if (!inUse) {
      map.set(key, inUse = {
        // Variable and fragment spread names used directly within this
        // operation or fragment definition, as identified by key. These sets
        // will be populated during the first traversal of the document in
        // removeDirectivesFromDocument below.
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function removeDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  var getInUseByOperationName = makeInUseGetterFunction("");
  var getInUseByFragmentName = makeInUseGetterFunction("");
  var getInUse = function(ancestors) {
    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
      if (isArray(ancestor))
        continue;
      if (ancestor.kind === Kind.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    globalThis.__DEV__ !== false && invariant.error(97);
    return null;
  };
  var operationCount = 0;
  for (var i = doc.definitions.length - 1; i >= 0; --i) {
    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  var directiveMatcher = getDirectiveMatcher(directives);
  var shouldRemoveField = function(nodeDirectives) {
    return isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some(function(config2) {
      return config2 && config2.remove;
    });
  };
  var originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  var firstVisitMadeChanges = false;
  var fieldOrInlineFragmentVisitor = {
    enter: function(node) {
      if (shouldRemoveField(node.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  var docWithoutDirectiveSubtrees = visit(doc, {
    // These two AST node types share the same implementation, defined above.
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter: function() {
        return false;
      }
    },
    Variable: {
      enter: function(node, _key, _parent, _path, ancestors) {
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node.name.value);
        }
      }
    },
    FragmentSpread: {
      enter: function(node, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        var inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter: function(node, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node);
      },
      leave: function(node, _key, _parent, path) {
        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node === originalNode) {
          return node;
        }
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          operationCount > 0 && node.selectionSet.selections.every(function(selection) {
            return selection.kind === Kind.FIELD && selection.name.value === "__typename";
          })
        ) {
          getInUseByFragmentName(node.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave: function(node) {
        if (directiveMatcher(node)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  var populateTransitiveVars = function(inUse) {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach(function(childFragmentName) {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function(varName) {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  var allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach(function(def) {
    if (def.kind === Kind.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function(childFragmentName) {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach(function(fragmentName) {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function(childFragmentName) {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  var fragmentWillBeRemoved = function(fragmentName) {
    return !!// A fragment definition will be removed if there are no spreads that refer
    // to it, or the fragment was explicitly removed because it had no fields
    // other than __typename.
    (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  };
  var enterVisitor = {
    enter: function(node) {
      if (fragmentWillBeRemoved(node.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: enterVisitor,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave: function(node) {
        if (node.variableDefinitions) {
          var usedVariableNames_1 = populateTransitiveVars(
            // If an operation is anonymous, we use the empty string as its key.
            getInUseByOperationName(node.name && node.name.value)
          ).transitiveVars;
          if (usedVariableNames_1.size < node.variableDefinitions.length) {
            return __assign(__assign({}, node), { variableDefinitions: node.variableDefinitions.filter(function(varDef) {
              return usedVariableNames_1.has(varDef.variable.name.value);
            }) });
          }
        }
      }
    }
  }));
}
var addTypenameToDocument = Object.assign(function(doc) {
  return visit(doc, {
    SelectionSet: {
      enter: function(node, _key, parent) {
        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
          return;
        }
        var selections = node.selections;
        if (!selections) {
          return;
        }
        var skip = selections.some(function(selection) {
          return isField(selection) && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        var field = parent;
        if (isField(field) && field.directives && field.directives.some(function(d) {
          return d.name.value === "export";
        })) {
          return;
        }
        return __assign(__assign({}, node), { selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false) });
      }
    }
  });
}, {
  added: function(field) {
    return field === TYPENAME_FIELD;
  }
});
function buildQueryFromSelectionSet(document2) {
  var definition = getMainDefinition(document2);
  var definitionOperation = definition.operation;
  if (definitionOperation === "query") {
    return document2;
  }
  var modifiedDoc = visit(document2, {
    OperationDefinition: {
      enter: function(node) {
        return __assign(__assign({}, node), { operation: "query" });
      }
    }
  });
  return modifiedDoc;
}
function removeClientSetsFromDocument(document2) {
  checkDocument(document2);
  var modifiedDoc = removeDirectivesFromDocument([
    {
      test: function(directive) {
        return directive.name.value === "client";
      },
      remove: true
    }
  ], document2);
  return modifiedDoc;
}
function addNonReactiveToNamedFragments(document2) {
  checkDocument(document2);
  return visit(document2, {
    FragmentSpread: function(node) {
      var _a;
      if ((_a = node.directives) === null || _a === void 0 ? void 0 : _a.some(function(directive) {
        return directive.name.value === "unmask";
      })) {
        return;
      }
      return __assign(__assign({}, node), { directives: __spreadArray(__spreadArray([], node.directives || [], true), [
        {
          kind: Kind.DIRECTIVE,
          name: { kind: Kind.NAME, value: "nonreactive" }
        }
      ], false) });
    }
  });
}
var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
function mergeDeep() {
  var sources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    sources[_i] = arguments[_i];
  }
  return mergeDeepArray(sources);
}
function mergeDeepArray(sources) {
  var target = sources[0] || {};
  var count = sources.length;
  if (count > 1) {
    var merger = new DeepMerger();
    for (var i = 1; i < count; ++i) {
      target = merger.merge(target, sources[i]);
    }
  }
  return target;
}
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = (
  /** @class */
  function() {
    function DeepMerger2(reconciler) {
      if (reconciler === void 0) {
        reconciler = defaultReconciler;
      }
      this.reconciler = reconciler;
      this.isObject = isNonNullObject;
      this.pastCopies = /* @__PURE__ */ new Set();
    }
    DeepMerger2.prototype.merge = function(target, source) {
      var _this = this;
      var context = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        context[_i - 2] = arguments[_i];
      }
      if (isNonNullObject(source) && isNonNullObject(target)) {
        Object.keys(source).forEach(function(sourceKey) {
          if (hasOwnProperty$4.call(target, sourceKey)) {
            var targetValue = target[sourceKey];
            if (source[sourceKey] !== targetValue) {
              var result = _this.reconciler.apply(_this, __spreadArray([
                target,
                source,
                sourceKey
              ], context, false));
              if (result !== targetValue) {
                target = _this.shallowCopyForMerge(target);
                target[sourceKey] = result;
              }
            }
          } else {
            target = _this.shallowCopyForMerge(target);
            target[sourceKey] = source[sourceKey];
          }
        });
        return target;
      }
      return source;
    };
    DeepMerger2.prototype.shallowCopyForMerge = function(value) {
      if (isNonNullObject(value)) {
        if (!this.pastCopies.has(value)) {
          if (Array.isArray(value)) {
            value = value.slice(0);
          } else {
            value = __assign({ __proto__: Object.getPrototypeOf(value) }, value);
          }
          this.pastCopies.add(value);
        }
      }
      return value;
    };
    return DeepMerger2;
  }()
);
function preventUnhandledRejection(promise) {
  promise.catch(function() {
  });
  return promise;
}
var toString = Object.prototype.toString;
function cloneDeep(value) {
  return cloneDeepHelper(value);
}
function cloneDeepHelper(val, seen) {
  switch (toString.call(val)) {
    case "[object Array]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_1 = val.slice(0);
      seen.set(val, copy_1);
      copy_1.forEach(function(child, i) {
        copy_1[i] = cloneDeepHelper(child, seen);
      });
      return copy_1;
    }
    case "[object Object]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      var copy_2 = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy_2);
      Object.keys(val).forEach(function(key) {
        copy_2[key] = cloneDeepHelper(val[key], seen);
      });
      return copy_2;
    }
    default:
      return val;
  }
}
function deepFreeze(value) {
  var workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach(function(obj) {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach(function(name2) {
        if (isNonNullObject(obj[name2]))
          workSet.add(obj[name2]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (globalThis.__DEV__ !== false && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e) {
      if (e instanceof TypeError)
        return null;
      throw e;
    }
  }
  return obj;
}
function maybeDeepFreeze(obj) {
  if (globalThis.__DEV__ !== false) {
    deepFreeze(obj);
  }
  return obj;
}
function iterateObserversSafely(observers2, method, argument) {
  var observersWithMethod = [];
  observers2.forEach(function(obs) {
    return obs[method] && observersWithMethod.push(obs);
  });
  observersWithMethod.forEach(function(obs) {
    return obs[method](argument);
  });
}
function asyncMap(observable, mapFn, catchFn) {
  return new Observable(function(observer) {
    var promiseQueue = {
      // Normally we would initialize promiseQueue to Promise.resolve(), but
      // in this case, for backwards compatibility, we need to be careful to
      // invoke the first callback synchronously.
      then: function(callback) {
        return new Promise(function(resolve) {
          return resolve(callback());
        });
      }
    };
    function makeCallback(examiner, key) {
      return function(arg) {
        if (examiner) {
          var both = function() {
            return observer.closed ? (
              /* will be swallowed */
              0
            ) : examiner(arg);
          };
          promiseQueue = promiseQueue.then(both, both).then(function(result) {
            return observer.next(result);
          }, function(error) {
            return observer.error(error);
          });
        } else {
          observer[key](arg);
        }
      };
    }
    var handler = {
      next: makeCallback(mapFn, "next"),
      error: makeCallback(catchFn, "error"),
      complete: function() {
        promiseQueue.then(function() {
          return observer.complete();
        });
      }
    };
    var sub = observable.subscribe(handler);
    return function() {
      return sub.unsubscribe();
    };
  });
}
function fixObservableSubclass(subclass) {
  function set(key) {
    Object.defineProperty(subclass, key, { value: Observable });
  }
  if (canUseSymbol && Symbol.species) {
    set(Symbol.species);
  }
  set("@@species");
  return subclass;
}
function isPromiseLike(value) {
  return value && typeof value.then === "function";
}
var Concast = (
  /** @class */
  function(_super) {
    __extends(Concast2, _super);
    function Concast2(sources) {
      var _this = _super.call(this, function(observer) {
        _this.addObserver(observer);
        return function() {
          return _this.removeObserver(observer);
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.promise = new Promise(function(resolve, reject) {
        _this.resolve = resolve;
        _this.reject = reject;
      });
      _this.handlers = {
        next: function(result) {
          if (_this.sub !== null) {
            _this.latest = ["next", result];
            _this.notify("next", result);
            iterateObserversSafely(_this.observers, "next", result);
          }
        },
        error: function(error) {
          var sub = _this.sub;
          if (sub !== null) {
            if (sub)
              setTimeout(function() {
                return sub.unsubscribe();
              });
            _this.sub = null;
            _this.latest = ["error", error];
            _this.reject(error);
            _this.notify("error", error);
            iterateObserversSafely(_this.observers, "error", error);
          }
        },
        complete: function() {
          var _a = _this, sub = _a.sub, _b = _a.sources, sources2 = _b === void 0 ? [] : _b;
          if (sub !== null) {
            var value = sources2.shift();
            if (!value) {
              if (sub)
                setTimeout(function() {
                  return sub.unsubscribe();
                });
              _this.sub = null;
              if (_this.latest && _this.latest[0] === "next") {
                _this.resolve(_this.latest[1]);
              } else {
                _this.resolve();
              }
              _this.notify("complete");
              iterateObserversSafely(_this.observers, "complete");
            } else if (isPromiseLike(value)) {
              value.then(function(obs) {
                return _this.sub = obs.subscribe(_this.handlers);
              }, _this.handlers.error);
            } else {
              _this.sub = value.subscribe(_this.handlers);
            }
          }
        }
      };
      _this.nextResultListeners = /* @__PURE__ */ new Set();
      _this.cancel = function(reason) {
        _this.reject(reason);
        _this.sources = [];
        _this.handlers.error(reason);
      };
      _this.promise.catch(function(_2) {
      });
      if (typeof sources === "function") {
        sources = [new Observable(sources)];
      }
      if (isPromiseLike(sources)) {
        sources.then(function(iterable) {
          return _this.start(iterable);
        }, _this.handlers.error);
      } else {
        _this.start(sources);
      }
      return _this;
    }
    Concast2.prototype.start = function(sources) {
      if (this.sub !== void 0)
        return;
      this.sources = Array.from(sources);
      this.handlers.complete();
    };
    Concast2.prototype.deliverLastMessage = function(observer) {
      if (this.latest) {
        var nextOrError = this.latest[0];
        var method = observer[nextOrError];
        if (method) {
          method.call(observer, this.latest[1]);
        }
        if (this.sub === null && nextOrError === "next" && observer.complete) {
          observer.complete();
        }
      }
    };
    Concast2.prototype.addObserver = function(observer) {
      if (!this.observers.has(observer)) {
        this.deliverLastMessage(observer);
        this.observers.add(observer);
      }
    };
    Concast2.prototype.removeObserver = function(observer) {
      if (this.observers.delete(observer) && this.observers.size < 1) {
        this.handlers.complete();
      }
    };
    Concast2.prototype.notify = function(method, arg) {
      var nextResultListeners = this.nextResultListeners;
      if (nextResultListeners.size) {
        this.nextResultListeners = /* @__PURE__ */ new Set();
        nextResultListeners.forEach(function(listener) {
          return listener(method, arg);
        });
      }
    };
    Concast2.prototype.beforeNext = function(callback) {
      var called = false;
      this.nextResultListeners.add(function(method, arg) {
        if (!called) {
          called = true;
          callback(method, arg);
        }
      });
    };
    return Concast2;
  }(Observable)
);
fixObservableSubclass(Concast);
function isExecutionPatchIncrementalResult(value) {
  return "incremental" in value;
}
function isExecutionPatchInitialResult(value) {
  return "hasNext" in value && "data" in value;
}
function isExecutionPatchResult(value) {
  return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);
}
function isApolloPayloadResult(value) {
  return isNonNullObject(value) && "payload" in value;
}
function mergeIncrementalData(prevResult, result) {
  var mergedData = prevResult;
  var merger = new DeepMerger();
  if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
    result.incremental.forEach(function(_a) {
      var data = _a.data, path = _a.path;
      for (var i = path.length - 1; i >= 0; --i) {
        var key = path[i];
        var isNumericKey = !isNaN(+key);
        var parent_1 = isNumericKey ? [] : {};
        parent_1[key] = data;
        data = parent_1;
      }
      mergedData = merger.merge(mergedData, data);
    });
  }
  return mergedData;
}
function graphQLResultHasError(result) {
  var errors = getGraphQLErrorsFromResult(result);
  return isNonEmptyArray(errors);
}
function getGraphQLErrorsFromResult(result) {
  var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
  if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
    result.incremental.forEach(function(incrementalResult) {
      if (incrementalResult.errors) {
        graphQLErrors.push.apply(graphQLErrors, incrementalResult.errors);
      }
    });
  }
  return graphQLErrors;
}
function compact() {
  var objects = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    objects[_i] = arguments[_i];
  }
  var result = /* @__PURE__ */ Object.create(null);
  objects.forEach(function(obj) {
    if (!obj)
      return;
    Object.keys(obj).forEach(function(key) {
      var value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}
function mergeOptions(defaults, options) {
  return compact(defaults, options, options.variables && {
    variables: compact(__assign(__assign({}, defaults && defaults.variables), options.variables))
  });
}
function fromError(errorValue) {
  return new Observable(function(observer) {
    observer.error(errorValue);
  });
}
var throwServerError = function(response, result, message) {
  var error = new Error(message);
  error.name = "ServerError";
  error.response = response;
  error.statusCode = response.status;
  error.result = result;
  throw error;
};
function validateOperation(operation) {
  var OPERATION_FIELDS = [
    "query",
    "operationName",
    "variables",
    "extensions",
    "context"
  ];
  for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {
    var key = _a[_i];
    if (OPERATION_FIELDS.indexOf(key) < 0) {
      throw newInvariantError(46, key);
    }
  }
  return operation;
}
function createOperation(starting, operation) {
  var context = __assign({}, starting);
  var setContext = function(next2) {
    if (typeof next2 === "function") {
      context = __assign(__assign({}, context), next2(context));
    } else {
      context = __assign(__assign({}, context), next2);
    }
  };
  var getContext = function() {
    return __assign({}, context);
  };
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  return operation;
}
function transformOperation(operation) {
  var transformedOperation = {
    variables: operation.variables || {},
    extensions: operation.extensions || {},
    operationName: operation.operationName,
    query: operation.query
  };
  if (!transformedOperation.operationName) {
    transformedOperation.operationName = typeof transformedOperation.query !== "string" ? getOperationName(transformedOperation.query) || void 0 : "";
  }
  return transformedOperation;
}
function filterOperationVariables(variables, query) {
  var result = __assign({}, variables);
  var unusedNames = new Set(Object.keys(variables));
  visit(query, {
    Variable: function(node, _key, parent) {
      if (parent && parent.kind !== "VariableDefinition") {
        unusedNames.delete(node.name.value);
      }
    }
  });
  unusedNames.forEach(function(name2) {
    delete result[name2];
  });
  return result;
}
function passthrough(op, forward) {
  return forward ? forward(op) : Observable.of();
}
function toLink(handler) {
  return typeof handler === "function" ? new ApolloLink(handler) : handler;
}
function isTerminating(link) {
  return link.request.length <= 1;
}
var ApolloLink = (
  /** @class */
  function() {
    function ApolloLink2(request) {
      if (request)
        this.request = request;
    }
    ApolloLink2.empty = function() {
      return new ApolloLink2(function() {
        return Observable.of();
      });
    };
    ApolloLink2.from = function(links) {
      if (links.length === 0)
        return ApolloLink2.empty();
      return links.map(toLink).reduce(function(x2, y) {
        return x2.concat(y);
      });
    };
    ApolloLink2.split = function(test2, left, right) {
      var leftLink = toLink(left);
      var rightLink = toLink(right || new ApolloLink2(passthrough));
      var ret;
      if (isTerminating(leftLink) && isTerminating(rightLink)) {
        ret = new ApolloLink2(function(operation) {
          return test2(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return test2(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();
        });
      }
      return Object.assign(ret, { left: leftLink, right: rightLink });
    };
    ApolloLink2.execute = function(link, operation) {
      return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();
    };
    ApolloLink2.concat = function(first, second) {
      var firstLink = toLink(first);
      if (isTerminating(firstLink)) {
        globalThis.__DEV__ !== false && invariant.warn(38, firstLink);
        return firstLink;
      }
      var nextLink = toLink(second);
      var ret;
      if (isTerminating(nextLink)) {
        ret = new ApolloLink2(function(operation) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op) || Observable.of();
          }) || Observable.of();
        });
      } else {
        ret = new ApolloLink2(function(operation, forward) {
          return firstLink.request(operation, function(op) {
            return nextLink.request(op, forward) || Observable.of();
          }) || Observable.of();
        });
      }
      return Object.assign(ret, { left: firstLink, right: nextLink });
    };
    ApolloLink2.prototype.split = function(test2, left, right) {
      return this.concat(ApolloLink2.split(test2, left, right || new ApolloLink2(passthrough)));
    };
    ApolloLink2.prototype.concat = function(next2) {
      return ApolloLink2.concat(this, next2);
    };
    ApolloLink2.prototype.request = function(operation, forward) {
      throw newInvariantError(39);
    };
    ApolloLink2.prototype.onError = function(error, observer) {
      if (observer && observer.error) {
        observer.error(error);
        return false;
      }
      throw error;
    };
    ApolloLink2.prototype.setOnError = function(fn) {
      this.onError = fn;
      return this;
    };
    return ApolloLink2;
  }()
);
var execute = ApolloLink.execute;
function asyncIterator(source) {
  var _a;
  var iterator = source[Symbol.asyncIterator]();
  return _a = {
    next: function() {
      return iterator.next();
    }
  }, _a[Symbol.asyncIterator] = function() {
    return this;
  }, _a;
}
function nodeStreamIterator(stream) {
  var cleanup = null;
  var error = null;
  var done = false;
  var data = [];
  var waiting = [];
  function onData(chunk) {
    if (error)
      return;
    if (waiting.length) {
      var shiftedArr = waiting.shift();
      if (Array.isArray(shiftedArr) && shiftedArr[0]) {
        return shiftedArr[0]({ value: chunk, done: false });
      }
    }
    data.push(chunk);
  }
  function onError(err) {
    error = err;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[1](err);
    });
    !cleanup || cleanup();
  }
  function onEnd() {
    done = true;
    var all = waiting.slice();
    all.forEach(function(pair) {
      pair[0]({ value: void 0, done: true });
    });
    !cleanup || cleanup();
  }
  cleanup = function() {
    cleanup = null;
    stream.removeListener("data", onData);
    stream.removeListener("error", onError);
    stream.removeListener("end", onEnd);
    stream.removeListener("finish", onEnd);
    stream.removeListener("close", onEnd);
  };
  stream.on("data", onData);
  stream.on("error", onError);
  stream.on("end", onEnd);
  stream.on("finish", onEnd);
  stream.on("close", onEnd);
  function getNext() {
    return new Promise(function(resolve, reject) {
      if (error)
        return reject(error);
      if (data.length)
        return resolve({ value: data.shift(), done: false });
      if (done)
        return resolve({ value: void 0, done: true });
      waiting.push([resolve, reject]);
    });
  }
  var iterator = {
    next: function() {
      return getNext();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function promiseIterator(promise) {
  var resolved = false;
  var iterator = {
    next: function() {
      if (resolved)
        return Promise.resolve({
          value: void 0,
          done: true
        });
      resolved = true;
      return new Promise(function(resolve, reject) {
        promise.then(function(value) {
          resolve({ value, done: false });
        }).catch(reject);
      });
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function readerIterator(reader) {
  var iterator = {
    next: function() {
      return reader.read();
    }
  };
  if (canUseAsyncIteratorSymbol) {
    iterator[Symbol.asyncIterator] = function() {
      return this;
    };
  }
  return iterator;
}
function isNodeResponse(value) {
  return !!value.body;
}
function isReadableStream(value) {
  return !!value.getReader;
}
function isAsyncIterableIterator(value) {
  return !!(canUseAsyncIteratorSymbol && value[Symbol.asyncIterator]);
}
function isStreamableBlob(value) {
  return !!value.stream;
}
function isBlob(value) {
  return !!value.arrayBuffer;
}
function isNodeReadableStream(value) {
  return !!value.pipe;
}
function responseIterator(response) {
  var body = response;
  if (isNodeResponse(response))
    body = response.body;
  if (isAsyncIterableIterator(body))
    return asyncIterator(body);
  if (isReadableStream(body))
    return readerIterator(body.getReader());
  if (isStreamableBlob(body)) {
    return readerIterator(body.stream().getReader());
  }
  if (isBlob(body))
    return promiseIterator(body.arrayBuffer());
  if (isNodeReadableStream(body))
    return nodeStreamIterator(body);
  throw new Error("Unknown body type for responseIterator. Please pass a streamable response.");
}
var PROTOCOL_ERRORS_SYMBOL = Symbol();
function graphQLResultHasProtocolErrors(result) {
  if (result.extensions) {
    return Array.isArray(result.extensions[PROTOCOL_ERRORS_SYMBOL]);
  }
  return false;
}
function isApolloError(err) {
  return err.hasOwnProperty("graphQLErrors");
}
var generateErrorMessage = function(err) {
  var errors = __spreadArray(__spreadArray(__spreadArray([], err.graphQLErrors, true), err.clientErrors, true), err.protocolErrors, true);
  if (err.networkError)
    errors.push(err.networkError);
  return errors.map(function(err2) {
    return isNonNullObject(err2) && err2.message || "Error message not found.";
  }).join("\n");
};
var ApolloError = (
  /** @class */
  function(_super) {
    __extends(ApolloError2, _super);
    function ApolloError2(_a) {
      var graphQLErrors = _a.graphQLErrors, protocolErrors = _a.protocolErrors, clientErrors = _a.clientErrors, networkError = _a.networkError, errorMessage = _a.errorMessage, extraInfo = _a.extraInfo;
      var _this = _super.call(this, errorMessage) || this;
      _this.name = "ApolloError";
      _this.graphQLErrors = graphQLErrors || [];
      _this.protocolErrors = protocolErrors || [];
      _this.clientErrors = clientErrors || [];
      _this.networkError = networkError || null;
      _this.message = errorMessage || generateErrorMessage(_this);
      _this.extraInfo = extraInfo;
      _this.cause = __spreadArray(__spreadArray(__spreadArray([
        networkError
      ], graphQLErrors || [], true), protocolErrors || [], true), clientErrors || [], true).find(function(e) {
        return !!e;
      }) || null;
      _this.__proto__ = ApolloError2.prototype;
      return _this;
    }
    return ApolloError2;
  }(Error)
);
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
function readMultipartBody(response, nextValue) {
  return __awaiter(this, void 0, void 0, function() {
    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _a, value, done, chunk, searchFrom, bi, message, i, headers, contentType_1, body, result, next2;
    var _b, _c;
    var _d;
    return __generator(this, function(_e) {
      switch (_e.label) {
        case 0:
          if (TextDecoder === void 0) {
            throw new Error("TextDecoder must be defined in the environment: please import a polyfill.");
          }
          decoder = new TextDecoder("utf-8");
          contentType = (_d = response.headers) === null || _d === void 0 ? void 0 : _d.get("content-type");
          delimiter = "boundary=";
          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['"]/g, "").replace(/\;(.*)/gm, "").trim() : "-";
          boundary = "\r\n--".concat(boundaryVal);
          buffer = "";
          iterator = responseIterator(response);
          running = true;
          _e.label = 1;
        case 1:
          if (!running)
            return [3, 3];
          return [4, iterator.next()];
        case 2:
          _a = _e.sent(), value = _a.value, done = _a.done;
          chunk = typeof value === "string" ? value : decoder.decode(value);
          searchFrom = buffer.length - boundary.length + 1;
          running = !done;
          buffer += chunk;
          bi = buffer.indexOf(boundary, searchFrom);
          while (bi > -1) {
            message = void 0;
            _b = [
              buffer.slice(0, bi),
              buffer.slice(bi + boundary.length)
            ], message = _b[0], buffer = _b[1];
            i = message.indexOf("\r\n\r\n");
            headers = parseHeaders(message.slice(0, i));
            contentType_1 = headers["content-type"];
            if (contentType_1 && contentType_1.toLowerCase().indexOf("application/json") === -1) {
              throw new Error("Unsupported patch content type: application/json is required.");
            }
            body = message.slice(i);
            if (body) {
              result = parseJsonBody(response, body);
              if (Object.keys(result).length > 1 || "data" in result || "incremental" in result || "errors" in result || "payload" in result) {
                if (isApolloPayloadResult(result)) {
                  next2 = {};
                  if ("payload" in result) {
                    if (Object.keys(result).length === 1 && result.payload === null) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    next2 = __assign({}, result.payload);
                  }
                  if ("errors" in result) {
                    next2 = __assign(__assign({}, next2), { extensions: __assign(__assign({}, "extensions" in next2 ? next2.extensions : null), (_c = {}, _c[PROTOCOL_ERRORS_SYMBOL] = result.errors, _c)) });
                  }
                  nextValue(next2);
                } else {
                  nextValue(result);
                }
              } else if (
                // If the chunk contains only a "hasNext: false", we can call
                // observer.complete() immediately.
                Object.keys(result).length === 1 && "hasNext" in result && !result.hasNext
              ) {
                return [
                  2
                  /*return*/
                ];
              }
            }
            bi = buffer.indexOf(boundary);
          }
          return [3, 1];
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function parseHeaders(headerText) {
  var headersInit = {};
  headerText.split("\n").forEach(function(line) {
    var i = line.indexOf(":");
    if (i > -1) {
      var name_1 = line.slice(0, i).trim().toLowerCase();
      var value = line.slice(i + 1).trim();
      headersInit[name_1] = value;
    }
  });
  return headersInit;
}
function parseJsonBody(response, bodyText) {
  if (response.status >= 300) {
    var getResult = function() {
      try {
        return JSON.parse(bodyText);
      } catch (err) {
        return bodyText;
      }
    };
    throwServerError(response, getResult(), "Response not successful: Received status code ".concat(response.status));
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    var parseError = err;
    parseError.name = "ServerParseError";
    parseError.response = response;
    parseError.statusCode = response.status;
    parseError.bodyText = bodyText;
    throw parseError;
  }
}
function handleError(err, observer) {
  if (err.result && err.result.errors && err.result.data) {
    observer.next(err.result);
  }
  observer.error(err);
}
function parseAndCheckHttpResponse(operations) {
  return function(response) {
    return response.text().then(function(bodyText) {
      return parseJsonBody(response, bodyText);
    }).then(function(result) {
      if (!Array.isArray(result) && !hasOwnProperty$3.call(result, "data") && !hasOwnProperty$3.call(result, "errors")) {
        throwServerError(response, result, "Server response was missing for query '".concat(Array.isArray(operations) ? operations.map(function(op) {
          return op.operationName;
        }) : operations.operationName, "'."));
      }
      return result;
    });
  };
}
var serializeFetchParameter = function(p, label) {
  var serialized;
  try {
    serialized = JSON.stringify(p);
  } catch (e) {
    var parseError = newInvariantError(42, label, e.message);
    parseError.parseError = e;
    throw parseError;
  }
  return serialized;
};
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: false,
  preserveHeaderCase: false
};
var defaultHeaders = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "*/*",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
};
var defaultOptions = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions
};
var defaultPrinter = function(ast, printer) {
  return printer(ast);
};
function selectHttpOptionsAndBodyInternal(operation, printer) {
  var configs = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    configs[_i - 2] = arguments[_i];
  }
  var options = {};
  var http = {};
  configs.forEach(function(config2) {
    options = __assign(__assign(__assign({}, options), config2.options), { headers: __assign(__assign({}, options.headers), config2.headers) });
    if (config2.credentials) {
      options.credentials = config2.credentials;
    }
    http = __assign(__assign({}, http), config2.http);
  });
  if (options.headers) {
    options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
  }
  var operationName2 = operation.operationName, extensions = operation.extensions, variables = operation.variables, query = operation.query;
  var body = { operationName: operationName2, variables };
  if (http.includeExtensions)
    body.extensions = extensions;
  if (http.includeQuery)
    body.query = printer(query, print);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    var normalizedHeaders_1 = {};
    Object.keys(Object(headers)).forEach(function(name2) {
      normalizedHeaders_1[name2.toLowerCase()] = headers[name2];
    });
    return normalizedHeaders_1;
  }
  var headerData = {};
  Object.keys(Object(headers)).forEach(function(name2) {
    headerData[name2.toLowerCase()] = {
      originalName: name2,
      value: headers[name2]
    };
  });
  var normalizedHeaders = {};
  Object.keys(headerData).forEach(function(name2) {
    normalizedHeaders[headerData[name2].originalName] = headerData[name2].value;
  });
  return normalizedHeaders;
}
var checkFetcher = function(fetcher) {
  if (!fetcher && typeof fetch === "undefined") {
    throw newInvariantError(40);
  }
};
var selectURI = function(operation, fallbackURI) {
  var context = operation.getContext();
  var contextURI = context.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};
function rewriteURIForGET(chosenURI, body) {
  var queryParams = [];
  var addQueryParam = function(key, value) {
    queryParams.push("".concat(key, "=").concat(encodeURIComponent(value)));
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    var serializedVariables = void 0;
    try {
      serializedVariables = serializeFetchParameter(body.variables, "Variables map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    var serializedExtensions = void 0;
    try {
      serializedExtensions = serializeFetchParameter(body.extensions, "Extensions map");
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  var fragment = "", preFragment = chosenURI;
  var fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  var queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  var newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}
var backupFetch = maybe(function() {
  return fetch;
});
var createHttpLink = function(linkOptions) {
  if (linkOptions === void 0) {
    linkOptions = {};
  }
  var _a = linkOptions.uri, uri = _a === void 0 ? "/graphql" : _a, preferredFetch = linkOptions.fetch, _b = linkOptions.print, print2 = _b === void 0 ? defaultPrinter : _b, includeExtensions = linkOptions.includeExtensions, preserveHeaderCase = linkOptions.preserveHeaderCase, useGETForQueries = linkOptions.useGETForQueries, _c = linkOptions.includeUnusedVariables, includeUnusedVariables = _c === void 0 ? false : _c, requestOptions = __rest(linkOptions, ["uri", "fetch", "print", "includeExtensions", "preserveHeaderCase", "useGETForQueries", "includeUnusedVariables"]);
  if (globalThis.__DEV__ !== false) {
    checkFetcher(preferredFetch || backupFetch);
  }
  var linkConfig = {
    http: { includeExtensions, preserveHeaderCase },
    options: requestOptions.fetchOptions,
    credentials: requestOptions.credentials,
    headers: requestOptions.headers
  };
  return new ApolloLink(function(operation) {
    var chosenURI = selectURI(operation, uri);
    var context = operation.getContext();
    var clientAwarenessHeaders = {};
    if (context.clientAwareness) {
      var _a2 = context.clientAwareness, name_1 = _a2.name, version2 = _a2.version;
      if (name_1) {
        clientAwarenessHeaders["apollographql-client-name"] = name_1;
      }
      if (version2) {
        clientAwarenessHeaders["apollographql-client-version"] = version2;
      }
    }
    var contextHeaders = __assign(__assign({}, clientAwarenessHeaders), context.headers);
    var contextConfig = {
      http: context.http,
      options: context.fetchOptions,
      credentials: context.credentials,
      headers: contextHeaders
    };
    if (hasDirectives(["client"], operation.query)) {
      var transformedQuery = removeClientSetsFromDocument(operation.query);
      if (!transformedQuery) {
        return fromError(new Error("HttpLink: Trying to send a client-only query to the server. To send to the server, ensure a non-client field is added to the query or set the `transformOptions.removeClientFields` option to `true`."));
      }
      operation.query = transformedQuery;
    }
    var _b2 = selectHttpOptionsAndBodyInternal(operation, print2, fallbackHttpConfig, linkConfig, contextConfig), options = _b2.options, body = _b2.body;
    if (body.variables && !includeUnusedVariables) {
      body.variables = filterOperationVariables(body.variables, operation.query);
    }
    var controller;
    if (!options.signal && typeof AbortController !== "undefined") {
      controller = new AbortController();
      options.signal = controller.signal;
    }
    var definitionIsMutation = function(d) {
      return d.kind === "OperationDefinition" && d.operation === "mutation";
    };
    var definitionIsSubscription = function(d) {
      return d.kind === "OperationDefinition" && d.operation === "subscription";
    };
    var isSubscription = definitionIsSubscription(getMainDefinition(operation.query));
    var hasDefer = hasDirectives(["defer"], operation.query);
    if (useGETForQueries && !operation.query.definitions.some(definitionIsMutation)) {
      options.method = "GET";
    }
    if (hasDefer || isSubscription) {
      options.headers = options.headers || {};
      var acceptHeader = "multipart/mixed;";
      if (isSubscription && hasDefer) {
        globalThis.__DEV__ !== false && invariant.warn(41);
      }
      if (isSubscription) {
        acceptHeader += "boundary=graphql;subscriptionSpec=1.0,application/json";
      } else if (hasDefer) {
        acceptHeader += "deferSpec=20220824,application/json";
      }
      options.headers.accept = acceptHeader;
    }
    if (options.method === "GET") {
      var _c2 = rewriteURIForGET(chosenURI, body), newURI = _c2.newURI, parseError = _c2.parseError;
      if (parseError) {
        return fromError(parseError);
      }
      chosenURI = newURI;
    } else {
      try {
        options.body = serializeFetchParameter(body, "Payload");
      } catch (parseError2) {
        return fromError(parseError2);
      }
    }
    return new Observable(function(observer) {
      var currentFetch = preferredFetch || maybe(function() {
        return fetch;
      }) || backupFetch;
      var observerNext = observer.next.bind(observer);
      currentFetch(chosenURI, options).then(function(response) {
        var _a3;
        operation.setContext({ response });
        var ctype = (_a3 = response.headers) === null || _a3 === void 0 ? void 0 : _a3.get("content-type");
        if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
          return readMultipartBody(response, observerNext);
        } else {
          return parseAndCheckHttpResponse(operation)(response).then(observerNext);
        }
      }).then(function() {
        controller = void 0;
        observer.complete();
      }).catch(function(err) {
        controller = void 0;
        handleError(err, observer);
      });
      return function() {
        if (controller)
          controller.abort();
      };
    });
  });
};
var HttpLink = (
  /** @class */
  function(_super) {
    __extends(HttpLink2, _super);
    function HttpLink2(options) {
      if (options === void 0) {
        options = {};
      }
      var _this = _super.call(this, createHttpLink(options).request) || this;
      _this.options = options;
      return _this;
    }
    return HttpLink2;
  }(ApolloLink)
);
function equalByQuery(query, _a, _b, variables) {
  var aData = _a.data, aRest = __rest(_a, ["data"]);
  var bData = _b.data, bRest = __rest(_b, ["data"]);
  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
    variables
  });
}
function equalBySelectionSet(selectionSet, aResult, bResult, context) {
  if (aResult === bResult) {
    return true;
  }
  var seenSelections = /* @__PURE__ */ new Set();
  return selectionSet.selections.every(function(selection) {
    if (seenSelections.has(selection))
      return true;
    seenSelections.add(selection);
    if (!shouldInclude(selection, context.variables))
      return true;
    if (selectionHasNonreactiveDirective(selection))
      return true;
    if (isField(selection)) {
      var resultKey = resultKeyNameFromField(selection);
      var aResultChild = aResult && aResult[resultKey];
      var bResultChild = bResult && bResult[resultKey];
      var childSelectionSet = selection.selectionSet;
      if (!childSelectionSet) {
        return equal(aResultChild, bResultChild);
      }
      var aChildIsArray = Array.isArray(aResultChild);
      var bChildIsArray = Array.isArray(bResultChild);
      if (aChildIsArray !== bChildIsArray)
        return false;
      if (aChildIsArray && bChildIsArray) {
        var length_1 = aResultChild.length;
        if (bResultChild.length !== length_1) {
          return false;
        }
        for (var i = 0; i < length_1; ++i) {
          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
            return false;
          }
        }
        return true;
      }
      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
    } else {
      var fragment = getFragmentFromSelection(selection, context.fragmentMap);
      if (fragment) {
        if (selectionHasNonreactiveDirective(fragment))
          return true;
        return equalBySelectionSet(
          fragment.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          aResult,
          bResult,
          context
        );
      }
    }
  });
}
function selectionHasNonreactiveDirective(selection) {
  return !!selection.directives && selection.directives.some(directiveIsNonreactive);
}
function directiveIsNonreactive(dir) {
  return dir.name.value === "nonreactive";
}
var MapImpl = canUseWeakMap ? WeakMap : Map;
var SetImpl = canUseWeakSet ? WeakSet : Set;
var disableWarningsSlot = new Slot();
var issuedWarning = false;
function warnOnImproperCacheImplementation() {
  if (!issuedWarning) {
    issuedWarning = true;
    globalThis.__DEV__ !== false && invariant.warn(52);
  }
}
function maskDefinition(data, selectionSet, context) {
  return disableWarningsSlot.withValue(true, function() {
    var masked = maskSelectionSet(data, selectionSet, context, false);
    if (Object.isFrozen(data)) {
      maybeDeepFreeze(masked);
    }
    return masked;
  });
}
function getMutableTarget(data, mutableTargets) {
  if (mutableTargets.has(data)) {
    return mutableTargets.get(data);
  }
  var mutableTarget = Array.isArray(data) ? [] : /* @__PURE__ */ Object.create(null);
  mutableTargets.set(data, mutableTarget);
  return mutableTarget;
}
function maskSelectionSet(data, selectionSet, context, migration, path) {
  var _a;
  var knownChanged = context.knownChanged;
  var memo2 = getMutableTarget(data, context.mutableTargets);
  if (Array.isArray(data)) {
    for (var _i = 0, _b = Array.from(data.entries()); _i < _b.length; _i++) {
      var _c = _b[_i], index = _c[0], item = _c[1];
      if (item === null) {
        memo2[index] = null;
        continue;
      }
      var masked = maskSelectionSet(item, selectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", "[").concat(index, "]") : void 0);
      if (knownChanged.has(masked)) {
        knownChanged.add(memo2);
      }
      memo2[index] = masked;
    }
    return knownChanged.has(memo2) ? memo2 : data;
  }
  for (var _d = 0, _e = selectionSet.selections; _d < _e.length; _d++) {
    var selection = _e[_d];
    var value = void 0;
    if (migration) {
      knownChanged.add(memo2);
    }
    if (selection.kind === Kind.FIELD) {
      var keyName = resultKeyNameFromField(selection);
      var childSelectionSet = selection.selectionSet;
      value = memo2[keyName] || data[keyName];
      if (value === void 0) {
        continue;
      }
      if (childSelectionSet && value !== null) {
        var masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, globalThis.__DEV__ !== false ? "".concat(path || "", ".").concat(keyName) : void 0);
        if (knownChanged.has(masked)) {
          value = masked;
        }
      }
      if (!(globalThis.__DEV__ !== false)) {
        memo2[keyName] = value;
      }
      if (globalThis.__DEV__ !== false) {
        if (migration && keyName !== "__typename" && // either the field is not present in the memo object
        // or it has a `get` descriptor, not a `value` descriptor
        // => it is a warning accessor and we can overwrite it
        // with another accessor
        !((_a = Object.getOwnPropertyDescriptor(memo2, keyName)) === null || _a === void 0 ? void 0 : _a.value)) {
          Object.defineProperty(memo2, keyName, getAccessorWarningDescriptor(keyName, value, path || "", context.operationName, context.operationType));
        } else {
          delete memo2[keyName];
          memo2[keyName] = value;
        }
      }
    }
    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {
      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);
    }
    if (selection.kind === Kind.FRAGMENT_SPREAD) {
      var fragmentName = selection.name.value;
      var fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));
      invariant(fragment, 47, fragmentName);
      var mode = getFragmentMaskMode(selection);
      if (mode !== "mask") {
        value = maskSelectionSet(data, fragment.selectionSet, context, mode === "migrate", path);
      }
    }
    if (knownChanged.has(value)) {
      knownChanged.add(memo2);
    }
  }
  if ("__typename" in data && !("__typename" in memo2)) {
    memo2.__typename = data.__typename;
  }
  if (Object.keys(memo2).length !== Object.keys(data).length) {
    knownChanged.add(memo2);
  }
  return knownChanged.has(memo2) ? memo2 : data;
}
function getAccessorWarningDescriptor(fieldName, value, path, operationName2, operationType) {
  var getValue = function() {
    if (disableWarningsSlot.getValue()) {
      return value;
    }
    globalThis.__DEV__ !== false && invariant.warn(48, operationName2 ? "".concat(operationType, " '").concat(operationName2, "'") : "anonymous ".concat(operationType), "".concat(path, ".").concat(fieldName).replace(/^\./, ""));
    getValue = function() {
      return value;
    };
    return value;
  };
  return {
    get: function() {
      return getValue();
    },
    set: function(newValue) {
      getValue = function() {
        return newValue;
      };
    },
    enumerable: true,
    configurable: true
  };
}
function maskFragment(data, document2, cache2, fragmentName) {
  if (!cache2.fragmentMatches) {
    if (globalThis.__DEV__ !== false) {
      warnOnImproperCacheImplementation();
    }
    return data;
  }
  var fragments = document2.definitions.filter(function(node) {
    return node.kind === Kind.FRAGMENT_DEFINITION;
  });
  if (typeof fragmentName === "undefined") {
    invariant(fragments.length === 1, 49, fragments.length);
    fragmentName = fragments[0].name.value;
  }
  var fragment = fragments.find(function(fragment2) {
    return fragment2.name.value === fragmentName;
  });
  invariant(!!fragment, 50, fragmentName);
  if (data == null) {
    return data;
  }
  if (equal(data, {})) {
    return data;
  }
  return maskDefinition(data, fragment.selectionSet, {
    operationType: "fragment",
    operationName: fragment.name.value,
    fragmentMap: createFragmentMap(getFragmentDefinitions(document2)),
    cache: cache2,
    mutableTargets: new MapImpl(),
    knownChanged: new SetImpl()
  });
}
function maskOperation(data, document2, cache2) {
  var _a;
  if (!cache2.fragmentMatches) {
    if (globalThis.__DEV__ !== false) {
      warnOnImproperCacheImplementation();
    }
    return data;
  }
  var definition = getOperationDefinition(document2);
  invariant(definition, 51);
  if (data == null) {
    return data;
  }
  return maskDefinition(data, definition.selectionSet, {
    operationType: definition.operation,
    operationName: (_a = definition.name) === null || _a === void 0 ? void 0 : _a.value,
    fragmentMap: createFragmentMap(getFragmentDefinitions(document2)),
    cache: cache2,
    mutableTargets: new MapImpl(),
    knownChanged: new SetImpl()
  });
}
var ApolloCache = (
  /** @class */
  function() {
    function ApolloCache2() {
      this.assumeImmutableResults = false;
      this.getFragmentDoc = wrap$2(getFragmentQueryDocument, {
        max: cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
        cache: WeakCache
      });
    }
    ApolloCache2.prototype.lookupFragment = function(fragmentName) {
      return null;
    };
    ApolloCache2.prototype.batch = function(options) {
      var _this = this;
      var optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
      var updateResult;
      this.performTransaction(function() {
        return updateResult = options.update(_this);
      }, optimisticId);
      return updateResult;
    };
    ApolloCache2.prototype.recordOptimisticTransaction = function(transaction, optimisticId) {
      this.performTransaction(transaction, optimisticId);
    };
    ApolloCache2.prototype.transformDocument = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.transformForLink = function(document2) {
      return document2;
    };
    ApolloCache2.prototype.identify = function(object) {
      return;
    };
    ApolloCache2.prototype.gc = function() {
      return [];
    };
    ApolloCache2.prototype.modify = function(options) {
      return false;
    };
    ApolloCache2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign(__assign({}, options), { rootId: options.id || "ROOT_QUERY", optimistic }));
    };
    ApolloCache2.prototype.watchFragment = function(options) {
      var _this = this;
      var fragment = options.fragment, fragmentName = options.fragmentName, from2 = options.from, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, otherOptions = __rest(options, ["fragment", "fragmentName", "from", "optimistic"]);
      var query = this.getFragmentDoc(fragment, fragmentName);
      var id2 = typeof from2 === "undefined" || typeof from2 === "string" ? from2 : this.identify(from2);
      var dataMasking = !!options[Symbol.for("apollo.dataMasking")];
      if (globalThis.__DEV__ !== false) {
        var actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;
        if (!id2) {
          globalThis.__DEV__ !== false && invariant.warn(1, actualFragmentName);
        }
      }
      var diffOptions = __assign(__assign({}, otherOptions), { returnPartialData: true, id: id2, query, optimistic });
      var latestDiff;
      return new Observable(function(observer) {
        return _this.watch(__assign(__assign({}, diffOptions), { immediate: true, callback: function(diff) {
          var data = dataMasking ? maskFragment(diff.result, fragment, _this, fragmentName) : diff.result;
          if (
            // Always ensure we deliver the first result
            latestDiff && equalByQuery(query, { data: latestDiff === null || latestDiff === void 0 ? void 0 : latestDiff.result }, { data })
          ) {
            return;
          }
          var result = {
            data,
            complete: !!diff.complete
          };
          if (diff.missing) {
            result.missing = mergeDeepArray(diff.missing.map(function(error) {
              return error.missing;
            }));
          }
          latestDiff = __assign(__assign({}, diff), { result: data });
          observer.next(result);
        } }));
      });
    };
    ApolloCache2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = !!options.optimistic;
      }
      return this.read(__assign(__assign({}, options), { query: this.getFragmentDoc(options.fragment, options.fragmentName), rootId: options.id, optimistic }));
    };
    ApolloCache2.prototype.writeQuery = function(_a) {
      var id2 = _a.id, data = _a.data, options = __rest(_a, ["id", "data"]);
      return this.write(Object.assign(options, {
        dataId: id2 || "ROOT_QUERY",
        result: data
      }));
    };
    ApolloCache2.prototype.writeFragment = function(_a) {
      var id2 = _a.id, data = _a.data, fragment = _a.fragment, fragmentName = _a.fragmentName, options = __rest(_a, ["id", "data", "fragment", "fragmentName"]);
      return this.write(Object.assign(options, {
        query: this.getFragmentDoc(fragment, fragmentName),
        dataId: id2,
        result: data
      }));
    };
    ApolloCache2.prototype.updateQuery = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readQuery(options);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeQuery(__assign(__assign({}, options), { data }));
          return data;
        }
      });
    };
    ApolloCache2.prototype.updateFragment = function(options, update) {
      return this.batch({
        update: function(cache2) {
          var value = cache2.readFragment(options);
          var data = update(value);
          if (data === void 0 || data === null)
            return value;
          cache2.writeFragment(__assign(__assign({}, options), { data }));
          return data;
        }
      });
    };
    return ApolloCache2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
}
var MissingFieldError = (
  /** @class */
  function(_super) {
    __extends(MissingFieldError2, _super);
    function MissingFieldError2(message, path, query, variables) {
      var _a;
      var _this = _super.call(this, message) || this;
      _this.message = message;
      _this.path = path;
      _this.query = query;
      _this.variables = variables;
      if (Array.isArray(_this.path)) {
        _this.missing = _this.message;
        for (var i = _this.path.length - 1; i >= 0; --i) {
          _this.missing = (_a = {}, _a[_this.path[i]] = _this.missing, _a);
        }
      } else {
        _this.missing = _this.path;
      }
      _this.__proto__ = MissingFieldError2.prototype;
      return _this;
    }
    return MissingFieldError2;
  }(Error)
);
var hasOwn$1 = Object.prototype.hasOwnProperty;
function isNullish(value) {
  return value === null || value === void 0;
}
function defaultDataIdFromObject(_a, context) {
  var __typename = _a.__typename, id2 = _a.id, _id = _a._id;
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = !isNullish(id2) ? { id: id2 } : !isNullish(_id) ? { _id } : void 0;
    }
    if (isNullish(id2) && !isNullish(_id)) {
      id2 = _id;
    }
    if (!isNullish(id2)) {
      return "".concat(__typename, ":").concat(typeof id2 === "number" || typeof id2 === "string" ? id2 : JSON.stringify(id2));
    }
  }
}
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  addTypename: true,
  resultCaching: true,
  // Thanks to the shouldCanonizeResults helper, this should be the only line
  // you have to change to reenable canonization by default in the future.
  canonizeResults: false
};
function normalizeConfig(config2) {
  return compact(defaultConfig, config2);
}
function shouldCanonizeResults(config2) {
  var value = config2.canonizeResults;
  return value === void 0 ? defaultConfig.canonizeResults : value;
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  var match2 = storeFieldName.match(TypeOrFieldNameRegExp);
  return match2 ? match2[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (isNonNullObject(result)) {
    return isArray(result) ? result.every(function(item) {
      return selectionSetMatchesResult(selectionSet, item, variables);
    }) : selectionSet.selections.every(function(field) {
      if (isField(field) && shouldInclude(field, variables)) {
        var key = resultKeyNameFromField(field);
        return hasOwn$1.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document2, fragments) {
  var fragmentMap = createFragmentMap(getFragmentDefinitions(document2));
  return {
    fragmentMap,
    lookupFragment: function(name2) {
      var def = fragmentMap[name2];
      if (!def && fragments) {
        def = fragments.lookup(name2);
      }
      return def || null;
    }
  };
}
var DELETE = /* @__PURE__ */ Object.create(null);
var delModifier = function() {
  return DELETE;
};
var INVALIDATE = /* @__PURE__ */ Object.create(null);
var EntityStore = (
  /** @class */
  function() {
    function EntityStore2(policies, group) {
      var _this = this;
      this.policies = policies;
      this.group = group;
      this.data = /* @__PURE__ */ Object.create(null);
      this.rootIds = /* @__PURE__ */ Object.create(null);
      this.refs = /* @__PURE__ */ Object.create(null);
      this.getFieldValue = function(objectOrReference, storeFieldName) {
        return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);
      };
      this.canRead = function(objOrRef) {
        return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === "object";
      };
      this.toReference = function(objOrIdOrRef, mergeIntoStore) {
        if (typeof objOrIdOrRef === "string") {
          return makeReference(objOrIdOrRef);
        }
        if (isReference(objOrIdOrRef)) {
          return objOrIdOrRef;
        }
        var id2 = _this.policies.identify(objOrIdOrRef)[0];
        if (id2) {
          var ref = makeReference(id2);
          if (mergeIntoStore) {
            _this.merge(id2, objOrIdOrRef);
          }
          return ref;
        }
      };
    }
    EntityStore2.prototype.toObject = function() {
      return __assign({}, this.data);
    };
    EntityStore2.prototype.has = function(dataId) {
      return this.lookup(dataId, true) !== void 0;
    };
    EntityStore2.prototype.get = function(dataId, fieldName) {
      this.group.depend(dataId, fieldName);
      if (hasOwn$1.call(this.data, dataId)) {
        var storeObject = this.data[dataId];
        if (storeObject && hasOwn$1.call(storeObject, fieldName)) {
          return storeObject[fieldName];
        }
      }
      if (fieldName === "__typename" && hasOwn$1.call(this.policies.rootTypenamesById, dataId)) {
        return this.policies.rootTypenamesById[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.get(dataId, fieldName);
      }
    };
    EntityStore2.prototype.lookup = function(dataId, dependOnExistence) {
      if (dependOnExistence)
        this.group.depend(dataId, "__exists");
      if (hasOwn$1.call(this.data, dataId)) {
        return this.data[dataId];
      }
      if (this instanceof Layer) {
        return this.parent.lookup(dataId, dependOnExistence);
      }
      if (this.policies.rootTypenamesById[dataId]) {
        return /* @__PURE__ */ Object.create(null);
      }
    };
    EntityStore2.prototype.merge = function(older, newer) {
      var _this = this;
      var dataId;
      if (isReference(older))
        older = older.__ref;
      if (isReference(newer))
        newer = newer.__ref;
      var existing = typeof older === "string" ? this.lookup(dataId = older) : older;
      var incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
      if (!incoming)
        return;
      invariant(typeof dataId === "string", 2);
      var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
      this.data[dataId] = merged;
      if (merged !== existing) {
        delete this.refs[dataId];
        if (this.group.caching) {
          var fieldsToDirty_1 = /* @__PURE__ */ Object.create(null);
          if (!existing)
            fieldsToDirty_1.__exists = 1;
          Object.keys(incoming).forEach(function(storeFieldName) {
            if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
              fieldsToDirty_1[storeFieldName] = 1;
              var fieldName = fieldNameFromStoreName(storeFieldName);
              if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {
                fieldsToDirty_1[fieldName] = 1;
              }
              if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {
                delete merged[storeFieldName];
              }
            }
          });
          if (fieldsToDirty_1.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
          // automatically from store.get, we don't need to dirty the
          // ROOT_QUERY.__typename field if merged.__typename is equal
          // to the default string (usually "Query").
          this.policies.rootTypenamesById[dataId] === merged.__typename) {
            delete fieldsToDirty_1.__typename;
          }
          Object.keys(fieldsToDirty_1).forEach(function(fieldName) {
            return _this.group.dirty(dataId, fieldName);
          });
        }
      }
    };
    EntityStore2.prototype.modify = function(dataId, fields) {
      var _this = this;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var changedFields_1 = /* @__PURE__ */ Object.create(null);
        var needToMerge_1 = false;
        var allDeleted_1 = true;
        var sharedDetails_1 = {
          DELETE,
          INVALIDATE,
          isReference,
          toReference: this.toReference,
          canRead: this.canRead,
          readField: function(fieldNameOrOptions, from2) {
            return _this.policies.readField(typeof fieldNameOrOptions === "string" ? {
              fieldName: fieldNameOrOptions,
              from: from2 || makeReference(dataId)
            } : fieldNameOrOptions, { store: _this });
          }
        };
        Object.keys(storeObject).forEach(function(storeFieldName) {
          var fieldName = fieldNameFromStoreName(storeFieldName);
          var fieldValue = storeObject[storeFieldName];
          if (fieldValue === void 0)
            return;
          var modify = typeof fields === "function" ? fields : fields[storeFieldName] || fields[fieldName];
          if (modify) {
            var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), { fieldName, storeFieldName, storage: _this.getStorage(dataId, storeFieldName) }));
            if (newValue === INVALIDATE) {
              _this.group.dirty(dataId, storeFieldName);
            } else {
              if (newValue === DELETE)
                newValue = void 0;
              if (newValue !== fieldValue) {
                changedFields_1[storeFieldName] = newValue;
                needToMerge_1 = true;
                fieldValue = newValue;
                if (globalThis.__DEV__ !== false) {
                  var checkReference = function(ref) {
                    if (_this.lookup(ref.__ref) === void 0) {
                      globalThis.__DEV__ !== false && invariant.warn(3, ref);
                      return true;
                    }
                  };
                  if (isReference(newValue)) {
                    checkReference(newValue);
                  } else if (Array.isArray(newValue)) {
                    var seenReference = false;
                    var someNonReference = void 0;
                    for (var _i = 0, newValue_1 = newValue; _i < newValue_1.length; _i++) {
                      var value = newValue_1[_i];
                      if (isReference(value)) {
                        seenReference = true;
                        if (checkReference(value))
                          break;
                      } else {
                        if (typeof value === "object" && !!value) {
                          var id2 = _this.policies.identify(value)[0];
                          if (id2) {
                            someNonReference = value;
                          }
                        }
                      }
                      if (seenReference && someNonReference !== void 0) {
                        globalThis.__DEV__ !== false && invariant.warn(4, someNonReference);
                        break;
                      }
                    }
                  }
                }
              }
            }
          }
          if (fieldValue !== void 0) {
            allDeleted_1 = false;
          }
        });
        if (needToMerge_1) {
          this.merge(dataId, changedFields_1);
          if (allDeleted_1) {
            if (this instanceof Layer) {
              this.data[dataId] = void 0;
            } else {
              delete this.data[dataId];
            }
            this.group.dirty(dataId, "__exists");
          }
          return true;
        }
      }
      return false;
    };
    EntityStore2.prototype.delete = function(dataId, fieldName, args) {
      var _a;
      var storeObject = this.lookup(dataId);
      if (storeObject) {
        var typename = this.getFieldValue(storeObject, "__typename");
        var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
        return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);
      }
      return false;
    };
    EntityStore2.prototype.evict = function(options, limit) {
      var evicted = false;
      if (options.id) {
        if (hasOwn$1.call(this.data, options.id)) {
          evicted = this.delete(options.id, options.fieldName, options.args);
        }
        if (this instanceof Layer && this !== limit) {
          evicted = this.parent.evict(options, limit) || evicted;
        }
        if (options.fieldName || evicted) {
          this.group.dirty(options.id, options.fieldName || "__exists");
        }
      }
      return evicted;
    };
    EntityStore2.prototype.clear = function() {
      this.replace(null);
    };
    EntityStore2.prototype.extract = function() {
      var _this = this;
      var obj = this.toObject();
      var extraRootIds = [];
      this.getRootIdSet().forEach(function(id2) {
        if (!hasOwn$1.call(_this.policies.rootTypenamesById, id2)) {
          extraRootIds.push(id2);
        }
      });
      if (extraRootIds.length) {
        obj.__META = { extraRootIds: extraRootIds.sort() };
      }
      return obj;
    };
    EntityStore2.prototype.replace = function(newData) {
      var _this = this;
      Object.keys(this.data).forEach(function(dataId) {
        if (!(newData && hasOwn$1.call(newData, dataId))) {
          _this.delete(dataId);
        }
      });
      if (newData) {
        var __META = newData.__META, rest_1 = __rest(newData, ["__META"]);
        Object.keys(rest_1).forEach(function(dataId) {
          _this.merge(dataId, rest_1[dataId]);
        });
        if (__META) {
          __META.extraRootIds.forEach(this.retain, this);
        }
      }
    };
    EntityStore2.prototype.retain = function(rootId) {
      return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
    };
    EntityStore2.prototype.release = function(rootId) {
      if (this.rootIds[rootId] > 0) {
        var count = --this.rootIds[rootId];
        if (!count)
          delete this.rootIds[rootId];
        return count;
      }
      return 0;
    };
    EntityStore2.prototype.getRootIdSet = function(ids) {
      if (ids === void 0) {
        ids = /* @__PURE__ */ new Set();
      }
      Object.keys(this.rootIds).forEach(ids.add, ids);
      if (this instanceof Layer) {
        this.parent.getRootIdSet(ids);
      } else {
        Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
      }
      return ids;
    };
    EntityStore2.prototype.gc = function() {
      var _this = this;
      var ids = this.getRootIdSet();
      var snapshot = this.toObject();
      ids.forEach(function(id2) {
        if (hasOwn$1.call(snapshot, id2)) {
          Object.keys(_this.findChildRefIds(id2)).forEach(ids.add, ids);
          delete snapshot[id2];
        }
      });
      var idsToRemove = Object.keys(snapshot);
      if (idsToRemove.length) {
        var root_1 = this;
        while (root_1 instanceof Layer)
          root_1 = root_1.parent;
        idsToRemove.forEach(function(id2) {
          return root_1.delete(id2);
        });
      }
      return idsToRemove;
    };
    EntityStore2.prototype.findChildRefIds = function(dataId) {
      if (!hasOwn$1.call(this.refs, dataId)) {
        var found_1 = this.refs[dataId] = /* @__PURE__ */ Object.create(null);
        var root = this.data[dataId];
        if (!root)
          return found_1;
        var workSet_1 = /* @__PURE__ */ new Set([root]);
        workSet_1.forEach(function(obj) {
          if (isReference(obj)) {
            found_1[obj.__ref] = true;
          }
          if (isNonNullObject(obj)) {
            Object.keys(obj).forEach(function(key) {
              var child = obj[key];
              if (isNonNullObject(child)) {
                workSet_1.add(child);
              }
            });
          }
        });
      }
      return this.refs[dataId];
    };
    EntityStore2.prototype.makeCacheKey = function() {
      return this.group.keyMaker.lookupArray(arguments);
    };
    return EntityStore2;
  }()
);
var CacheGroup = (
  /** @class */
  function() {
    function CacheGroup2(caching, parent) {
      if (parent === void 0) {
        parent = null;
      }
      this.caching = caching;
      this.parent = parent;
      this.d = null;
      this.resetCaching();
    }
    CacheGroup2.prototype.resetCaching = function() {
      this.d = this.caching ? dep() : null;
      this.keyMaker = new Trie(canUseWeakMap);
    };
    CacheGroup2.prototype.depend = function(dataId, storeFieldName) {
      if (this.d) {
        this.d(makeDepKey(dataId, storeFieldName));
        var fieldName = fieldNameFromStoreName(storeFieldName);
        if (fieldName !== storeFieldName) {
          this.d(makeDepKey(dataId, fieldName));
        }
        if (this.parent) {
          this.parent.depend(dataId, storeFieldName);
        }
      }
    };
    CacheGroup2.prototype.dirty = function(dataId, storeFieldName) {
      if (this.d) {
        this.d.dirty(
          makeDepKey(dataId, storeFieldName),
          // When storeFieldName === "__exists", that means the entity identified
          // by dataId has either disappeared from the cache or was newly added,
          // so the result caching system would do well to "forget everything it
          // knows" about that object. To achieve that kind of invalidation, we
          // not only dirty the associated result cache entry, but also remove it
          // completely from the dependency graph. For the optimism implementation
          // details, see https://github.com/benjamn/optimism/pull/195.
          storeFieldName === "__exists" ? "forget" : "setDirty"
        );
      }
    };
    return CacheGroup2;
  }()
);
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
(function(EntityStore2) {
  var Root = (
    /** @class */
    function(_super) {
      __extends(Root2, _super);
      function Root2(_a) {
        var policies = _a.policies, _b = _a.resultCaching, resultCaching = _b === void 0 ? true : _b, seed = _a.seed;
        var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;
        _this.stump = new Stump(_this);
        _this.storageTrie = new Trie(canUseWeakMap);
        if (seed)
          _this.replace(seed);
        return _this;
      }
      Root2.prototype.addLayer = function(layerId, replay) {
        return this.stump.addLayer(layerId, replay);
      };
      Root2.prototype.removeLayer = function() {
        return this;
      };
      Root2.prototype.getStorage = function() {
        return this.storageTrie.lookupArray(arguments);
      };
      return Root2;
    }(EntityStore2)
  );
  EntityStore2.Root = Root;
})(EntityStore || (EntityStore = {}));
var Layer = (
  /** @class */
  function(_super) {
    __extends(Layer2, _super);
    function Layer2(id2, parent, replay, group) {
      var _this = _super.call(this, parent.policies, group) || this;
      _this.id = id2;
      _this.parent = parent;
      _this.replay = replay;
      _this.group = group;
      replay(_this);
      return _this;
    }
    Layer2.prototype.addLayer = function(layerId, replay) {
      return new Layer2(layerId, this, replay, this.group);
    };
    Layer2.prototype.removeLayer = function(layerId) {
      var _this = this;
      var parent = this.parent.removeLayer(layerId);
      if (layerId === this.id) {
        if (this.group.caching) {
          Object.keys(this.data).forEach(function(dataId) {
            var ownStoreObject = _this.data[dataId];
            var parentStoreObject = parent["lookup"](dataId);
            if (!parentStoreObject) {
              _this.delete(dataId);
            } else if (!ownStoreObject) {
              _this.group.dirty(dataId, "__exists");
              Object.keys(parentStoreObject).forEach(function(storeFieldName) {
                _this.group.dirty(dataId, storeFieldName);
              });
            } else if (ownStoreObject !== parentStoreObject) {
              Object.keys(ownStoreObject).forEach(function(storeFieldName) {
                if (!equal$1(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                  _this.group.dirty(dataId, storeFieldName);
                }
              });
            }
          });
        }
        return parent;
      }
      if (parent === this.parent)
        return this;
      return parent.addLayer(this.id, this.replay);
    };
    Layer2.prototype.toObject = function() {
      return __assign(__assign({}, this.parent.toObject()), this.data);
    };
    Layer2.prototype.findChildRefIds = function(dataId) {
      var fromParent = this.parent.findChildRefIds(dataId);
      return hasOwn$1.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;
    };
    Layer2.prototype.getStorage = function() {
      var p = this.parent;
      while (p.parent)
        p = p.parent;
      return p.getStorage.apply(
        p,
        // @ts-expect-error
        arguments
      );
    };
    return Layer2;
  }(EntityStore)
);
var Stump = (
  /** @class */
  function(_super) {
    __extends(Stump2, _super);
    function Stump2(root) {
      return _super.call(this, "EntityStore.Stump", root, function() {
      }, new CacheGroup(root.group.caching, root.group)) || this;
    }
    Stump2.prototype.removeLayer = function() {
      return this;
    };
    Stump2.prototype.merge = function(older, newer) {
      return this.parent.merge(older, newer);
    };
    return Stump2;
  }(Layer)
);
function storeObjectReconciler(existingObject, incomingObject, property) {
  var existingValue = existingObject[property];
  var incomingValue = incomingObject[property];
  return equal$1(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store instanceof EntityStore && store.group.caching);
}
function shallowCopy(value) {
  if (isNonNullObject(value)) {
    return isArray(value) ? value.slice(0) : __assign({ __proto__: Object.getPrototypeOf(value) }, value);
  }
  return value;
}
var ObjectCanon = (
  /** @class */
  function() {
    function ObjectCanon2() {
      this.known = new (canUseWeakSet ? WeakSet : Set)();
      this.pool = new Trie(canUseWeakMap);
      this.passes = /* @__PURE__ */ new WeakMap();
      this.keysByJSON = /* @__PURE__ */ new Map();
      this.empty = this.admit({});
    }
    ObjectCanon2.prototype.isKnown = function(value) {
      return isNonNullObject(value) && this.known.has(value);
    };
    ObjectCanon2.prototype.pass = function(value) {
      if (isNonNullObject(value)) {
        var copy2 = shallowCopy(value);
        this.passes.set(copy2, value);
        return copy2;
      }
      return value;
    };
    ObjectCanon2.prototype.admit = function(value) {
      var _this = this;
      if (isNonNullObject(value)) {
        var original = this.passes.get(value);
        if (original)
          return original;
        var proto = Object.getPrototypeOf(value);
        switch (proto) {
          case Array.prototype: {
            if (this.known.has(value))
              return value;
            var array = value.map(this.admit, this);
            var node = this.pool.lookupArray(array);
            if (!node.array) {
              this.known.add(node.array = array);
              if (globalThis.__DEV__ !== false) {
                Object.freeze(array);
              }
            }
            return node.array;
          }
          case null:
          case Object.prototype: {
            if (this.known.has(value))
              return value;
            var proto_1 = Object.getPrototypeOf(value);
            var array_1 = [proto_1];
            var keys = this.sortedKeys(value);
            array_1.push(keys.json);
            var firstValueIndex_1 = array_1.length;
            keys.sorted.forEach(function(key) {
              array_1.push(_this.admit(value[key]));
            });
            var node = this.pool.lookupArray(array_1);
            if (!node.object) {
              var obj_1 = node.object = Object.create(proto_1);
              this.known.add(obj_1);
              keys.sorted.forEach(function(key, i) {
                obj_1[key] = array_1[firstValueIndex_1 + i];
              });
              if (globalThis.__DEV__ !== false) {
                Object.freeze(obj_1);
              }
            }
            return node.object;
          }
        }
      }
      return value;
    };
    ObjectCanon2.prototype.sortedKeys = function(obj) {
      var keys = Object.keys(obj);
      var node = this.pool.lookupArray(keys);
      if (!node.keys) {
        keys.sort();
        var json = JSON.stringify(keys);
        if (!(node.keys = this.keysByJSON.get(json))) {
          this.keysByJSON.set(json, node.keys = { sorted: keys, json });
        }
      }
      return node.keys;
    };
    return ObjectCanon2;
  }()
);
function execSelectionSetKeyArgs(options) {
  return [
    options.selectionSet,
    options.objectOrReference,
    options.context,
    // We split out this property so we can pass different values
    // independently without modifying options.context itself.
    options.context.canonizeResults
  ];
}
var StoreReader = (
  /** @class */
  function() {
    function StoreReader2(config2) {
      var _this = this;
      this.knownResults = new (canUseWeakMap ? WeakMap : Map)();
      this.config = compact(config2, {
        addTypename: config2.addTypename !== false,
        canonizeResults: shouldCanonizeResults(config2)
      });
      this.canon = config2.canon || new ObjectCanon();
      this.executeSelectionSet = wrap$2(function(options) {
        var _a;
        var canonizeResults = options.context.canonizeResults;
        var peekArgs = execSelectionSetKeyArgs(options);
        peekArgs[3] = !canonizeResults;
        var other = (_a = _this.executeSelectionSet).peek.apply(_a, peekArgs);
        if (other) {
          if (canonizeResults) {
            return __assign(__assign({}, other), {
              // If we previously read this result without canonizing it, we can
              // reuse that result simply by canonizing it now.
              result: _this.canon.admit(other.result)
            });
          }
          return other;
        }
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSelectionSetImpl(options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
        keyArgs: execSelectionSetKeyArgs,
        // Note that the parameters of makeCacheKey are determined by the
        // array returned by keyArgs.
        makeCacheKey: function(selectionSet, parent, context, canonizeResults) {
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString, canonizeResults);
          }
        }
      });
      this.executeSubSelectedArray = wrap$2(function(options) {
        maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
        return _this.execSubSelectedArrayImpl(options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
        makeCacheKey: function(_a) {
          var field = _a.field, array = _a.array, context = _a.context;
          if (supportsResultCaching(context.store)) {
            return context.store.makeCacheKey(field, array, context.varString);
          }
        }
      });
    }
    StoreReader2.prototype.resetCanon = function() {
      this.canon = new ObjectCanon();
    };
    StoreReader2.prototype.diffQueryAgainstStore = function(_a) {
      var store = _a.store, query = _a.query, _b = _a.rootId, rootId = _b === void 0 ? "ROOT_QUERY" : _b, variables = _a.variables, _c = _a.returnPartialData, returnPartialData = _c === void 0 ? true : _c, _d = _a.canonizeResults, canonizeResults = _d === void 0 ? this.config.canonizeResults : _d;
      var policies = this.config.cache.policies;
      variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);
      var rootRef = makeReference(rootId);
      var execResult = this.executeSelectionSet({
        selectionSet: getMainDefinition(query).selectionSet,
        objectOrReference: rootRef,
        enclosingRef: rootRef,
        context: __assign({ store, query, policies, variables, varString: canonicalStringify(variables), canonizeResults }, extractFragmentContext(query, this.config.fragments))
      });
      var missing;
      if (execResult.missing) {
        missing = [
          new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables)
        ];
        if (!returnPartialData) {
          throw missing[0];
        }
      }
      return {
        result: execResult.result,
        complete: !missing,
        missing
      };
    };
    StoreReader2.prototype.isFresh = function(result, parent, selectionSet, context) {
      if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {
        var latest = this.executeSelectionSet.peek(
          selectionSet,
          parent,
          context,
          // If result is canonical, then it could only have been previously
          // cached by the canonizing version of executeSelectionSet, so we can
          // avoid checking both possibilities here.
          this.canon.isKnown(result)
        );
        if (latest && result === latest.result) {
          return true;
        }
      }
      return false;
    };
    StoreReader2.prototype.execSelectionSetImpl = function(_a) {
      var _this = this;
      var selectionSet = _a.selectionSet, objectOrReference = _a.objectOrReference, enclosingRef = _a.enclosingRef, context = _a.context;
      if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
        return {
          result: this.canon.empty,
          missing: "Dangling reference to missing ".concat(objectOrReference.__ref, " object")
        };
      }
      var variables = context.variables, policies = context.policies, store = context.store;
      var typename = store.getFieldValue(objectOrReference, "__typename");
      var objectsToMerge = [];
      var missing;
      var missingMerger = new DeepMerger();
      if (this.config.addTypename && typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
        objectsToMerge.push({ __typename: typename });
      }
      function handleMissing(result2, resultName) {
        var _a2;
        if (result2.missing) {
          missing = missingMerger.merge(missing, (_a2 = {}, _a2[resultName] = result2.missing, _a2));
        }
        return result2.result;
      }
      var workSet = new Set(selectionSet.selections);
      workSet.forEach(function(selection) {
        var _a2, _b;
        if (!shouldInclude(selection, variables))
          return;
        if (isField(selection)) {
          var fieldValue = policies.readField({
            fieldName: selection.name.value,
            field: selection,
            variables: context.variables,
            from: objectOrReference
          }, context);
          var resultName = resultKeyNameFromField(selection);
          if (fieldValue === void 0) {
            if (!addTypenameToDocument.added(selection)) {
              missing = missingMerger.merge(missing, (_a2 = {}, _a2[resultName] = "Can't find field '".concat(selection.name.value, "' on ").concat(isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)), _a2));
            }
          } else if (isArray(fieldValue)) {
            if (fieldValue.length > 0) {
              fieldValue = handleMissing(_this.executeSubSelectedArray({
                field: selection,
                array: fieldValue,
                enclosingRef,
                context
              }), resultName);
            }
          } else if (!selection.selectionSet) {
            if (context.canonizeResults) {
              fieldValue = _this.canon.pass(fieldValue);
            }
          } else if (fieldValue != null) {
            fieldValue = handleMissing(_this.executeSelectionSet({
              selectionSet: selection.selectionSet,
              objectOrReference: fieldValue,
              enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
              context
            }), resultName);
          }
          if (fieldValue !== void 0) {
            objectsToMerge.push((_b = {}, _b[resultName] = fieldValue, _b));
          }
        } else {
          var fragment = getFragmentFromSelection(selection, context.lookupFragment);
          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
            throw newInvariantError(10, selection.name.value);
          }
          if (fragment && policies.fragmentMatches(fragment, typename)) {
            fragment.selectionSet.selections.forEach(workSet.add, workSet);
          }
        }
      });
      var result = mergeDeepArray(objectsToMerge);
      var finalResult = { result, missing };
      var frozen = context.canonizeResults ? this.canon.admit(finalResult) : maybeDeepFreeze(finalResult);
      if (frozen.result) {
        this.knownResults.set(frozen.result, selectionSet);
      }
      return frozen;
    };
    StoreReader2.prototype.execSubSelectedArrayImpl = function(_a) {
      var _this = this;
      var field = _a.field, array = _a.array, enclosingRef = _a.enclosingRef, context = _a.context;
      var missing;
      var missingMerger = new DeepMerger();
      function handleMissing(childResult, i) {
        var _a2;
        if (childResult.missing) {
          missing = missingMerger.merge(missing, (_a2 = {}, _a2[i] = childResult.missing, _a2));
        }
        return childResult.result;
      }
      if (field.selectionSet) {
        array = array.filter(context.store.canRead);
      }
      array = array.map(function(item, i) {
        if (item === null) {
          return null;
        }
        if (isArray(item)) {
          return handleMissing(_this.executeSubSelectedArray({
            field,
            array: item,
            enclosingRef,
            context
          }), i);
        }
        if (field.selectionSet) {
          return handleMissing(_this.executeSelectionSet({
            selectionSet: field.selectionSet,
            objectOrReference: item,
            enclosingRef: isReference(item) ? item : enclosingRef,
            context
          }), i);
        }
        if (globalThis.__DEV__ !== false) {
          assertSelectionSetForIdValue(context.store, field, item);
        }
        return item;
      });
      return {
        result: context.canonizeResults ? this.canon.admit(array) : array,
        missing
      };
    };
    return StoreReader2;
  }()
);
function firstMissing(tree) {
  try {
    JSON.stringify(tree, function(_2, value) {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result) {
    return result;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    var workSet_1 = /* @__PURE__ */ new Set([fieldValue]);
    workSet_1.forEach(function(value) {
      if (isNonNullObject(value)) {
        invariant(
          !isReference(value),
          11,
          getTypenameFromStoreObject(store, value),
          field.name.value
        );
        Object.values(value).forEach(workSet_1.add, workSet_1);
      }
    });
  }
}
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache2) {
  var info = cacheInfoMap.get(cache2);
  if (!info) {
    cacheInfoMap.set(cache2, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.forgetCache(cache2);
  });
}
function recallCache(cache2) {
  getCacheInfo(cache2).vars.forEach(function(rv) {
    return rv.attachCache(cache2);
  });
}
function makeVar(value) {
  var caches = /* @__PURE__ */ new Set();
  var listeners = /* @__PURE__ */ new Set();
  var rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches.forEach(function(cache3) {
          getCacheInfo(cache3).dep.dirty(rv);
          broadcast(cache3);
        });
        var oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach(function(listener) {
          return listener(value);
        });
      }
    } else {
      var cache2 = cacheSlot.getValue();
      if (cache2) {
        attach(cache2);
        getCacheInfo(cache2).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = function(listener) {
    listeners.add(listener);
    return function() {
      listeners.delete(listener);
    };
  };
  var attach = rv.attachCache = function(cache2) {
    caches.add(cache2);
    getCacheInfo(cache2).vars.add(rv);
    return rv;
  };
  rv.forgetCache = function(cache2) {
    return caches.delete(cache2);
  };
  return rv;
}
function broadcast(cache2) {
  if (cache2.broadcastWatches) {
    cache2.broadcastWatches();
  }
}
var specifierInfoCache = /* @__PURE__ */ Object.create(null);
function lookupSpecifierInfo(spec) {
  var cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = /* @__PURE__ */ Object.create(null));
}
function keyFieldsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = function(object, context) {
    var extract = function(from2, key) {
      return context.readField(key, from2);
    };
    var keyObject = context.keyObject = collectSpecifierPaths(specifier, function(schemaKeyPath) {
      var extracted = extractKeyPath(
        context.storeObject,
        schemaKeyPath,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        extract
      );
      if (extracted === void 0 && object !== context.storeObject && hasOwn$1.call(object, schemaKeyPath[0])) {
        extracted = extractKeyPath(object, schemaKeyPath, extractKey);
      }
      invariant(extracted !== void 0, 5, schemaKeyPath.join("."), object);
      return extracted;
    });
    return "".concat(context.typename, ":").concat(JSON.stringify(keyObject));
  });
}
function keyArgsFnFromSpecifier(specifier) {
  var info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = function(args, _a) {
    var field = _a.field, variables = _a.variables, fieldName = _a.fieldName;
    var collected = collectSpecifierPaths(specifier, function(keyPath) {
      var firstKey = keyPath[0];
      var firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          var directiveName_1 = firstKey.slice(1);
          var d = field.directives.find(function(d2) {
            return d2.name.value === directiveName_1;
          });
          var directiveArgs = d && argumentsObjectFromField(d, variables);
          return directiveArgs && extractKeyPath(
            directiveArgs,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            keyPath.slice(1)
          );
        }
        return;
      }
      if (firstChar === "$") {
        var variableName = firstKey.slice(1);
        if (variables && hasOwn$1.call(variables, variableName)) {
          var varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    var suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  var merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce(function(collected, path) {
    var _a;
    var toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (var i = path.length - 1; i >= 0; --i) {
        toMerge = (_a = {}, _a[path[i]] = toMerge, _a);
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, /* @__PURE__ */ Object.create(null));
}
function getSpecifierPaths(spec) {
  var info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    var paths_1 = info.paths = [];
    var currentPath_1 = [];
    spec.forEach(function(s, i) {
      if (isArray(s)) {
        getSpecifierPaths(s).forEach(function(p) {
          return paths_1.push(currentPath_1.concat(p));
        });
        currentPath_1.length = 0;
      } else {
        currentPath_1.push(s);
        if (!isArray(spec[i + 1])) {
          paths_1.push(currentPath_1.slice(0));
          currentPath_1.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object, key) {
  return object[key];
}
function extractKeyPath(object, path, extract) {
  extract = extract || extractKey;
  return normalize$2(path.reduce(function reducer(obj, key) {
    return isArray(obj) ? obj.map(function(child) {
      return reducer(child, key);
    }) : obj && extract(obj, key);
  }, object));
}
function normalize$2(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize$2);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), function(path) {
      return extractKeyPath(value, path);
    });
  }
  return value;
}
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = function() {
  return void 0;
};
var simpleKeyArgsFn = function(_args, context) {
  return context.fieldName;
};
var mergeTrueFn = function(existing, incoming, _a) {
  var mergeObjects = _a.mergeObjects;
  return mergeObjects(existing, incoming);
};
var mergeFalseFn = function(_2, incoming) {
  return incoming;
};
var Policies = (
  /** @class */
  function() {
    function Policies2(config2) {
      this.config = config2;
      this.typePolicies = /* @__PURE__ */ Object.create(null);
      this.toBeAdded = /* @__PURE__ */ Object.create(null);
      this.supertypeMap = /* @__PURE__ */ new Map();
      this.fuzzySubtypes = /* @__PURE__ */ new Map();
      this.rootIdsByTypename = /* @__PURE__ */ Object.create(null);
      this.rootTypenamesById = /* @__PURE__ */ Object.create(null);
      this.usingPossibleTypes = false;
      this.config = __assign({ dataIdFromObject: defaultDataIdFromObject }, config2);
      this.cache = this.config.cache;
      this.setRootTypename("Query");
      this.setRootTypename("Mutation");
      this.setRootTypename("Subscription");
      if (config2.possibleTypes) {
        this.addPossibleTypes(config2.possibleTypes);
      }
      if (config2.typePolicies) {
        this.addTypePolicies(config2.typePolicies);
      }
    }
    Policies2.prototype.identify = function(object, partialContext) {
      var _a;
      var policies = this;
      var typename = partialContext && (partialContext.typename || ((_a = partialContext.storeObject) === null || _a === void 0 ? void 0 : _a.__typename)) || object.__typename;
      if (typename === this.rootTypenamesById.ROOT_QUERY) {
        return ["ROOT_QUERY"];
      }
      var storeObject = partialContext && partialContext.storeObject || object;
      var context = __assign(__assign({}, partialContext), { typename, storeObject, readField: partialContext && partialContext.readField || function() {
        var options = normalizeReadFieldOptions(arguments, storeObject);
        return policies.readField(options, {
          store: policies.cache["data"],
          variables: options.variables
        });
      } });
      var id2;
      var policy = typename && this.getTypePolicy(typename);
      var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
      disableWarningsSlot.withValue(true, function() {
        while (keyFn) {
          var specifierOrId = keyFn(__assign(__assign({}, object), storeObject), context);
          if (isArray(specifierOrId)) {
            keyFn = keyFieldsFnFromSpecifier(specifierOrId);
          } else {
            id2 = specifierOrId;
            break;
          }
        }
      });
      id2 = id2 ? String(id2) : void 0;
      return context.keyObject ? [id2, context.keyObject] : [id2];
    };
    Policies2.prototype.addTypePolicies = function(typePolicies) {
      var _this = this;
      Object.keys(typePolicies).forEach(function(typename) {
        var _a = typePolicies[typename], queryType = _a.queryType, mutationType = _a.mutationType, subscriptionType = _a.subscriptionType, incoming = __rest(_a, ["queryType", "mutationType", "subscriptionType"]);
        if (queryType)
          _this.setRootTypename("Query", typename);
        if (mutationType)
          _this.setRootTypename("Mutation", typename);
        if (subscriptionType)
          _this.setRootTypename("Subscription", typename);
        if (hasOwn$1.call(_this.toBeAdded, typename)) {
          _this.toBeAdded[typename].push(incoming);
        } else {
          _this.toBeAdded[typename] = [incoming];
        }
      });
    };
    Policies2.prototype.updateTypePolicy = function(typename, incoming) {
      var _this = this;
      var existing = this.getTypePolicy(typename);
      var keyFields = incoming.keyFields, fields = incoming.fields;
      function setMerge(existing2, merge2) {
        existing2.merge = typeof merge2 === "function" ? merge2 : merge2 === true ? mergeTrueFn : merge2 === false ? mergeFalseFn : existing2.merge;
      }
      setMerge(existing, incoming.merge);
      existing.keyFn = // Pass false to disable normalization for this typename.
      keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
      if (fields) {
        Object.keys(fields).forEach(function(fieldName) {
          var existing2 = _this.getFieldPolicy(typename, fieldName, true);
          var incoming2 = fields[fieldName];
          if (typeof incoming2 === "function") {
            existing2.read = incoming2;
          } else {
            var keyArgs = incoming2.keyArgs, read = incoming2.read, merge2 = incoming2.merge;
            existing2.keyFn = // Pass false to disable argument-based differentiation of
            // field identities.
            keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
            if (typeof read === "function") {
              existing2.read = read;
            }
            setMerge(existing2, merge2);
          }
          if (existing2.read && existing2.merge) {
            existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
          }
        });
      }
    };
    Policies2.prototype.setRootTypename = function(which, typename) {
      if (typename === void 0) {
        typename = which;
      }
      var rootId = "ROOT_" + which.toUpperCase();
      var old = this.rootTypenamesById[rootId];
      if (typename !== old) {
        invariant(!old || old === which, 6, which);
        if (old)
          delete this.rootIdsByTypename[old];
        this.rootIdsByTypename[typename] = rootId;
        this.rootTypenamesById[rootId] = typename;
      }
    };
    Policies2.prototype.addPossibleTypes = function(possibleTypes) {
      var _this = this;
      this.usingPossibleTypes = true;
      Object.keys(possibleTypes).forEach(function(supertype) {
        _this.getSupertypeSet(supertype, true);
        possibleTypes[supertype].forEach(function(subtype) {
          _this.getSupertypeSet(subtype, true).add(supertype);
          var match2 = subtype.match(TypeOrFieldNameRegExp);
          if (!match2 || match2[0] !== subtype) {
            _this.fuzzySubtypes.set(subtype, new RegExp(subtype));
          }
        });
      });
    };
    Policies2.prototype.getTypePolicy = function(typename) {
      var _this = this;
      if (!hasOwn$1.call(this.typePolicies, typename)) {
        var policy_1 = this.typePolicies[typename] = /* @__PURE__ */ Object.create(null);
        policy_1.fields = /* @__PURE__ */ Object.create(null);
        var supertypes_1 = this.supertypeMap.get(typename);
        if (!supertypes_1 && this.fuzzySubtypes.size) {
          supertypes_1 = this.getSupertypeSet(typename, true);
          this.fuzzySubtypes.forEach(function(regExp, fuzzy) {
            if (regExp.test(typename)) {
              var fuzzySupertypes = _this.supertypeMap.get(fuzzy);
              if (fuzzySupertypes) {
                fuzzySupertypes.forEach(function(supertype) {
                  return supertypes_1.add(supertype);
                });
              }
            }
          });
        }
        if (supertypes_1 && supertypes_1.size) {
          supertypes_1.forEach(function(supertype) {
            var _a = _this.getTypePolicy(supertype), fields = _a.fields, rest = __rest(_a, ["fields"]);
            Object.assign(policy_1, rest);
            Object.assign(policy_1.fields, fields);
          });
        }
      }
      var inbox = this.toBeAdded[typename];
      if (inbox && inbox.length) {
        inbox.splice(0).forEach(function(policy) {
          _this.updateTypePolicy(typename, policy);
        });
      }
      return this.typePolicies[typename];
    };
    Policies2.prototype.getFieldPolicy = function(typename, fieldName, createIfMissing) {
      if (typename) {
        var fieldPolicies = this.getTypePolicy(typename).fields;
        return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = /* @__PURE__ */ Object.create(null));
      }
    };
    Policies2.prototype.getSupertypeSet = function(subtype, createIfMissing) {
      var supertypeSet = this.supertypeMap.get(subtype);
      if (!supertypeSet && createIfMissing) {
        this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
      }
      return supertypeSet;
    };
    Policies2.prototype.fragmentMatches = function(fragment, typename, result, variables) {
      var _this = this;
      if (!fragment.typeCondition)
        return true;
      if (!typename)
        return false;
      var supertype = fragment.typeCondition.name.value;
      if (typename === supertype)
        return true;
      if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
        var typenameSupertypeSet = this.getSupertypeSet(typename, true);
        var workQueue_1 = [typenameSupertypeSet];
        var maybeEnqueue_1 = function(subtype) {
          var supertypeSet2 = _this.getSupertypeSet(subtype, false);
          if (supertypeSet2 && supertypeSet2.size && workQueue_1.indexOf(supertypeSet2) < 0) {
            workQueue_1.push(supertypeSet2);
          }
        };
        var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
        var checkingFuzzySubtypes = false;
        for (var i = 0; i < workQueue_1.length; ++i) {
          var supertypeSet = workQueue_1[i];
          if (supertypeSet.has(supertype)) {
            if (!typenameSupertypeSet.has(supertype)) {
              if (checkingFuzzySubtypes) {
                globalThis.__DEV__ !== false && invariant.warn(7, typename, supertype);
              }
              typenameSupertypeSet.add(supertype);
            }
            return true;
          }
          supertypeSet.forEach(maybeEnqueue_1);
          if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
          // non-fuzzy subtypes (after the final iteration of the loop).
          i === workQueue_1.length - 1 && // We could wait to compare fragment.selectionSet to result
          // after we verify the supertype, but this check is often less
          // expensive than that search, and we will have to do the
          // comparison anyway whenever we find a potential match.
          selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
            needToCheckFuzzySubtypes = false;
            checkingFuzzySubtypes = true;
            this.fuzzySubtypes.forEach(function(regExp, fuzzyString) {
              var match2 = typename.match(regExp);
              if (match2 && match2[0] === typename) {
                maybeEnqueue_1(fuzzyString);
              }
            });
          }
        }
      }
      return false;
    };
    Policies2.prototype.hasKeyArgs = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return !!(policy && policy.keyFn);
    };
    Policies2.prototype.getStoreFieldName = function(fieldSpec) {
      var typename = fieldSpec.typename, fieldName = fieldSpec.fieldName;
      var policy = this.getFieldPolicy(typename, fieldName, false);
      var storeFieldName;
      var keyFn = policy && policy.keyFn;
      if (keyFn && typename) {
        var context = {
          typename,
          fieldName,
          field: fieldSpec.field || null,
          variables: fieldSpec.variables
        };
        var args = argsFromFieldSpecifier(fieldSpec);
        while (keyFn) {
          var specifierOrString = keyFn(args, context);
          if (isArray(specifierOrString)) {
            keyFn = keyArgsFnFromSpecifier(specifierOrString);
          } else {
            storeFieldName = specifierOrString || fieldName;
            break;
          }
        }
      }
      if (storeFieldName === void 0) {
        storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
      }
      if (storeFieldName === false) {
        return fieldName;
      }
      return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
    };
    Policies2.prototype.readField = function(options, context) {
      var objectOrReference = options.from;
      if (!objectOrReference)
        return;
      var nameOrField = options.field || options.fieldName;
      if (!nameOrField)
        return;
      if (options.typename === void 0) {
        var typename = context.store.getFieldValue(objectOrReference, "__typename");
        if (typename)
          options.typename = typename;
      }
      var storeFieldName = this.getStoreFieldName(options);
      var fieldName = fieldNameFromStoreName(storeFieldName);
      var existing = context.store.getFieldValue(objectOrReference, storeFieldName);
      var policy = this.getFieldPolicy(options.typename, fieldName, false);
      var read = policy && policy.read;
      if (read) {
        var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
        return cacheSlot.withValue(this.cache, read, [
          existing,
          readOptions
        ]);
      }
      return existing;
    };
    Policies2.prototype.getReadFunction = function(typename, fieldName) {
      var policy = this.getFieldPolicy(typename, fieldName, false);
      return policy && policy.read;
    };
    Policies2.prototype.getMergeFunction = function(parentTypename, fieldName, childTypename) {
      var policy = this.getFieldPolicy(parentTypename, fieldName, false);
      var merge2 = policy && policy.merge;
      if (!merge2 && childTypename) {
        policy = this.getTypePolicy(childTypename);
        merge2 = policy && policy.merge;
      }
      return merge2;
    };
    Policies2.prototype.runMergeFunction = function(existing, incoming, _a, context, storage) {
      var field = _a.field, typename = _a.typename, merge2 = _a.merge;
      if (merge2 === mergeTrueFn) {
        return makeMergeObjectsFunction(context.store)(existing, incoming);
      }
      if (merge2 === mergeFalseFn) {
        return incoming;
      }
      if (context.overwrite) {
        existing = void 0;
      }
      return merge2(existing, incoming, makeFieldFunctionOptions(
        this,
        // Unlike options.readField for read functions, we do not fall
        // back to the current object if no foreignObjOrRef is provided,
        // because it's not clear what the current object should be for
        // merge functions: the (possibly undefined) existing object, or
        // the incoming object? If you think your merge function needs
        // to read sibling fields in order to produce a new value for
        // the current field, you might want to rethink your strategy,
        // because that's a recipe for making merge behavior sensitive
        // to the order in which fields are written into the cache.
        // However, readField(name, ref) is useful for merge functions
        // that need to deduplicate child objects and references.
        void 0,
        {
          typename,
          fieldName: field.name.value,
          field,
          variables: context.variables
        },
        context,
        storage || /* @__PURE__ */ Object.create(null)
      ));
    };
    return Policies2;
  }()
);
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  var storeFieldName = policies.getStoreFieldName(fieldSpec);
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var variables = fieldSpec.variables || context.variables;
  var _a = context.store, toReference = _a.toReference, canRead = _a.canRead;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField: function() {
      return policies.readField(normalizeReadFieldOptions(arguments, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  var fieldNameOrOptions = readFieldArgs[0], from2 = readFieldArgs[1], argc = readFieldArgs.length;
  var options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      // Default to objectOrReference only when no second argument was
      // passed for the from parameter, not when undefined is explicitly
      // passed as the second argument.
      from: argc > 1 ? from2 : objectOrReference
    };
  } else {
    options = __assign({}, fieldNameOrOptions);
    if (!hasOwn$1.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (globalThis.__DEV__ !== false && options.from === void 0) {
    globalThis.__DEV__ !== false && invariant.warn(8, stringifyForDisplay(Array.from(readFieldArgs)));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw newInvariantError(9);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      var eType = store.getFieldValue(existing, "__typename");
      var iType = store.getFieldValue(incoming, "__typename");
      var typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return __assign(__assign({}, existing), incoming);
      }
    }
    return incoming;
  };
}
function getContextFlavor(context, clientOnly, deferred) {
  var key = "".concat(clientOnly).concat(deferred);
  var flavored = context.flavors.get(key);
  if (!flavored) {
    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : __assign(__assign({}, context), { clientOnly, deferred }));
  }
  return flavored;
}
var StoreWriter = (
  /** @class */
  function() {
    function StoreWriter2(cache2, reader, fragments) {
      this.cache = cache2;
      this.reader = reader;
      this.fragments = fragments;
    }
    StoreWriter2.prototype.writeToStore = function(store, _a) {
      var _this = this;
      var query = _a.query, result = _a.result, dataId = _a.dataId, variables = _a.variables, overwrite = _a.overwrite;
      var operationDefinition = getOperationDefinition(query);
      var merger = makeProcessedFieldsMerger();
      variables = __assign(__assign({}, getDefaultValues(operationDefinition)), variables);
      var context = __assign(__assign({ store, written: /* @__PURE__ */ Object.create(null), merge: function(existing, incoming) {
        return merger.merge(existing, incoming);
      }, variables, varString: canonicalStringify(variables) }, extractFragmentContext(query, this.fragments)), { overwrite: !!overwrite, incomingById: /* @__PURE__ */ new Map(), clientOnly: false, deferred: false, flavors: /* @__PURE__ */ new Map() });
      var ref = this.processSelectionSet({
        result: result || /* @__PURE__ */ Object.create(null),
        dataId,
        selectionSet: operationDefinition.selectionSet,
        mergeTree: { map: /* @__PURE__ */ new Map() },
        context
      });
      if (!isReference(ref)) {
        throw newInvariantError(12, result);
      }
      context.incomingById.forEach(function(_a2, dataId2) {
        var storeObject = _a2.storeObject, mergeTree = _a2.mergeTree, fieldNodeSet = _a2.fieldNodeSet;
        var entityRef = makeReference(dataId2);
        if (mergeTree && mergeTree.map.size) {
          var applied = _this.applyMerges(mergeTree, entityRef, storeObject, context);
          if (isReference(applied)) {
            return;
          }
          storeObject = applied;
        }
        if (globalThis.__DEV__ !== false && !context.overwrite) {
          var fieldsWithSelectionSets_1 = /* @__PURE__ */ Object.create(null);
          fieldNodeSet.forEach(function(field) {
            if (field.selectionSet) {
              fieldsWithSelectionSets_1[field.name.value] = true;
            }
          });
          var hasSelectionSet_1 = function(storeFieldName) {
            return fieldsWithSelectionSets_1[fieldNameFromStoreName(storeFieldName)] === true;
          };
          var hasMergeFunction_1 = function(storeFieldName) {
            var childTree = mergeTree && mergeTree.map.get(storeFieldName);
            return Boolean(childTree && childTree.info && childTree.info.merge);
          };
          Object.keys(storeObject).forEach(function(storeFieldName) {
            if (hasSelectionSet_1(storeFieldName) && !hasMergeFunction_1(storeFieldName)) {
              warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
            }
          });
        }
        store.merge(dataId2, storeObject);
      });
      store.retain(ref.__ref);
      return ref;
    };
    StoreWriter2.prototype.processSelectionSet = function(_a) {
      var _this = this;
      var dataId = _a.dataId, result = _a.result, selectionSet = _a.selectionSet, context = _a.context, mergeTree = _a.mergeTree;
      var policies = this.cache.policies;
      var incoming = /* @__PURE__ */ Object.create(null);
      var typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
      if ("string" === typeof typename) {
        incoming.__typename = typename;
      }
      var readField = function() {
        var options = normalizeReadFieldOptions(arguments, incoming, context.variables);
        if (isReference(options.from)) {
          var info = context.incomingById.get(options.from.__ref);
          if (info) {
            var result_1 = policies.readField(__assign(__assign({}, options), { from: info.storeObject }), context);
            if (result_1 !== void 0) {
              return result_1;
            }
          }
        }
        return policies.readField(options, context);
      };
      var fieldNodeSet = /* @__PURE__ */ new Set();
      this.flattenFields(
        selectionSet,
        result,
        // This WriteContext will be the default context value for fields returned
        // by the flattenFields method, but some fields may be assigned a modified
        // context, depending on the presence of @client and other directives.
        context,
        typename
      ).forEach(function(context2, field) {
        var _a2;
        var resultFieldKey = resultKeyNameFromField(field);
        var value = result[resultFieldKey];
        fieldNodeSet.add(field);
        if (value !== void 0) {
          var storeFieldName = policies.getStoreFieldName({
            typename,
            fieldName: field.name.value,
            field,
            variables: context2.variables
          });
          var childTree = getChildMergeTree(mergeTree, storeFieldName);
          var incomingValue = _this.processFieldValue(
            value,
            field,
            // Reset context.clientOnly and context.deferred to their default
            // values before processing nested selection sets.
            field.selectionSet ? getContextFlavor(context2, false, false) : context2,
            childTree
          );
          var childTypename = void 0;
          if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
            childTypename = readField("__typename", incomingValue);
          }
          var merge2 = policies.getMergeFunction(typename, field.name.value, childTypename);
          if (merge2) {
            childTree.info = {
              // TODO Check compatibility against any existing childTree.field?
              field,
              typename,
              merge: merge2
            };
          } else {
            maybeRecycleChildMergeTree(mergeTree, storeFieldName);
          }
          incoming = context2.merge(incoming, (_a2 = {}, _a2[storeFieldName] = incomingValue, _a2));
        } else if (globalThis.__DEV__ !== false && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or
        // provide a default value, so its absence from the written data should
        // not be cause for alarm.
        !policies.getReadFunction(typename, field.name.value)) {
          globalThis.__DEV__ !== false && invariant.error(13, resultKeyNameFromField(field), result);
        }
      });
      try {
        var _b = policies.identify(result, {
          typename,
          selectionSet,
          fragmentMap: context.fragmentMap,
          storeObject: incoming,
          readField
        }), id2 = _b[0], keyObject = _b[1];
        dataId = dataId || id2;
        if (keyObject) {
          incoming = context.merge(incoming, keyObject);
        }
      } catch (e) {
        if (!dataId)
          throw e;
      }
      if ("string" === typeof dataId) {
        var dataRef = makeReference(dataId);
        var sets = context.written[dataId] || (context.written[dataId] = []);
        if (sets.indexOf(selectionSet) >= 0)
          return dataRef;
        sets.push(selectionSet);
        if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
          return dataRef;
        }
        var previous_1 = context.incomingById.get(dataId);
        if (previous_1) {
          previous_1.storeObject = context.merge(previous_1.storeObject, incoming);
          previous_1.mergeTree = mergeMergeTrees(previous_1.mergeTree, mergeTree);
          fieldNodeSet.forEach(function(field) {
            return previous_1.fieldNodeSet.add(field);
          });
        } else {
          context.incomingById.set(dataId, {
            storeObject: incoming,
            // Save a reference to mergeTree only if it is not empty, because
            // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
            // reused for entirely different parts of the result tree.
            mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
            fieldNodeSet
          });
        }
        return dataRef;
      }
      return incoming;
    };
    StoreWriter2.prototype.processFieldValue = function(value, field, context, mergeTree) {
      var _this = this;
      if (!field.selectionSet || value === null) {
        return globalThis.__DEV__ !== false ? cloneDeep(value) : value;
      }
      if (isArray(value)) {
        return value.map(function(item, i) {
          var value2 = _this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
          maybeRecycleChildMergeTree(mergeTree, i);
          return value2;
        });
      }
      return this.processSelectionSet({
        result: value,
        selectionSet: field.selectionSet,
        context,
        mergeTree
      });
    };
    StoreWriter2.prototype.flattenFields = function(selectionSet, result, context, typename) {
      if (typename === void 0) {
        typename = getTypenameFromResult(result, selectionSet, context.fragmentMap);
      }
      var fieldMap = /* @__PURE__ */ new Map();
      var policies = this.cache.policies;
      var limitingTrie = new Trie(false);
      (function flatten(selectionSet2, inheritedContext) {
        var visitedNode = limitingTrie.lookup(
          selectionSet2,
          // Because we take inheritedClientOnly and inheritedDeferred into
          // consideration here (in addition to selectionSet), it's possible for
          // the same selection set to be flattened more than once, if it appears
          // in the query with different @client and/or @directive configurations.
          inheritedContext.clientOnly,
          inheritedContext.deferred
        );
        if (visitedNode.visited)
          return;
        visitedNode.visited = true;
        selectionSet2.selections.forEach(function(selection) {
          if (!shouldInclude(selection, context.variables))
            return;
          var clientOnly = inheritedContext.clientOnly, deferred = inheritedContext.deferred;
          if (
            // Since the presence of @client or @defer on this field can only
            // cause clientOnly or deferred to become true, we can skip the
            // forEach loop if both clientOnly and deferred are already true.
            !(clientOnly && deferred) && isNonEmptyArray(selection.directives)
          ) {
            selection.directives.forEach(function(dir) {
              var name2 = dir.name.value;
              if (name2 === "client")
                clientOnly = true;
              if (name2 === "defer") {
                var args = argumentsObjectFromField(dir, context.variables);
                if (!args || args.if !== false) {
                  deferred = true;
                }
              }
            });
          }
          if (isField(selection)) {
            var existing = fieldMap.get(selection);
            if (existing) {
              clientOnly = clientOnly && existing.clientOnly;
              deferred = deferred && existing.deferred;
            }
            fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
          } else {
            var fragment = getFragmentFromSelection(selection, context.lookupFragment);
            if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
              throw newInvariantError(14, selection.name.value);
            }
            if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {
              flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
            }
          }
        });
      })(selectionSet, context);
      return fieldMap;
    };
    StoreWriter2.prototype.applyMerges = function(mergeTree, existing, incoming, context, getStorageArgs) {
      var _a;
      var _this = this;
      if (mergeTree.map.size && !isReference(incoming)) {
        var e_1 = (
          // Items in the same position in different arrays are not
          // necessarily related to each other, so when incoming is an array
          // we process its elements as if there was no existing data.
          !isArray(incoming) && // Likewise, existing must be either a Reference or a StoreObject
          // in order for its fields to be safe to merge with the fields of
          // the incoming object.
          (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
        );
        var i_1 = incoming;
        if (e_1 && !getStorageArgs) {
          getStorageArgs = [isReference(e_1) ? e_1.__ref : e_1];
        }
        var changedFields_1;
        var getValue_1 = function(from2, name2) {
          return isArray(from2) ? typeof name2 === "number" ? from2[name2] : void 0 : context.store.getFieldValue(from2, String(name2));
        };
        mergeTree.map.forEach(function(childTree, storeFieldName) {
          var eVal = getValue_1(e_1, storeFieldName);
          var iVal = getValue_1(i_1, storeFieldName);
          if (void 0 === iVal)
            return;
          if (getStorageArgs) {
            getStorageArgs.push(storeFieldName);
          }
          var aVal = _this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
          if (aVal !== iVal) {
            changedFields_1 = changedFields_1 || /* @__PURE__ */ new Map();
            changedFields_1.set(storeFieldName, aVal);
          }
          if (getStorageArgs) {
            invariant(getStorageArgs.pop() === storeFieldName);
          }
        });
        if (changedFields_1) {
          incoming = isArray(i_1) ? i_1.slice(0) : __assign({}, i_1);
          changedFields_1.forEach(function(value, name2) {
            incoming[name2] = value;
          });
        }
      }
      if (mergeTree.info) {
        return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && (_a = context.store).getStorage.apply(_a, getStorageArgs));
      }
      return incoming;
    };
    return StoreWriter2;
  }()
);
var emptyMergeTreePool = [];
function getChildMergeTree(_a, name2) {
  var map = _a.map;
  if (!map.has(name2)) {
    map.set(name2, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map.get(name2);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  var info = left.info && right.info ? __assign(__assign({}, left.info), right.info) : left.info || right.info;
  var needToMergeMaps = left.map.size && right.map.size;
  var map = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  var merged = { info, map };
  if (needToMergeMaps) {
    var remainingRightKeys_1 = new Set(right.map.keys());
    left.map.forEach(function(leftTree, key) {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys_1.delete(key);
    });
    remainingRightKeys_1.forEach(function(key) {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree(_a, name2) {
  var map = _a.map;
  var childTree = map.get(name2);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map.delete(name2);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  var getChild = function(objOrRef) {
    var child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  var existing = getChild(existingRef);
  if (!existing)
    return;
  var incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal$1(existing, incoming))
    return;
  if (Object.keys(existing).every(function(key) {
    return store.getFieldValue(incoming, key) !== void 0;
  })) {
    return;
  }
  var parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  var fieldName = fieldNameFromStoreName(storeFieldName);
  var typeDotName = "".concat(parentType, ".").concat(fieldName);
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  var childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach(function(child) {
      var typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  globalThis.__DEV__ !== false && invariant.warn(15, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, __assign({}, existing), __assign({}, incoming));
}
var InMemoryCache = (
  /** @class */
  function(_super) {
    __extends(InMemoryCache2, _super);
    function InMemoryCache2(config2) {
      if (config2 === void 0) {
        config2 = {};
      }
      var _this = _super.call(this) || this;
      _this.watches = /* @__PURE__ */ new Set();
      _this.addTypenameTransform = new DocumentTransform(addTypenameToDocument);
      _this.assumeImmutableResults = true;
      _this.makeVar = makeVar;
      _this.txCount = 0;
      _this.config = normalizeConfig(config2);
      _this.addTypename = !!_this.config.addTypename;
      _this.policies = new Policies({
        cache: _this,
        dataIdFromObject: _this.config.dataIdFromObject,
        possibleTypes: _this.config.possibleTypes,
        typePolicies: _this.config.typePolicies
      });
      _this.init();
      return _this;
    }
    InMemoryCache2.prototype.init = function() {
      var rootStore = this.data = new EntityStore.Root({
        policies: this.policies,
        resultCaching: this.config.resultCaching
      });
      this.optimisticData = rootStore.stump;
      this.resetResultCache();
    };
    InMemoryCache2.prototype.resetResultCache = function(resetResultIdentities) {
      var _this = this;
      var previousReader = this.storeReader;
      var fragments = this.config.fragments;
      this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({
        cache: this,
        addTypename: this.addTypename,
        resultCacheMaxSize: this.config.resultCacheMaxSize,
        canonizeResults: shouldCanonizeResults(this.config),
        canon: resetResultIdentities ? void 0 : previousReader && previousReader.canon,
        fragments
      }), fragments);
      this.maybeBroadcastWatch = wrap$2(function(c, options) {
        return _this.broadcastWatch(c, options);
      }, {
        max: this.config.resultCacheMaxSize || cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
        makeCacheKey: function(c) {
          var store = c.optimistic ? _this.optimisticData : _this.data;
          if (supportsResultCaching(store)) {
            var optimistic = c.optimistic, id2 = c.id, variables = c.variables;
            return store.makeCacheKey(
              c.query,
              // Different watches can have the same query, optimistic
              // status, rootId, and variables, but if their callbacks are
              // different, the (identical) result needs to be delivered to
              // each distinct callback. The easiest way to achieve that
              // separation is to include c.callback in the cache key for
              // maybeBroadcastWatch calls. See issue #5733.
              c.callback,
              canonicalStringify({ optimistic, id: id2, variables })
            );
          }
        }
      });
      (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach(function(group) {
        return group.resetCaching();
      });
    };
    InMemoryCache2.prototype.restore = function(data) {
      this.init();
      if (data)
        this.data.replace(data);
      return this;
    };
    InMemoryCache2.prototype.extract = function(optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return (optimistic ? this.optimisticData : this.data).extract();
    };
    InMemoryCache2.prototype.read = function(options) {
      var _a = options.returnPartialData, returnPartialData = _a === void 0 ? false : _a;
      try {
        return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, config: this.config, returnPartialData })).result || null;
      } catch (e) {
        if (e instanceof MissingFieldError) {
          return null;
        }
        throw e;
      }
    };
    InMemoryCache2.prototype.write = function(options) {
      try {
        ++this.txCount;
        return this.storeWriter.writeToStore(this.data, options);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.modify = function(options) {
      if (hasOwn$1.call(options, "id") && !options.id) {
        return false;
      }
      var store = options.optimistic ? this.optimisticData : this.data;
      try {
        ++this.txCount;
        return store.modify(options.id || "ROOT_QUERY", options.fields);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.diff = function(options) {
      return this.storeReader.diffQueryAgainstStore(__assign(__assign({}, options), { store: options.optimistic ? this.optimisticData : this.data, rootId: options.id || "ROOT_QUERY", config: this.config }));
    };
    InMemoryCache2.prototype.watch = function(watch) {
      var _this = this;
      if (!this.watches.size) {
        recallCache(this);
      }
      this.watches.add(watch);
      if (watch.immediate) {
        this.maybeBroadcastWatch(watch);
      }
      return function() {
        if (_this.watches.delete(watch) && !_this.watches.size) {
          forgetCache(_this);
        }
        _this.maybeBroadcastWatch.forget(watch);
      };
    };
    InMemoryCache2.prototype.gc = function(options) {
      var _a;
      canonicalStringify.reset();
      print.reset();
      this.addTypenameTransform.resetCache();
      (_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.resetCaches();
      var ids = this.optimisticData.gc();
      if (options && !this.txCount) {
        if (options.resetResultCache) {
          this.resetResultCache(options.resetResultIdentities);
        } else if (options.resetResultIdentities) {
          this.storeReader.resetCanon();
        }
      }
      return ids;
    };
    InMemoryCache2.prototype.retain = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).retain(rootId);
    };
    InMemoryCache2.prototype.release = function(rootId, optimistic) {
      return (optimistic ? this.optimisticData : this.data).release(rootId);
    };
    InMemoryCache2.prototype.identify = function(object) {
      if (isReference(object))
        return object.__ref;
      try {
        return this.policies.identify(object)[0];
      } catch (e) {
        globalThis.__DEV__ !== false && invariant.warn(e);
      }
    };
    InMemoryCache2.prototype.evict = function(options) {
      if (!options.id) {
        if (hasOwn$1.call(options, "id")) {
          return false;
        }
        options = __assign(__assign({}, options), { id: "ROOT_QUERY" });
      }
      try {
        ++this.txCount;
        return this.optimisticData.evict(options, this.data);
      } finally {
        if (!--this.txCount && options.broadcast !== false) {
          this.broadcastWatches();
        }
      }
    };
    InMemoryCache2.prototype.reset = function(options) {
      var _this = this;
      this.init();
      canonicalStringify.reset();
      if (options && options.discardWatches) {
        this.watches.forEach(function(watch) {
          return _this.maybeBroadcastWatch.forget(watch);
        });
        this.watches.clear();
        forgetCache(this);
      } else {
        this.broadcastWatches();
      }
      return Promise.resolve();
    };
    InMemoryCache2.prototype.removeOptimistic = function(idToRemove) {
      var newOptimisticData = this.optimisticData.removeLayer(idToRemove);
      if (newOptimisticData !== this.optimisticData) {
        this.optimisticData = newOptimisticData;
        this.broadcastWatches();
      }
    };
    InMemoryCache2.prototype.batch = function(options) {
      var _this = this;
      var update = options.update, _a = options.optimistic, optimistic = _a === void 0 ? true : _a, removeOptimistic = options.removeOptimistic, onWatchUpdated = options.onWatchUpdated;
      var updateResult;
      var perform = function(layer) {
        var _a2 = _this, data = _a2.data, optimisticData = _a2.optimisticData;
        ++_this.txCount;
        if (layer) {
          _this.data = _this.optimisticData = layer;
        }
        try {
          return updateResult = update(_this);
        } finally {
          --_this.txCount;
          _this.data = data;
          _this.optimisticData = optimisticData;
        }
      };
      var alreadyDirty = /* @__PURE__ */ new Set();
      if (onWatchUpdated && !this.txCount) {
        this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch) {
          alreadyDirty.add(watch);
          return false;
        } }));
      }
      if (typeof optimistic === "string") {
        this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
      } else if (optimistic === false) {
        perform(this.data);
      } else {
        perform();
      }
      if (typeof removeOptimistic === "string") {
        this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
      }
      if (onWatchUpdated && alreadyDirty.size) {
        this.broadcastWatches(__assign(__assign({}, options), { onWatchUpdated: function(watch, diff) {
          var result = onWatchUpdated.call(this, watch, diff);
          if (result !== false) {
            alreadyDirty.delete(watch);
          }
          return result;
        } }));
        if (alreadyDirty.size) {
          alreadyDirty.forEach(function(watch) {
            return _this.maybeBroadcastWatch.dirty(watch);
          });
        }
      } else {
        this.broadcastWatches(options);
      }
      return updateResult;
    };
    InMemoryCache2.prototype.performTransaction = function(update, optimisticId) {
      return this.batch({
        update,
        optimistic: optimisticId || optimisticId !== null
      });
    };
    InMemoryCache2.prototype.transformDocument = function(document2) {
      return this.addTypenameToDocument(this.addFragmentsToDocument(document2));
    };
    InMemoryCache2.prototype.fragmentMatches = function(fragment, typename) {
      return this.policies.fragmentMatches(fragment, typename);
    };
    InMemoryCache2.prototype.lookupFragment = function(fragmentName) {
      var _a;
      return ((_a = this.config.fragments) === null || _a === void 0 ? void 0 : _a.lookup(fragmentName)) || null;
    };
    InMemoryCache2.prototype.broadcastWatches = function(options) {
      var _this = this;
      if (!this.txCount) {
        this.watches.forEach(function(c) {
          return _this.maybeBroadcastWatch(c, options);
        });
      }
    };
    InMemoryCache2.prototype.addFragmentsToDocument = function(document2) {
      var fragments = this.config.fragments;
      return fragments ? fragments.transform(document2) : document2;
    };
    InMemoryCache2.prototype.addTypenameToDocument = function(document2) {
      if (this.addTypename) {
        return this.addTypenameTransform.transformDocument(document2);
      }
      return document2;
    };
    InMemoryCache2.prototype.broadcastWatch = function(c, options) {
      var lastDiff = c.lastDiff;
      var diff = this.diff(c);
      if (options) {
        if (c.optimistic && typeof options.optimistic === "string") {
          diff.fromOptimisticTransaction = true;
        }
        if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
          return;
        }
      }
      if (!lastDiff || !equal$1(lastDiff.result, diff.result)) {
        c.callback(c.lastDiff = diff, lastDiff);
      }
    };
    return InMemoryCache2;
  }(ApolloCache)
);
if (globalThis.__DEV__ !== false) {
  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
}
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
})(NetworkStatus || (NetworkStatus = {}));
function isNetworkRequestInFlight(networkStatus) {
  return networkStatus ? networkStatus < 7 : false;
}
var assign = Object.assign, hasOwnProperty$2 = Object.hasOwnProperty;
var ObservableQuery = (
  /** @class */
  function(_super) {
    __extends(ObservableQuery2, _super);
    function ObservableQuery2(_a) {
      var queryManager = _a.queryManager, queryInfo = _a.queryInfo, options = _a.options;
      var _this = _super.call(this, function(observer) {
        try {
          var subObserver = observer._subscription._observer;
          if (subObserver && !subObserver.error) {
            subObserver.error = defaultSubscriptionObserverErrorCallback;
          }
        } catch (_a2) {
        }
        var first = !_this.observers.size;
        _this.observers.add(observer);
        var last = _this.last;
        if (last && last.error) {
          observer.error && observer.error(last.error);
        } else if (last && last.result) {
          observer.next && observer.next(_this.maskResult(last.result));
        }
        if (first) {
          _this.reobserve().catch(function() {
          });
        }
        return function() {
          if (_this.observers.delete(observer) && !_this.observers.size) {
            _this.tearDownQuery();
          }
        };
      }) || this;
      _this.observers = /* @__PURE__ */ new Set();
      _this.subscriptions = /* @__PURE__ */ new Set();
      _this.queryInfo = queryInfo;
      _this.queryManager = queryManager;
      _this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy);
      _this.isTornDown = false;
      _this.subscribeToMore = _this.subscribeToMore.bind(_this);
      _this.maskResult = _this.maskResult.bind(_this);
      var _b = queryManager.defaultOptions.watchQuery, _c = _b === void 0 ? {} : _b, _d = _c.fetchPolicy, defaultFetchPolicy = _d === void 0 ? "cache-first" : _d;
      var _e = options.fetchPolicy, fetchPolicy = _e === void 0 ? defaultFetchPolicy : _e, _f = options.initialFetchPolicy, initialFetchPolicy = _f === void 0 ? fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy : _f;
      _this.options = __assign(__assign({}, options), {
        // Remember the initial options.fetchPolicy so we can revert back to this
        // policy when variables change. This information can also be specified
        // (or overridden) by providing options.initialFetchPolicy explicitly.
        initialFetchPolicy,
        // This ensures this.options.fetchPolicy always has a string value, in
        // case options.fetchPolicy was not provided.
        fetchPolicy
      });
      _this.queryId = queryInfo.queryId || queryManager.generateQueryId();
      var opDef = getOperationDefinition(_this.query);
      _this.queryName = opDef && opDef.name && opDef.name.value;
      return _this;
    }
    Object.defineProperty(ObservableQuery2.prototype, "query", {
      // The `query` computed property will always reflect the document transformed
      // by the last run query. `this.options.query` will always reflect the raw
      // untransformed query to ensure document transforms with runtime conditionals
      // are run on the original document.
      get: function() {
        return this.lastQuery || this.options.query;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ObservableQuery2.prototype, "variables", {
      // Computed shorthand for this.options.variables, preserved for
      // backwards compatibility.
      /**
       * An object containing the variables that were provided for the query.
       */
      get: function() {
        return this.options.variables;
      },
      enumerable: false,
      configurable: true
    });
    ObservableQuery2.prototype.result = function() {
      var _this = this;
      return new Promise(function(resolve, reject) {
        var observer = {
          next: function(result) {
            resolve(result);
            _this.observers.delete(observer);
            if (!_this.observers.size) {
              _this.queryManager.removeQuery(_this.queryId);
            }
            setTimeout(function() {
              subscription.unsubscribe();
            }, 0);
          },
          error: reject
        };
        var subscription = _this.subscribe(observer);
      });
    };
    ObservableQuery2.prototype.resetDiff = function() {
      this.queryInfo.resetDiff();
    };
    ObservableQuery2.prototype.getCurrentFullResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      var lastResult = this.getLastResult(true);
      var networkStatus = this.queryInfo.networkStatus || lastResult && lastResult.networkStatus || NetworkStatus.ready;
      var result = __assign(__assign({}, lastResult), { loading: isNetworkRequestInFlight(networkStatus), networkStatus });
      var _a = this.options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a;
      if (
        // These fetch policies should never deliver data from the cache, unless
        // redelivering a previously delivered result.
        skipCacheDataFor(fetchPolicy) || // If this.options.query has @client(always: true) fields, we cannot
        // trust diff.result, since it was read from the cache without running
        // local resolvers (and it's too late to run resolvers now, since we must
        // return a result synchronously).
        this.queryManager.getDocumentInfo(this.query).hasForcedResolvers
      )
        ;
      else if (this.waitForOwnResult) {
        this.queryInfo["updateWatch"]();
      } else {
        var diff = this.queryInfo.getDiff();
        if (diff.complete || this.options.returnPartialData) {
          result.data = diff.result;
        }
        if (equal$1(result.data, {})) {
          result.data = void 0;
        }
        if (diff.complete) {
          delete result.partial;
          if (diff.complete && result.networkStatus === NetworkStatus.loading && (fetchPolicy === "cache-first" || fetchPolicy === "cache-only")) {
            result.networkStatus = NetworkStatus.ready;
            result.loading = false;
          }
        } else {
          result.partial = true;
        }
        if (globalThis.__DEV__ !== false && !diff.complete && !this.options.partialRefetch && !result.loading && !result.data && !result.error) {
          logMissingFieldErrors(diff.missing);
        }
      }
      if (saveAsLastResult) {
        this.updateLastResult(result);
      }
      return result;
    };
    ObservableQuery2.prototype.getCurrentResult = function(saveAsLastResult) {
      if (saveAsLastResult === void 0) {
        saveAsLastResult = true;
      }
      return this.maskResult(this.getCurrentFullResult(saveAsLastResult));
    };
    ObservableQuery2.prototype.isDifferentFromLastResult = function(newResult, variables) {
      if (!this.last) {
        return true;
      }
      var documentInfo = this.queryManager.getDocumentInfo(this.query);
      var dataMasking = this.queryManager.dataMasking;
      var query = dataMasking ? documentInfo.nonReactiveQuery : this.query;
      var resultIsDifferent = dataMasking || documentInfo.hasNonreactiveDirective ? !equalByQuery(query, this.last.result, newResult, this.variables) : !equal$1(this.last.result, newResult);
      return resultIsDifferent || variables && !equal$1(this.last.variables, variables);
    };
    ObservableQuery2.prototype.getLast = function(key, variablesMustMatch) {
      var last = this.last;
      if (last && last[key] && (!variablesMustMatch || equal$1(last.variables, this.variables))) {
        return last[key];
      }
    };
    ObservableQuery2.prototype.getLastResult = function(variablesMustMatch) {
      return this.getLast("result", variablesMustMatch);
    };
    ObservableQuery2.prototype.getLastError = function(variablesMustMatch) {
      return this.getLast("error", variablesMustMatch);
    };
    ObservableQuery2.prototype.resetLastResults = function() {
      delete this.last;
      this.isTornDown = false;
    };
    ObservableQuery2.prototype.resetQueryStoreErrors = function() {
      this.queryManager.resetErrors(this.queryId);
    };
    ObservableQuery2.prototype.refetch = function(variables) {
      var _a;
      var reobserveOptions = {
        // Always disable polling for refetches.
        pollInterval: 0
      };
      var fetchPolicy = this.options.fetchPolicy;
      if (fetchPolicy === "cache-and-network") {
        reobserveOptions.fetchPolicy = fetchPolicy;
      } else if (fetchPolicy === "no-cache") {
        reobserveOptions.fetchPolicy = "no-cache";
      } else {
        reobserveOptions.fetchPolicy = "network-only";
      }
      if (globalThis.__DEV__ !== false && variables && hasOwnProperty$2.call(variables, "variables")) {
        var queryDef = getQueryDefinition(this.query);
        var vars = queryDef.variableDefinitions;
        if (!vars || !vars.some(function(v2) {
          return v2.variable.name.value === "variables";
        })) {
          globalThis.__DEV__ !== false && invariant.warn(
            21,
            variables,
            ((_a = queryDef.name) === null || _a === void 0 ? void 0 : _a.value) || queryDef
          );
        }
      }
      if (variables && !equal$1(this.options.variables, variables)) {
        reobserveOptions.variables = this.options.variables = __assign(__assign({}, this.options.variables), variables);
      }
      this.queryInfo.resetLastWrite();
      return this.reobserve(reobserveOptions, NetworkStatus.refetch);
    };
    ObservableQuery2.prototype.fetchMore = function(fetchMoreOptions) {
      var _this = this;
      var combinedOptions = __assign(__assign({}, fetchMoreOptions.query ? fetchMoreOptions : __assign(__assign(__assign(__assign({}, this.options), { query: this.options.query }), fetchMoreOptions), { variables: __assign(__assign({}, this.options.variables), fetchMoreOptions.variables) })), {
        // The fetchMore request goes immediately to the network and does
        // not automatically write its result to the cache (hence no-cache
        // instead of network-only), because we allow the caller of
        // fetchMore to provide an updateQuery callback that determines how
        // the data gets written to the cache.
        fetchPolicy: "no-cache"
      });
      combinedOptions.query = this.transformDocument(combinedOptions.query);
      var qid = this.queryManager.generateQueryId();
      this.lastQuery = fetchMoreOptions.query ? this.transformDocument(this.options.query) : combinedOptions.query;
      var queryInfo = this.queryInfo;
      var originalNetworkStatus = queryInfo.networkStatus;
      queryInfo.networkStatus = NetworkStatus.fetchMore;
      if (combinedOptions.notifyOnNetworkStatusChange) {
        this.observe();
      }
      var updatedQuerySet = /* @__PURE__ */ new Set();
      var updateQuery = fetchMoreOptions === null || fetchMoreOptions === void 0 ? void 0 : fetchMoreOptions.updateQuery;
      var isCached = this.options.fetchPolicy !== "no-cache";
      if (!isCached) {
        invariant(updateQuery, 22);
      }
      return this.queryManager.fetchQuery(qid, combinedOptions, NetworkStatus.fetchMore).then(function(fetchMoreResult) {
        _this.queryManager.removeQuery(qid);
        if (queryInfo.networkStatus === NetworkStatus.fetchMore) {
          queryInfo.networkStatus = originalNetworkStatus;
        }
        if (isCached) {
          _this.queryManager.cache.batch({
            update: function(cache2) {
              var updateQuery2 = fetchMoreOptions.updateQuery;
              if (updateQuery2) {
                cache2.updateQuery({
                  query: _this.query,
                  variables: _this.variables,
                  returnPartialData: true,
                  optimistic: false
                }, function(previous) {
                  return updateQuery2(previous, {
                    fetchMoreResult: fetchMoreResult.data,
                    variables: combinedOptions.variables
                  });
                });
              } else {
                cache2.writeQuery({
                  query: combinedOptions.query,
                  variables: combinedOptions.variables,
                  data: fetchMoreResult.data
                });
              }
            },
            onWatchUpdated: function(watch) {
              updatedQuerySet.add(watch.query);
            }
          });
        } else {
          var lastResult = _this.getLast("result");
          var data = updateQuery(lastResult.data, {
            fetchMoreResult: fetchMoreResult.data,
            variables: combinedOptions.variables
          });
          _this.reportResult(__assign(__assign({}, lastResult), { data }), _this.variables);
        }
        return _this.maskResult(fetchMoreResult);
      }).finally(function() {
        if (isCached && !updatedQuerySet.has(_this.query)) {
          reobserveCacheFirst(_this);
        }
      });
    };
    ObservableQuery2.prototype.subscribeToMore = function(options) {
      var _this = this;
      var subscription = this.queryManager.startGraphQLSubscription({
        query: options.document,
        variables: options.variables,
        context: options.context
      }).subscribe({
        next: function(subscriptionData) {
          var updateQuery = options.updateQuery;
          if (updateQuery) {
            _this.updateQuery(function(previous, _a) {
              var variables = _a.variables;
              return updateQuery(previous, {
                subscriptionData,
                variables
              });
            });
          }
        },
        error: function(err) {
          if (options.onError) {
            options.onError(err);
            return;
          }
          globalThis.__DEV__ !== false && invariant.error(23, err);
        }
      });
      this.subscriptions.add(subscription);
      return function() {
        if (_this.subscriptions.delete(subscription)) {
          subscription.unsubscribe();
        }
      };
    };
    ObservableQuery2.prototype.setOptions = function(newOptions) {
      return this.reobserve(newOptions);
    };
    ObservableQuery2.prototype.silentSetOptions = function(newOptions) {
      var mergedOptions = compact(this.options, newOptions || {});
      assign(this.options, mergedOptions);
    };
    ObservableQuery2.prototype.setVariables = function(variables) {
      if (equal$1(this.variables, variables)) {
        return this.observers.size ? this.result() : Promise.resolve();
      }
      this.options.variables = variables;
      if (!this.observers.size) {
        return Promise.resolve();
      }
      return this.reobserve({
        // Reset options.fetchPolicy to its original value.
        fetchPolicy: this.options.initialFetchPolicy,
        variables
      }, NetworkStatus.setVariables);
    };
    ObservableQuery2.prototype.updateQuery = function(mapFn) {
      var queryManager = this.queryManager;
      var result = queryManager.cache.diff({
        query: this.options.query,
        variables: this.variables,
        returnPartialData: true,
        optimistic: false
      }).result;
      var newResult = mapFn(result, {
        variables: this.variables
      });
      if (newResult) {
        queryManager.cache.writeQuery({
          query: this.options.query,
          data: newResult,
          variables: this.variables
        });
        queryManager.broadcastQueries();
      }
    };
    ObservableQuery2.prototype.startPolling = function(pollInterval) {
      this.options.pollInterval = pollInterval;
      this.updatePolling();
    };
    ObservableQuery2.prototype.stopPolling = function() {
      this.options.pollInterval = 0;
      this.updatePolling();
    };
    ObservableQuery2.prototype.applyNextFetchPolicy = function(reason, options) {
      if (options.nextFetchPolicy) {
        var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? "cache-first" : _a, _b = options.initialFetchPolicy, initialFetchPolicy = _b === void 0 ? fetchPolicy : _b;
        if (fetchPolicy === "standby")
          ;
        else if (typeof options.nextFetchPolicy === "function") {
          options.fetchPolicy = options.nextFetchPolicy(fetchPolicy, {
            reason,
            options,
            observable: this,
            initialFetchPolicy
          });
        } else if (reason === "variables-changed") {
          options.fetchPolicy = initialFetchPolicy;
        } else {
          options.fetchPolicy = options.nextFetchPolicy;
        }
      }
      return options.fetchPolicy;
    };
    ObservableQuery2.prototype.fetch = function(options, newNetworkStatus, query) {
      this.queryManager.setObservableQuery(this);
      return this.queryManager["fetchConcastWithInfo"](this.queryId, options, newNetworkStatus, query);
    };
    ObservableQuery2.prototype.updatePolling = function() {
      var _this = this;
      if (this.queryManager.ssrMode) {
        return;
      }
      var _a = this, pollingInfo = _a.pollingInfo, pollInterval = _a.options.pollInterval;
      if (!pollInterval || !this.hasObservers()) {
        if (pollingInfo) {
          clearTimeout(pollingInfo.timeout);
          delete this.pollingInfo;
        }
        return;
      }
      if (pollingInfo && pollingInfo.interval === pollInterval) {
        return;
      }
      invariant(pollInterval, 24);
      var info = pollingInfo || (this.pollingInfo = {});
      info.interval = pollInterval;
      var maybeFetch = function() {
        var _a2, _b;
        if (_this.pollingInfo) {
          if (!isNetworkRequestInFlight(_this.queryInfo.networkStatus) && !((_b = (_a2 = _this.options).skipPollAttempt) === null || _b === void 0 ? void 0 : _b.call(_a2))) {
            _this.reobserve({
              // Most fetchPolicy options don't make sense to use in a polling context, as
              // users wouldn't want to be polling the cache directly. However, network-only and
              // no-cache are both useful for when the user wants to control whether or not the
              // polled results are written to the cache.
              fetchPolicy: _this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
            }, NetworkStatus.poll).then(poll, poll);
          } else {
            poll();
          }
        }
      };
      var poll = function() {
        var info2 = _this.pollingInfo;
        if (info2) {
          clearTimeout(info2.timeout);
          info2.timeout = setTimeout(maybeFetch, info2.interval);
        }
      };
      poll();
    };
    ObservableQuery2.prototype.updateLastResult = function(newResult, variables) {
      if (variables === void 0) {
        variables = this.variables;
      }
      var error = this.getLastError();
      if (error && this.last && !equal$1(variables, this.last.variables)) {
        error = void 0;
      }
      return this.last = __assign({ result: this.queryManager.assumeImmutableResults ? newResult : cloneDeep(newResult), variables }, error ? { error } : null);
    };
    ObservableQuery2.prototype.reobserveAsConcast = function(newOptions, newNetworkStatus) {
      var _this = this;
      this.isTornDown = false;
      var useDisposableConcast = (
        // Refetching uses a disposable Concast to allow refetches using different
        // options/variables, without permanently altering the options of the
        // original ObservableQuery.
        newNetworkStatus === NetworkStatus.refetch || // The fetchMore method does not actually call the reobserve method, but,
        // if it did, it would definitely use a disposable Concast.
        newNetworkStatus === NetworkStatus.fetchMore || // Polling uses a disposable Concast so the polling options (which force
        // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
        newNetworkStatus === NetworkStatus.poll
      );
      var oldVariables = this.options.variables;
      var oldFetchPolicy = this.options.fetchPolicy;
      var mergedOptions = compact(this.options, newOptions || {});
      var options = useDisposableConcast ? (
        // Disposable Concast fetches receive a shallow copy of this.options
        // (merged with newOptions), leaving this.options unmodified.
        mergedOptions
      ) : assign(this.options, mergedOptions);
      var query = this.transformDocument(options.query);
      this.lastQuery = query;
      if (!useDisposableConcast) {
        this.updatePolling();
        if (newOptions && newOptions.variables && !equal$1(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
        options.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
        // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
        (options.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,
        // so in that case `applyNextFetchPolicy` must be called.
        typeof options.nextFetchPolicy === "function")) {
          this.applyNextFetchPolicy("variables-changed", options);
          if (newNetworkStatus === void 0) {
            newNetworkStatus = NetworkStatus.setVariables;
          }
        }
      }
      this.waitForOwnResult && (this.waitForOwnResult = skipCacheDataFor(options.fetchPolicy));
      var finishWaitingForOwnResult = function() {
        if (_this.concast === concast) {
          _this.waitForOwnResult = false;
        }
      };
      var variables = options.variables && __assign({}, options.variables);
      var _a = this.fetch(options, newNetworkStatus, query), concast = _a.concast, fromLink = _a.fromLink;
      var observer = {
        next: function(result) {
          if (equal$1(_this.variables, variables)) {
            finishWaitingForOwnResult();
            _this.reportResult(result, variables);
          }
        },
        error: function(error) {
          if (equal$1(_this.variables, variables)) {
            if (!isApolloError(error)) {
              error = new ApolloError({ networkError: error });
            }
            finishWaitingForOwnResult();
            _this.reportError(error, variables);
          }
        }
      };
      if (!useDisposableConcast && (fromLink || !this.concast)) {
        if (this.concast && this.observer) {
          this.concast.removeObserver(this.observer);
        }
        this.concast = concast;
        this.observer = observer;
      }
      concast.addObserver(observer);
      return concast;
    };
    ObservableQuery2.prototype.reobserve = function(newOptions, newNetworkStatus) {
      return preventUnhandledRejection(this.reobserveAsConcast(newOptions, newNetworkStatus).promise.then(this.maskResult));
    };
    ObservableQuery2.prototype.resubscribeAfterError = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var last = this.last;
      this.resetLastResults();
      var subscription = this.subscribe.apply(this, args);
      this.last = last;
      return subscription;
    };
    ObservableQuery2.prototype.observe = function() {
      this.reportResult(
        // Passing false is important so that this.getCurrentResult doesn't
        // save the fetchMore result as this.lastResult, causing it to be
        // ignored due to the this.isDifferentFromLastResult check in
        // this.reportResult.
        this.getCurrentFullResult(false),
        this.variables
      );
    };
    ObservableQuery2.prototype.reportResult = function(result, variables) {
      var lastError = this.getLastError();
      var isDifferent = this.isDifferentFromLastResult(result, variables);
      if (lastError || !result.partial || this.options.returnPartialData) {
        this.updateLastResult(result, variables);
      }
      if (lastError || isDifferent) {
        iterateObserversSafely(this.observers, "next", this.maskResult(result));
      }
    };
    ObservableQuery2.prototype.reportError = function(error, variables) {
      var errorResult = __assign(__assign({}, this.getLastResult()), { error, errors: error.graphQLErrors, networkStatus: NetworkStatus.error, loading: false });
      this.updateLastResult(errorResult, variables);
      iterateObserversSafely(this.observers, "error", this.last.error = error);
    };
    ObservableQuery2.prototype.hasObservers = function() {
      return this.observers.size > 0;
    };
    ObservableQuery2.prototype.tearDownQuery = function() {
      if (this.isTornDown)
        return;
      if (this.concast && this.observer) {
        this.concast.removeObserver(this.observer);
        delete this.concast;
        delete this.observer;
      }
      this.stopPolling();
      this.subscriptions.forEach(function(sub) {
        return sub.unsubscribe();
      });
      this.subscriptions.clear();
      this.queryManager.stopQuery(this.queryId);
      this.observers.clear();
      this.isTornDown = true;
    };
    ObservableQuery2.prototype.transformDocument = function(document2) {
      return this.queryManager.transform(document2);
    };
    ObservableQuery2.prototype.maskResult = function(result) {
      return result && "data" in result ? __assign(__assign({}, result), { data: this.queryManager.maskOperation({
        document: this.query,
        data: result.data,
        fetchPolicy: this.options.fetchPolicy,
        id: this.queryId
      }) }) : result;
    };
    return ObservableQuery2;
  }(Observable)
);
fixObservableSubclass(ObservableQuery);
function reobserveCacheFirst(obsQuery) {
  var _a = obsQuery.options, fetchPolicy = _a.fetchPolicy, nextFetchPolicy = _a.nextFetchPolicy;
  if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
    return obsQuery.reobserve({
      fetchPolicy: "cache-first",
      // Use a temporary nextFetchPolicy function that replaces itself with the
      // previous nextFetchPolicy value and returns the original fetchPolicy.
      nextFetchPolicy: function(currentFetchPolicy, context) {
        this.nextFetchPolicy = nextFetchPolicy;
        if (typeof this.nextFetchPolicy === "function") {
          return this.nextFetchPolicy(currentFetchPolicy, context);
        }
        return fetchPolicy;
      }
    });
  }
  return obsQuery.reobserve();
}
function defaultSubscriptionObserverErrorCallback(error) {
  globalThis.__DEV__ !== false && invariant.error(25, error.message, error.stack);
}
function logMissingFieldErrors(missing) {
  if (globalThis.__DEV__ !== false && missing) {
    globalThis.__DEV__ !== false && invariant.debug(26, missing);
  }
}
function skipCacheDataFor(fetchPolicy) {
  return fetchPolicy === "network-only" || fetchPolicy === "no-cache" || fetchPolicy === "standby";
}
var destructiveMethodCounts = new (canUseWeakMap ? WeakMap : Map)();
function wrapDestructiveCacheMethod(cache2, methodName) {
  var original = cache2[methodName];
  if (typeof original === "function") {
    cache2[methodName] = function() {
      destructiveMethodCounts.set(
        cache2,
        // The %1e15 allows the count to wrap around to 0 safely every
        // quadrillion evictions, so there's no risk of overflow. To be
        // clear, this is more of a pedantic principle than something
        // that matters in any conceivable practical scenario.
        (destructiveMethodCounts.get(cache2) + 1) % 1e15
      );
      return original.apply(this, arguments);
    };
  }
}
function cancelNotifyTimeout(info) {
  if (info["notifyTimeout"]) {
    clearTimeout(info["notifyTimeout"]);
    info["notifyTimeout"] = void 0;
  }
}
var QueryInfo = (
  /** @class */
  function() {
    function QueryInfo2(queryManager, queryId) {
      if (queryId === void 0) {
        queryId = queryManager.generateQueryId();
      }
      this.queryId = queryId;
      this.listeners = /* @__PURE__ */ new Set();
      this.document = null;
      this.lastRequestId = 1;
      this.stopped = false;
      this.dirty = false;
      this.observableQuery = null;
      var cache2 = this.cache = queryManager.cache;
      if (!destructiveMethodCounts.has(cache2)) {
        destructiveMethodCounts.set(cache2, 0);
        wrapDestructiveCacheMethod(cache2, "evict");
        wrapDestructiveCacheMethod(cache2, "modify");
        wrapDestructiveCacheMethod(cache2, "reset");
      }
    }
    QueryInfo2.prototype.init = function(query) {
      var networkStatus = query.networkStatus || NetworkStatus.loading;
      if (this.variables && this.networkStatus !== NetworkStatus.loading && !equal$1(this.variables, query.variables)) {
        networkStatus = NetworkStatus.setVariables;
      }
      if (!equal$1(query.variables, this.variables)) {
        this.lastDiff = void 0;
      }
      Object.assign(this, {
        document: query.document,
        variables: query.variables,
        networkError: null,
        graphQLErrors: this.graphQLErrors || [],
        networkStatus
      });
      if (query.observableQuery) {
        this.setObservableQuery(query.observableQuery);
      }
      if (query.lastRequestId) {
        this.lastRequestId = query.lastRequestId;
      }
      return this;
    };
    QueryInfo2.prototype.reset = function() {
      cancelNotifyTimeout(this);
      this.dirty = false;
    };
    QueryInfo2.prototype.resetDiff = function() {
      this.lastDiff = void 0;
    };
    QueryInfo2.prototype.getDiff = function() {
      var options = this.getDiffOptions();
      if (this.lastDiff && equal$1(options, this.lastDiff.options)) {
        return this.lastDiff.diff;
      }
      this.updateWatch(this.variables);
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return { complete: false };
      }
      var diff = this.cache.diff(options);
      this.updateLastDiff(diff, options);
      return diff;
    };
    QueryInfo2.prototype.updateLastDiff = function(diff, options) {
      this.lastDiff = diff ? {
        diff,
        options: options || this.getDiffOptions()
      } : void 0;
    };
    QueryInfo2.prototype.getDiffOptions = function(variables) {
      var _a;
      if (variables === void 0) {
        variables = this.variables;
      }
      return {
        query: this.document,
        variables,
        returnPartialData: true,
        optimistic: true,
        canonizeResults: (_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.options.canonizeResults
      };
    };
    QueryInfo2.prototype.setDiff = function(diff) {
      var _this = this;
      var _a;
      var oldDiff = this.lastDiff && this.lastDiff.diff;
      if (diff && !diff.complete && ((_a = this.observableQuery) === null || _a === void 0 ? void 0 : _a.getLastError())) {
        return;
      }
      this.updateLastDiff(diff);
      if (!this.dirty && !equal$1(oldDiff && oldDiff.result, diff && diff.result)) {
        this.dirty = true;
        if (!this.notifyTimeout) {
          this.notifyTimeout = setTimeout(function() {
            return _this.notify();
          }, 0);
        }
      }
    };
    QueryInfo2.prototype.setObservableQuery = function(oq) {
      var _this = this;
      if (oq === this.observableQuery)
        return;
      if (this.oqListener) {
        this.listeners.delete(this.oqListener);
      }
      this.observableQuery = oq;
      if (oq) {
        oq["queryInfo"] = this;
        this.listeners.add(this.oqListener = function() {
          var diff = _this.getDiff();
          if (diff.fromOptimisticTransaction) {
            oq["observe"]();
          } else {
            reobserveCacheFirst(oq);
          }
        });
      } else {
        delete this.oqListener;
      }
    };
    QueryInfo2.prototype.notify = function() {
      var _this = this;
      cancelNotifyTimeout(this);
      if (this.shouldNotify()) {
        this.listeners.forEach(function(listener) {
          return listener(_this);
        });
      }
      this.dirty = false;
    };
    QueryInfo2.prototype.shouldNotify = function() {
      if (!this.dirty || !this.listeners.size) {
        return false;
      }
      if (isNetworkRequestInFlight(this.networkStatus) && this.observableQuery) {
        var fetchPolicy = this.observableQuery.options.fetchPolicy;
        if (fetchPolicy !== "cache-only" && fetchPolicy !== "cache-and-network") {
          return false;
        }
      }
      return true;
    };
    QueryInfo2.prototype.stop = function() {
      if (!this.stopped) {
        this.stopped = true;
        this.reset();
        this.cancel();
        this.cancel = QueryInfo2.prototype.cancel;
        var oq = this.observableQuery;
        if (oq)
          oq.stopPolling();
      }
    };
    QueryInfo2.prototype.cancel = function() {
    };
    QueryInfo2.prototype.updateWatch = function(variables) {
      var _this = this;
      if (variables === void 0) {
        variables = this.variables;
      }
      var oq = this.observableQuery;
      if (oq && oq.options.fetchPolicy === "no-cache") {
        return;
      }
      var watchOptions = __assign(__assign({}, this.getDiffOptions(variables)), { watcher: this, callback: function(diff) {
        return _this.setDiff(diff);
      } });
      if (!this.lastWatch || !equal$1(watchOptions, this.lastWatch)) {
        this.cancel();
        this.cancel = this.cache.watch(this.lastWatch = watchOptions);
      }
    };
    QueryInfo2.prototype.resetLastWrite = function() {
      this.lastWrite = void 0;
    };
    QueryInfo2.prototype.shouldWrite = function(result, variables) {
      var lastWrite = this.lastWrite;
      return !(lastWrite && // If cache.evict has been called since the last time we wrote this
      // data into the cache, there's a chance writing this result into
      // the cache will repair what was evicted.
      lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal$1(variables, lastWrite.variables) && equal$1(result.data, lastWrite.result.data));
    };
    QueryInfo2.prototype.markResult = function(result, document2, options, cacheWriteBehavior) {
      var _this = this;
      var merger = new DeepMerger();
      var graphQLErrors = isNonEmptyArray(result.errors) ? result.errors.slice(0) : [];
      this.reset();
      if ("incremental" in result && isNonEmptyArray(result.incremental)) {
        var mergedData = mergeIncrementalData(this.getDiff().result, result);
        result.data = mergedData;
      } else if ("hasNext" in result && result.hasNext) {
        var diff = this.getDiff();
        result.data = merger.merge(diff.result, result.data);
      }
      this.graphQLErrors = graphQLErrors;
      if (options.fetchPolicy === "no-cache") {
        this.updateLastDiff({ result: result.data, complete: true }, this.getDiffOptions(options.variables));
      } else if (cacheWriteBehavior !== 0) {
        if (shouldWriteResult(result, options.errorPolicy)) {
          this.cache.performTransaction(function(cache2) {
            if (_this.shouldWrite(result, options.variables)) {
              cache2.writeQuery({
                query: document2,
                data: result.data,
                variables: options.variables,
                overwrite: cacheWriteBehavior === 1
              });
              _this.lastWrite = {
                result,
                variables: options.variables,
                dmCount: destructiveMethodCounts.get(_this.cache)
              };
            } else {
              if (_this.lastDiff && _this.lastDiff.diff.complete) {
                result.data = _this.lastDiff.diff.result;
                return;
              }
            }
            var diffOptions = _this.getDiffOptions(options.variables);
            var diff2 = cache2.diff(diffOptions);
            if (!_this.stopped && equal$1(_this.variables, options.variables)) {
              _this.updateWatch(options.variables);
            }
            _this.updateLastDiff(diff2, diffOptions);
            if (diff2.complete) {
              result.data = diff2.result;
            }
          });
        } else {
          this.lastWrite = void 0;
        }
      }
    };
    QueryInfo2.prototype.markReady = function() {
      this.networkError = null;
      return this.networkStatus = NetworkStatus.ready;
    };
    QueryInfo2.prototype.markError = function(error) {
      this.networkStatus = NetworkStatus.error;
      this.lastWrite = void 0;
      this.reset();
      if (error.graphQLErrors) {
        this.graphQLErrors = error.graphQLErrors;
      }
      if (error.networkError) {
        this.networkError = error.networkError;
      }
      return error;
    };
    return QueryInfo2;
  }()
);
function shouldWriteResult(result, errorPolicy) {
  if (errorPolicy === void 0) {
    errorPolicy = "none";
  }
  var ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  var writeWithErrors = !graphQLResultHasError(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var IGNORE = /* @__PURE__ */ Object.create(null);
var QueryManager = (
  /** @class */
  function() {
    function QueryManager2(options) {
      var _this = this;
      this.clientAwareness = {};
      this.queries = /* @__PURE__ */ new Map();
      this.fetchCancelFns = /* @__PURE__ */ new Map();
      this.transformCache = new AutoCleanedWeakCache(
        cacheSizes["queryManager.getDocumentInfo"] || 2e3
        /* defaultCacheSizes["queryManager.getDocumentInfo"] */
      );
      this.queryIdCounter = 1;
      this.requestIdCounter = 1;
      this.mutationIdCounter = 1;
      this.inFlightLinkObservables = new Trie(false);
      this.noCacheWarningsByQueryId = /* @__PURE__ */ new Set();
      var defaultDocumentTransform = new DocumentTransform(
        function(document2) {
          return _this.cache.transformDocument(document2);
        },
        // Allow the apollo cache to manage its own transform caches
        { cache: false }
      );
      this.cache = options.cache;
      this.link = options.link;
      this.defaultOptions = options.defaultOptions;
      this.queryDeduplication = options.queryDeduplication;
      this.clientAwareness = options.clientAwareness;
      this.localState = options.localState;
      this.ssrMode = options.ssrMode;
      this.assumeImmutableResults = options.assumeImmutableResults;
      this.dataMasking = options.dataMasking;
      var documentTransform = options.documentTransform;
      this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
      this.defaultContext = options.defaultContext || /* @__PURE__ */ Object.create(null);
      if (this.onBroadcast = options.onBroadcast) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
    }
    QueryManager2.prototype.stop = function() {
      var _this = this;
      this.queries.forEach(function(_info, queryId) {
        _this.stopQueryNoBroadcast(queryId);
      });
      this.cancelPendingFetches(newInvariantError(27));
    };
    QueryManager2.prototype.cancelPendingFetches = function(error) {
      this.fetchCancelFns.forEach(function(cancel) {
        return cancel(error);
      });
      this.fetchCancelFns.clear();
    };
    QueryManager2.prototype.mutate = function(_a) {
      return __awaiter(this, arguments, void 0, function(_b) {
        var mutationId, hasClientExports2, mutationStoreValue, isOptimistic, self2;
        var _c, _d;
        var mutation = _b.mutation, variables = _b.variables, optimisticResponse = _b.optimisticResponse, updateQueries = _b.updateQueries, _e = _b.refetchQueries, refetchQueries = _e === void 0 ? [] : _e, _f = _b.awaitRefetchQueries, awaitRefetchQueries = _f === void 0 ? false : _f, updateWithProxyFn = _b.update, onQueryUpdated = _b.onQueryUpdated, _g = _b.fetchPolicy, fetchPolicy = _g === void 0 ? ((_c = this.defaultOptions.mutate) === null || _c === void 0 ? void 0 : _c.fetchPolicy) || "network-only" : _g, _h = _b.errorPolicy, errorPolicy = _h === void 0 ? ((_d = this.defaultOptions.mutate) === null || _d === void 0 ? void 0 : _d.errorPolicy) || "none" : _h, keepRootFields = _b.keepRootFields, context = _b.context;
        return __generator(this, function(_j) {
          switch (_j.label) {
            case 0:
              invariant(mutation, 28);
              invariant(fetchPolicy === "network-only" || fetchPolicy === "no-cache", 29);
              mutationId = this.generateMutationId();
              mutation = this.cache.transformForLink(this.transform(mutation));
              hasClientExports2 = this.getDocumentInfo(mutation).hasClientExports;
              variables = this.getVariables(mutation, variables);
              if (!hasClientExports2)
                return [3, 2];
              return [4, this.localState.addExportedVariables(mutation, variables, context)];
            case 1:
              variables = _j.sent();
              _j.label = 2;
            case 2:
              mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {
                mutation,
                variables,
                loading: true,
                error: null
              });
              isOptimistic = optimisticResponse && this.markMutationOptimistic(optimisticResponse, {
                mutationId,
                document: mutation,
                variables,
                fetchPolicy,
                errorPolicy,
                context,
                updateQueries,
                update: updateWithProxyFn,
                keepRootFields
              });
              this.broadcastQueries();
              self2 = this;
              return [2, new Promise(function(resolve, reject) {
                return asyncMap(self2.getObservableFromLink(mutation, __assign(__assign({}, context), { optimisticResponse: isOptimistic ? optimisticResponse : void 0 }), variables, {}, false), function(result) {
                  if (graphQLResultHasError(result) && errorPolicy === "none") {
                    throw new ApolloError({
                      graphQLErrors: getGraphQLErrorsFromResult(result)
                    });
                  }
                  if (mutationStoreValue) {
                    mutationStoreValue.loading = false;
                    mutationStoreValue.error = null;
                  }
                  var storeResult = __assign({}, result);
                  if (typeof refetchQueries === "function") {
                    refetchQueries = refetchQueries(storeResult);
                  }
                  if (errorPolicy === "ignore" && graphQLResultHasError(storeResult)) {
                    delete storeResult.errors;
                  }
                  return self2.markMutationResult({
                    mutationId,
                    result: storeResult,
                    document: mutation,
                    variables,
                    fetchPolicy,
                    errorPolicy,
                    context,
                    update: updateWithProxyFn,
                    updateQueries,
                    awaitRefetchQueries,
                    refetchQueries,
                    removeOptimistic: isOptimistic ? mutationId : void 0,
                    onQueryUpdated,
                    keepRootFields
                  });
                }).subscribe({
                  next: function(storeResult) {
                    self2.broadcastQueries();
                    if (!("hasNext" in storeResult) || storeResult.hasNext === false) {
                      resolve(__assign(__assign({}, storeResult), { data: self2.maskOperation({
                        document: mutation,
                        data: storeResult.data,
                        fetchPolicy,
                        id: mutationId
                      }) }));
                    }
                  },
                  error: function(err) {
                    if (mutationStoreValue) {
                      mutationStoreValue.loading = false;
                      mutationStoreValue.error = err;
                    }
                    if (isOptimistic) {
                      self2.cache.removeOptimistic(mutationId);
                    }
                    self2.broadcastQueries();
                    reject(err instanceof ApolloError ? err : new ApolloError({
                      networkError: err
                    }));
                  }
                });
              })];
          }
        });
      });
    };
    QueryManager2.prototype.markMutationResult = function(mutation, cache2) {
      var _this = this;
      if (cache2 === void 0) {
        cache2 = this.cache;
      }
      var result = mutation.result;
      var cacheWrites = [];
      var skipCache = mutation.fetchPolicy === "no-cache";
      if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
        if (!isExecutionPatchIncrementalResult(result)) {
          cacheWrites.push({
            result: result.data,
            dataId: "ROOT_MUTATION",
            query: mutation.document,
            variables: mutation.variables
          });
        }
        if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {
          var diff = cache2.diff({
            id: "ROOT_MUTATION",
            // The cache complains if passed a mutation where it expects a
            // query, so we transform mutations and subscriptions to queries
            // (only once, thanks to this.transformCache).
            query: this.getDocumentInfo(mutation.document).asQuery,
            variables: mutation.variables,
            optimistic: false,
            returnPartialData: true
          });
          var mergedData = void 0;
          if (diff.result) {
            mergedData = mergeIncrementalData(diff.result, result);
          }
          if (typeof mergedData !== "undefined") {
            result.data = mergedData;
            cacheWrites.push({
              result: mergedData,
              dataId: "ROOT_MUTATION",
              query: mutation.document,
              variables: mutation.variables
            });
          }
        }
        var updateQueries_1 = mutation.updateQueries;
        if (updateQueries_1) {
          this.queries.forEach(function(_a, queryId) {
            var observableQuery = _a.observableQuery;
            var queryName = observableQuery && observableQuery.queryName;
            if (!queryName || !hasOwnProperty$1.call(updateQueries_1, queryName)) {
              return;
            }
            var updater = updateQueries_1[queryName];
            var _b = _this.queries.get(queryId), document2 = _b.document, variables = _b.variables;
            var _c = cache2.diff({
              query: document2,
              variables,
              returnPartialData: true,
              optimistic: false
            }), currentQueryResult = _c.result, complete = _c.complete;
            if (complete && currentQueryResult) {
              var nextQueryResult = updater(currentQueryResult, {
                mutationResult: result,
                queryName: document2 && getOperationName(document2) || void 0,
                queryVariables: variables
              });
              if (nextQueryResult) {
                cacheWrites.push({
                  result: nextQueryResult,
                  dataId: "ROOT_QUERY",
                  query: document2,
                  variables
                });
              }
            }
          });
        }
      }
      if (cacheWrites.length > 0 || (mutation.refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
        var results_1 = [];
        this.refetchQueries({
          updateCache: function(cache3) {
            if (!skipCache) {
              cacheWrites.forEach(function(write) {
                return cache3.write(write);
              });
            }
            var update = mutation.update;
            var isFinalResult = !isExecutionPatchResult(result) || isExecutionPatchIncrementalResult(result) && !result.hasNext;
            if (update) {
              if (!skipCache) {
                var diff2 = cache3.diff({
                  id: "ROOT_MUTATION",
                  // The cache complains if passed a mutation where it expects a
                  // query, so we transform mutations and subscriptions to queries
                  // (only once, thanks to this.transformCache).
                  query: _this.getDocumentInfo(mutation.document).asQuery,
                  variables: mutation.variables,
                  optimistic: false,
                  returnPartialData: true
                });
                if (diff2.complete) {
                  result = __assign(__assign({}, result), { data: diff2.result });
                  if ("incremental" in result) {
                    delete result.incremental;
                  }
                  if ("hasNext" in result) {
                    delete result.hasNext;
                  }
                }
              }
              if (isFinalResult) {
                update(cache3, result, {
                  context: mutation.context,
                  variables: mutation.variables
                });
              }
            }
            if (!skipCache && !mutation.keepRootFields && isFinalResult) {
              cache3.modify({
                id: "ROOT_MUTATION",
                fields: function(value, _a) {
                  var fieldName = _a.fieldName, DELETE2 = _a.DELETE;
                  return fieldName === "__typename" ? value : DELETE2;
                }
              });
            }
          },
          include: mutation.refetchQueries,
          // Write the final mutation.result to the root layer of the cache.
          optimistic: false,
          // Remove the corresponding optimistic layer at the same time as we
          // write the final non-optimistic result.
          removeOptimistic: mutation.removeOptimistic,
          // Let the caller of client.mutate optionally determine the refetching
          // behavior for watched queries after the mutation.update function runs.
          // If no onQueryUpdated function was provided for this mutation, pass
          // null instead of undefined to disable the default refetching behavior.
          onQueryUpdated: mutation.onQueryUpdated || null
        }).forEach(function(result2) {
          return results_1.push(result2);
        });
        if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
          return Promise.all(results_1).then(function() {
            return result;
          });
        }
      }
      return Promise.resolve(result);
    };
    QueryManager2.prototype.markMutationOptimistic = function(optimisticResponse, mutation) {
      var _this = this;
      var data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
      if (data === IGNORE) {
        return false;
      }
      this.cache.recordOptimisticTransaction(function(cache2) {
        try {
          _this.markMutationResult(__assign(__assign({}, mutation), { result: { data } }), cache2);
        } catch (error) {
          globalThis.__DEV__ !== false && invariant.error(error);
        }
      }, mutation.mutationId);
      return true;
    };
    QueryManager2.prototype.fetchQuery = function(queryId, options, networkStatus) {
      return this.fetchConcastWithInfo(queryId, options, networkStatus).concast.promise;
    };
    QueryManager2.prototype.getQueryStore = function() {
      var store = /* @__PURE__ */ Object.create(null);
      this.queries.forEach(function(info, queryId) {
        store[queryId] = {
          variables: info.variables,
          networkStatus: info.networkStatus,
          networkError: info.networkError,
          graphQLErrors: info.graphQLErrors
        };
      });
      return store;
    };
    QueryManager2.prototype.resetErrors = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo) {
        queryInfo.networkError = void 0;
        queryInfo.graphQLErrors = [];
      }
    };
    QueryManager2.prototype.transform = function(document2) {
      return this.documentTransform.transformDocument(document2);
    };
    QueryManager2.prototype.getDocumentInfo = function(document2) {
      var transformCache = this.transformCache;
      if (!transformCache.has(document2)) {
        var cacheEntry = {
          // TODO These three calls (hasClientExports, shouldForceResolvers, and
          // usesNonreactiveDirective) are performing independent full traversals
          // of the transformed document. We should consider merging these
          // traversals into a single pass in the future, though the work is
          // cached after the first time.
          hasClientExports: hasClientExports(document2),
          hasForcedResolvers: this.localState.shouldForceResolvers(document2),
          hasNonreactiveDirective: hasDirectives(["nonreactive"], document2),
          nonReactiveQuery: addNonReactiveToNamedFragments(document2),
          clientQuery: this.localState.clientQuery(document2),
          serverQuery: removeDirectivesFromDocument([
            { name: "client", remove: true },
            { name: "connection" },
            { name: "nonreactive" },
            { name: "unmask" }
          ], document2),
          defaultVars: getDefaultValues(getOperationDefinition(document2)),
          // Transform any mutation or subscription operations to query operations
          // so we can read/write them from/to the cache.
          asQuery: __assign(__assign({}, document2), { definitions: document2.definitions.map(function(def) {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return __assign(__assign({}, def), { operation: "query" });
            }
            return def;
          }) })
        };
        transformCache.set(document2, cacheEntry);
      }
      return transformCache.get(document2);
    };
    QueryManager2.prototype.getVariables = function(document2, variables) {
      return __assign(__assign({}, this.getDocumentInfo(document2).defaultVars), variables);
    };
    QueryManager2.prototype.watchQuery = function(options) {
      var query = this.transform(options.query);
      options = __assign(__assign({}, options), { variables: this.getVariables(query, options.variables) });
      if (typeof options.notifyOnNetworkStatusChange === "undefined") {
        options.notifyOnNetworkStatusChange = false;
      }
      var queryInfo = new QueryInfo(this);
      var observable = new ObservableQuery({
        queryManager: this,
        queryInfo,
        options
      });
      observable["lastQuery"] = query;
      this.queries.set(observable.queryId, queryInfo);
      queryInfo.init({
        document: query,
        observableQuery: observable,
        variables: observable.variables
      });
      return observable;
    };
    QueryManager2.prototype.query = function(options, queryId) {
      var _this = this;
      if (queryId === void 0) {
        queryId = this.generateQueryId();
      }
      invariant(options.query, 30);
      invariant(options.query.kind === "Document", 31);
      invariant(!options.returnPartialData, 32);
      invariant(!options.pollInterval, 33);
      var query = this.transform(options.query);
      return this.fetchQuery(queryId, __assign(__assign({}, options), { query })).then(function(result) {
        return result && __assign(__assign({}, result), { data: _this.maskOperation({
          document: query,
          data: result.data,
          fetchPolicy: options.fetchPolicy,
          id: queryId
        }) });
      }).finally(function() {
        return _this.stopQuery(queryId);
      });
    };
    QueryManager2.prototype.generateQueryId = function() {
      return String(this.queryIdCounter++);
    };
    QueryManager2.prototype.generateRequestId = function() {
      return this.requestIdCounter++;
    };
    QueryManager2.prototype.generateMutationId = function() {
      return String(this.mutationIdCounter++);
    };
    QueryManager2.prototype.stopQueryInStore = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryInStoreNoBroadcast = function(queryId) {
      var queryInfo = this.queries.get(queryId);
      if (queryInfo)
        queryInfo.stop();
    };
    QueryManager2.prototype.clearStore = function(options) {
      if (options === void 0) {
        options = {
          discardWatches: true
        };
      }
      this.cancelPendingFetches(newInvariantError(34));
      this.queries.forEach(function(queryInfo) {
        if (queryInfo.observableQuery) {
          queryInfo.networkStatus = NetworkStatus.loading;
        } else {
          queryInfo.stop();
        }
      });
      if (this.mutationStore) {
        this.mutationStore = /* @__PURE__ */ Object.create(null);
      }
      return this.cache.reset(options);
    };
    QueryManager2.prototype.getObservableQueries = function(include) {
      var _this = this;
      if (include === void 0) {
        include = "active";
      }
      var queries = /* @__PURE__ */ new Map();
      var queryNames = /* @__PURE__ */ new Map();
      var queryNamesAndQueryStrings = /* @__PURE__ */ new Map();
      var legacyQueryOptions = /* @__PURE__ */ new Set();
      if (Array.isArray(include)) {
        include.forEach(function(desc) {
          if (typeof desc === "string") {
            queryNames.set(desc, desc);
            queryNamesAndQueryStrings.set(desc, false);
          } else if (isDocumentNode(desc)) {
            var queryString = print(_this.transform(desc));
            queryNames.set(queryString, getOperationName(desc));
            queryNamesAndQueryStrings.set(queryString, false);
          } else if (isNonNullObject(desc) && desc.query) {
            legacyQueryOptions.add(desc);
          }
        });
      }
      this.queries.forEach(function(_a, queryId) {
        var oq = _a.observableQuery, document2 = _a.document;
        if (oq) {
          if (include === "all") {
            queries.set(queryId, oq);
            return;
          }
          var queryName = oq.queryName, fetchPolicy = oq.options.fetchPolicy;
          if (fetchPolicy === "standby" || include === "active" && !oq.hasObservers()) {
            return;
          }
          if (include === "active" || queryName && queryNamesAndQueryStrings.has(queryName) || document2 && queryNamesAndQueryStrings.has(print(document2))) {
            queries.set(queryId, oq);
            if (queryName)
              queryNamesAndQueryStrings.set(queryName, true);
            if (document2)
              queryNamesAndQueryStrings.set(print(document2), true);
          }
        }
      });
      if (legacyQueryOptions.size) {
        legacyQueryOptions.forEach(function(options) {
          var queryId = makeUniqueId("legacyOneTimeQuery");
          var queryInfo = _this.getQuery(queryId).init({
            document: options.query,
            variables: options.variables
          });
          var oq = new ObservableQuery({
            queryManager: _this,
            queryInfo,
            options: __assign(__assign({}, options), { fetchPolicy: "network-only" })
          });
          invariant(oq.queryId === queryId);
          queryInfo.setObservableQuery(oq);
          queries.set(queryId, oq);
        });
      }
      if (globalThis.__DEV__ !== false && queryNamesAndQueryStrings.size) {
        queryNamesAndQueryStrings.forEach(function(included, nameOrQueryString) {
          if (!included) {
            var queryName = queryNames.get(nameOrQueryString);
            if (queryName) {
              globalThis.__DEV__ !== false && invariant.warn(35, queryName);
            } else {
              globalThis.__DEV__ !== false && invariant.warn(36);
            }
          }
        });
      }
      return queries;
    };
    QueryManager2.prototype.reFetchObservableQueries = function(includeStandby) {
      var _this = this;
      if (includeStandby === void 0) {
        includeStandby = false;
      }
      var observableQueryPromises = [];
      this.getObservableQueries(includeStandby ? "all" : "active").forEach(function(observableQuery, queryId) {
        var fetchPolicy = observableQuery.options.fetchPolicy;
        observableQuery.resetLastResults();
        if (includeStandby || fetchPolicy !== "standby" && fetchPolicy !== "cache-only") {
          observableQueryPromises.push(observableQuery.refetch());
        }
        _this.getQuery(queryId).setDiff(null);
      });
      this.broadcastQueries();
      return Promise.all(observableQueryPromises);
    };
    QueryManager2.prototype.setObservableQuery = function(observableQuery) {
      this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);
    };
    QueryManager2.prototype.startGraphQLSubscription = function(options) {
      var _this = this;
      var query = options.query, variables = options.variables;
      var fetchPolicy = options.fetchPolicy, _a = options.errorPolicy, errorPolicy = _a === void 0 ? "none" : _a, _b = options.context, context = _b === void 0 ? {} : _b, _c = options.extensions, extensions = _c === void 0 ? {} : _c;
      query = this.transform(query);
      variables = this.getVariables(query, variables);
      var makeObservable = function(variables2) {
        return _this.getObservableFromLink(query, context, variables2, extensions).map(function(result) {
          if (fetchPolicy !== "no-cache") {
            if (shouldWriteResult(result, errorPolicy)) {
              _this.cache.write({
                query,
                result: result.data,
                dataId: "ROOT_SUBSCRIPTION",
                variables: variables2
              });
            }
            _this.broadcastQueries();
          }
          var hasErrors = graphQLResultHasError(result);
          var hasProtocolErrors = graphQLResultHasProtocolErrors(result);
          if (hasErrors || hasProtocolErrors) {
            var errors = {};
            if (hasErrors) {
              errors.graphQLErrors = result.errors;
            }
            if (hasProtocolErrors) {
              errors.protocolErrors = result.extensions[PROTOCOL_ERRORS_SYMBOL];
            }
            if (errorPolicy === "none" || hasProtocolErrors) {
              throw new ApolloError(errors);
            }
          }
          if (errorPolicy === "ignore") {
            delete result.errors;
          }
          return result;
        });
      };
      if (this.getDocumentInfo(query).hasClientExports) {
        var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);
        return new Observable(function(observer) {
          var sub = null;
          observablePromise_1.then(function(observable) {
            return sub = observable.subscribe(observer);
          }, observer.error);
          return function() {
            return sub && sub.unsubscribe();
          };
        });
      }
      return makeObservable(variables);
    };
    QueryManager2.prototype.stopQuery = function(queryId) {
      this.stopQueryNoBroadcast(queryId);
      this.broadcastQueries();
    };
    QueryManager2.prototype.stopQueryNoBroadcast = function(queryId) {
      this.stopQueryInStoreNoBroadcast(queryId);
      this.removeQuery(queryId);
    };
    QueryManager2.prototype.removeQuery = function(queryId) {
      this.fetchCancelFns.delete(queryId);
      if (this.queries.has(queryId)) {
        this.getQuery(queryId).stop();
        this.queries.delete(queryId);
      }
    };
    QueryManager2.prototype.broadcastQueries = function() {
      if (this.onBroadcast)
        this.onBroadcast();
      this.queries.forEach(function(info) {
        return info.notify();
      });
    };
    QueryManager2.prototype.getLocalState = function() {
      return this.localState;
    };
    QueryManager2.prototype.getObservableFromLink = function(query, context, variables, extensions, deduplication) {
      var _this = this;
      var _a;
      if (deduplication === void 0) {
        deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;
      }
      var observable;
      var _b = this.getDocumentInfo(query), serverQuery = _b.serverQuery, clientQuery = _b.clientQuery;
      if (serverQuery) {
        var _c = this, inFlightLinkObservables_1 = _c.inFlightLinkObservables, link = _c.link;
        var operation = {
          query: serverQuery,
          variables,
          operationName: getOperationName(serverQuery) || void 0,
          context: this.prepareContext(__assign(__assign({}, context), { forceFetch: !deduplication })),
          extensions
        };
        context = operation.context;
        if (deduplication) {
          var printedServerQuery_1 = print(serverQuery);
          var varJson_1 = canonicalStringify(variables);
          var entry = inFlightLinkObservables_1.lookup(printedServerQuery_1, varJson_1);
          observable = entry.observable;
          if (!observable) {
            var concast = new Concast([
              execute(link, operation)
            ]);
            observable = entry.observable = concast;
            concast.beforeNext(function() {
              inFlightLinkObservables_1.remove(printedServerQuery_1, varJson_1);
            });
          }
        } else {
          observable = new Concast([
            execute(link, operation)
          ]);
        }
      } else {
        observable = new Concast([Observable.of({ data: {} })]);
        context = this.prepareContext(context);
      }
      if (clientQuery) {
        observable = asyncMap(observable, function(result) {
          return _this.localState.runResolvers({
            document: clientQuery,
            remoteResult: result,
            context,
            variables
          });
        });
      }
      return observable;
    };
    QueryManager2.prototype.getResultsFromLink = function(queryInfo, cacheWriteBehavior, options) {
      var requestId = queryInfo.lastRequestId = this.generateRequestId();
      var linkDocument = this.cache.transformForLink(options.query);
      return asyncMap(this.getObservableFromLink(linkDocument, options.context, options.variables), function(result) {
        var graphQLErrors = getGraphQLErrorsFromResult(result);
        var hasErrors = graphQLErrors.length > 0;
        var errorPolicy = options.errorPolicy;
        if (requestId >= queryInfo.lastRequestId) {
          if (hasErrors && errorPolicy === "none") {
            throw queryInfo.markError(new ApolloError({
              graphQLErrors
            }));
          }
          queryInfo.markResult(result, linkDocument, options, cacheWriteBehavior);
          queryInfo.markReady();
        }
        var aqr = {
          data: result.data,
          loading: false,
          networkStatus: NetworkStatus.ready
        };
        if (hasErrors && errorPolicy === "none") {
          aqr.data = void 0;
        }
        if (hasErrors && errorPolicy !== "ignore") {
          aqr.errors = graphQLErrors;
          aqr.networkStatus = NetworkStatus.error;
        }
        return aqr;
      }, function(networkError) {
        var error = isApolloError(networkError) ? networkError : new ApolloError({ networkError });
        if (requestId >= queryInfo.lastRequestId) {
          queryInfo.markError(error);
        }
        throw error;
      });
    };
    QueryManager2.prototype.fetchConcastWithInfo = function(queryId, options, networkStatus, query) {
      var _this = this;
      if (networkStatus === void 0) {
        networkStatus = NetworkStatus.loading;
      }
      if (query === void 0) {
        query = options.query;
      }
      var variables = this.getVariables(query, options.variables);
      var queryInfo = this.getQuery(queryId);
      var defaults = this.defaultOptions.watchQuery;
      var _a = options.fetchPolicy, fetchPolicy = _a === void 0 ? defaults && defaults.fetchPolicy || "cache-first" : _a, _b = options.errorPolicy, errorPolicy = _b === void 0 ? defaults && defaults.errorPolicy || "none" : _b, _c = options.returnPartialData, returnPartialData = _c === void 0 ? false : _c, _d = options.notifyOnNetworkStatusChange, notifyOnNetworkStatusChange = _d === void 0 ? false : _d, _e = options.context, context = _e === void 0 ? {} : _e;
      var normalized = Object.assign({}, options, {
        query,
        variables,
        fetchPolicy,
        errorPolicy,
        returnPartialData,
        notifyOnNetworkStatusChange,
        context
      });
      var fromVariables = function(variables2) {
        normalized.variables = variables2;
        var sourcesWithInfo2 = _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);
        if (
          // If we're in standby, postpone advancing options.fetchPolicy using
          // applyNextFetchPolicy.
          normalized.fetchPolicy !== "standby" && // The "standby" policy currently returns [] from fetchQueryByPolicy, so
          // this is another way to detect when nothing was done/fetched.
          sourcesWithInfo2.sources.length > 0 && queryInfo.observableQuery
        ) {
          queryInfo.observableQuery["applyNextFetchPolicy"]("after-fetch", options);
        }
        return sourcesWithInfo2;
      };
      var cleanupCancelFn = function() {
        return _this.fetchCancelFns.delete(queryId);
      };
      this.fetchCancelFns.set(queryId, function(reason) {
        cleanupCancelFn();
        setTimeout(function() {
          return concast.cancel(reason);
        });
      });
      var concast, containsDataFromLink;
      if (this.getDocumentInfo(normalized.query).hasClientExports) {
        concast = new Concast(this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables).then(function(sourcesWithInfo2) {
          return sourcesWithInfo2.sources;
        }));
        containsDataFromLink = true;
      } else {
        var sourcesWithInfo = fromVariables(normalized.variables);
        containsDataFromLink = sourcesWithInfo.fromLink;
        concast = new Concast(sourcesWithInfo.sources);
      }
      concast.promise.then(cleanupCancelFn, cleanupCancelFn);
      return {
        concast,
        fromLink: containsDataFromLink
      };
    };
    QueryManager2.prototype.refetchQueries = function(_a) {
      var _this = this;
      var updateCache = _a.updateCache, include = _a.include, _b = _a.optimistic, optimistic = _b === void 0 ? false : _b, _c = _a.removeOptimistic, removeOptimistic = _c === void 0 ? optimistic ? makeUniqueId("refetchQueries") : void 0 : _c, onQueryUpdated = _a.onQueryUpdated;
      var includedQueriesById = /* @__PURE__ */ new Map();
      if (include) {
        this.getObservableQueries(include).forEach(function(oq, queryId) {
          includedQueriesById.set(queryId, {
            oq,
            lastDiff: _this.getQuery(queryId).getDiff()
          });
        });
      }
      var results2 = /* @__PURE__ */ new Map();
      if (updateCache) {
        this.cache.batch({
          update: updateCache,
          // Since you can perform any combination of cache reads and/or writes in
          // the cache.batch update function, its optimistic option can be either
          // a boolean or a string, representing three distinct modes of
          // operation:
          //
          // * false: read/write only the root layer
          // * true: read/write the topmost layer
          // * string: read/write a fresh optimistic layer with that ID string
          //
          // When typeof optimistic === "string", a new optimistic layer will be
          // temporarily created within cache.batch with that string as its ID. If
          // we then pass that same string as the removeOptimistic option, we can
          // make cache.batch immediately remove the optimistic layer after
          // running the updateCache function, triggering only one broadcast.
          //
          // However, the refetchQueries method accepts only true or false for its
          // optimistic option (not string). We interpret true to mean a temporary
          // optimistic layer should be created, to allow efficiently rolling back
          // the effect of the updateCache function, which involves passing a
          // string instead of true as the optimistic option to cache.batch, when
          // refetchQueries receives optimistic: true.
          //
          // In other words, we are deliberately not supporting the use case of
          // writing to an *existing* optimistic layer (using the refetchQueries
          // updateCache function), since that would potentially interfere with
          // other optimistic updates in progress. Instead, you can read/write
          // only the root layer by passing optimistic: false to refetchQueries,
          // or you can read/write a brand new optimistic layer that will be
          // automatically removed by passing optimistic: true.
          optimistic: optimistic && removeOptimistic || false,
          // The removeOptimistic option can also be provided by itself, even if
          // optimistic === false, to remove some previously-added optimistic
          // layer safely and efficiently, like we do in markMutationResult.
          //
          // If an explicit removeOptimistic string is provided with optimistic:
          // true, the removeOptimistic string will determine the ID of the
          // temporary optimistic layer, in case that ever matters.
          removeOptimistic,
          onWatchUpdated: function(watch, diff, lastDiff) {
            var oq = watch.watcher instanceof QueryInfo && watch.watcher.observableQuery;
            if (oq) {
              if (onQueryUpdated) {
                includedQueriesById.delete(oq.queryId);
                var result = onQueryUpdated(oq, diff, lastDiff);
                if (result === true) {
                  result = oq.refetch();
                }
                if (result !== false) {
                  results2.set(oq, result);
                }
                return result;
              }
              if (onQueryUpdated !== null) {
                includedQueriesById.set(oq.queryId, { oq, lastDiff, diff });
              }
            }
          }
        });
      }
      if (includedQueriesById.size) {
        includedQueriesById.forEach(function(_a2, queryId) {
          var oq = _a2.oq, lastDiff = _a2.lastDiff, diff = _a2.diff;
          var result;
          if (onQueryUpdated) {
            if (!diff) {
              var info = oq["queryInfo"];
              info.reset();
              diff = info.getDiff();
            }
            result = onQueryUpdated(oq, diff, lastDiff);
          }
          if (!onQueryUpdated || result === true) {
            result = oq.refetch();
          }
          if (result !== false) {
            results2.set(oq, result);
          }
          if (queryId.indexOf("legacyOneTimeQuery") >= 0) {
            _this.stopQueryNoBroadcast(queryId);
          }
        });
      }
      if (removeOptimistic) {
        this.cache.removeOptimistic(removeOptimistic);
      }
      return results2;
    };
    QueryManager2.prototype.maskOperation = function(options) {
      var _a, _b, _c;
      var document2 = options.document, data = options.data;
      if (globalThis.__DEV__ !== false) {
        var fetchPolicy = options.fetchPolicy, id2 = options.id;
        var operationType = (_a = getOperationDefinition(document2)) === null || _a === void 0 ? void 0 : _a.operation;
        var operationId = ((_b = operationType === null || operationType === void 0 ? void 0 : operationType[0]) !== null && _b !== void 0 ? _b : "o") + id2;
        if (this.dataMasking && fetchPolicy === "no-cache" && !isFullyUnmaskedOperation(document2) && !this.noCacheWarningsByQueryId.has(operationId)) {
          this.noCacheWarningsByQueryId.add(operationId);
          globalThis.__DEV__ !== false && invariant.warn(
            37,
            (_c = getOperationName(document2)) !== null && _c !== void 0 ? _c : "Unnamed ".concat(operationType !== null && operationType !== void 0 ? operationType : "operation")
          );
        }
      }
      return this.dataMasking ? maskOperation(data, document2, this.cache) : data;
    };
    QueryManager2.prototype.maskFragment = function(options) {
      var data = options.data, fragment = options.fragment, fragmentName = options.fragmentName;
      return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;
    };
    QueryManager2.prototype.fetchQueryByPolicy = function(queryInfo, _a, networkStatus) {
      var _this = this;
      var query = _a.query, variables = _a.variables, fetchPolicy = _a.fetchPolicy, refetchWritePolicy = _a.refetchWritePolicy, errorPolicy = _a.errorPolicy, returnPartialData = _a.returnPartialData, context = _a.context, notifyOnNetworkStatusChange = _a.notifyOnNetworkStatusChange;
      var oldNetworkStatus = queryInfo.networkStatus;
      queryInfo.init({
        document: query,
        variables,
        networkStatus
      });
      var readCache = function() {
        return queryInfo.getDiff();
      };
      var resultsFromCache = function(diff2, networkStatus2) {
        if (networkStatus2 === void 0) {
          networkStatus2 = queryInfo.networkStatus || NetworkStatus.loading;
        }
        var data = diff2.result;
        if (globalThis.__DEV__ !== false && !returnPartialData && !equal$1(data, {})) {
          logMissingFieldErrors(diff2.missing);
        }
        var fromData = function(data2) {
          return Observable.of(__assign({ data: data2, loading: isNetworkRequestInFlight(networkStatus2), networkStatus: networkStatus2 }, diff2.complete ? null : { partial: true }));
        };
        if (data && _this.getDocumentInfo(query).hasForcedResolvers) {
          return _this.localState.runResolvers({
            document: query,
            remoteResult: { data },
            context,
            variables,
            onlyRunForcedResolvers: true
          }).then(function(resolved) {
            return fromData(resolved.data || void 0);
          });
        }
        if (errorPolicy === "none" && networkStatus2 === NetworkStatus.refetch && Array.isArray(diff2.missing)) {
          return fromData(void 0);
        }
        return fromData(data);
      };
      var cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && refetchWritePolicy !== "merge" ? 1 : 2;
      var resultsFromLink = function() {
        return _this.getResultsFromLink(queryInfo, cacheWriteBehavior, {
          query,
          variables,
          context,
          fetchPolicy,
          errorPolicy
        });
      };
      var shouldNotify = notifyOnNetworkStatusChange && typeof oldNetworkStatus === "number" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus);
      switch (fetchPolicy) {
        default:
        case "cache-first": {
          var diff = readCache();
          if (diff.complete) {
            return {
              fromLink: false,
              sources: [resultsFromCache(diff, queryInfo.markReady())]
            };
          }
          if (returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-and-network": {
          var diff = readCache();
          if (diff.complete || returnPartialData || shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(diff), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        }
        case "cache-only":
          return {
            fromLink: false,
            sources: [resultsFromCache(readCache(), queryInfo.markReady())]
          };
        case "network-only":
          if (shouldNotify) {
            return {
              fromLink: true,
              sources: [resultsFromCache(readCache()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "no-cache":
          if (shouldNotify) {
            return {
              fromLink: true,
              // Note that queryInfo.getDiff() for no-cache queries does not call
              // cache.diff, but instead returns a { complete: false } stub result
              // when there is no queryInfo.diff already defined.
              sources: [resultsFromCache(queryInfo.getDiff()), resultsFromLink()]
            };
          }
          return { fromLink: true, sources: [resultsFromLink()] };
        case "standby":
          return { fromLink: false, sources: [] };
      }
    };
    QueryManager2.prototype.getQuery = function(queryId) {
      if (queryId && !this.queries.has(queryId)) {
        this.queries.set(queryId, new QueryInfo(this, queryId));
      }
      return this.queries.get(queryId);
    };
    QueryManager2.prototype.prepareContext = function(context) {
      if (context === void 0) {
        context = {};
      }
      var newContext = this.localState.prepareContext(context);
      return __assign(__assign(__assign({}, this.defaultContext), newContext), { clientAwareness: this.clientAwareness });
    };
    return QueryManager2;
  }()
);
var LocalState = (
  /** @class */
  function() {
    function LocalState2(_a) {
      var cache2 = _a.cache, client = _a.client, resolvers = _a.resolvers, fragmentMatcher = _a.fragmentMatcher;
      this.selectionsToResolveCache = /* @__PURE__ */ new WeakMap();
      this.cache = cache2;
      if (client) {
        this.client = client;
      }
      if (resolvers) {
        this.addResolvers(resolvers);
      }
      if (fragmentMatcher) {
        this.setFragmentMatcher(fragmentMatcher);
      }
    }
    LocalState2.prototype.addResolvers = function(resolvers) {
      var _this = this;
      this.resolvers = this.resolvers || {};
      if (Array.isArray(resolvers)) {
        resolvers.forEach(function(resolverGroup) {
          _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);
        });
      } else {
        this.resolvers = mergeDeep(this.resolvers, resolvers);
      }
    };
    LocalState2.prototype.setResolvers = function(resolvers) {
      this.resolvers = {};
      this.addResolvers(resolvers);
    };
    LocalState2.prototype.getResolvers = function() {
      return this.resolvers || {};
    };
    LocalState2.prototype.runResolvers = function(_a) {
      return __awaiter(this, arguments, void 0, function(_b) {
        var document2 = _b.document, remoteResult = _b.remoteResult, context = _b.context, variables = _b.variables, _c = _b.onlyRunForcedResolvers, onlyRunForcedResolvers = _c === void 0 ? false : _c;
        return __generator(this, function(_d) {
          if (document2) {
            return [2, this.resolveDocument(document2, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function(localResult) {
              return __assign(__assign({}, remoteResult), { data: localResult.result });
            })];
          }
          return [2, remoteResult];
        });
      });
    };
    LocalState2.prototype.setFragmentMatcher = function(fragmentMatcher) {
      this.fragmentMatcher = fragmentMatcher;
    };
    LocalState2.prototype.getFragmentMatcher = function() {
      return this.fragmentMatcher;
    };
    LocalState2.prototype.clientQuery = function(document2) {
      if (hasDirectives(["client"], document2)) {
        if (this.resolvers) {
          return document2;
        }
      }
      return null;
    };
    LocalState2.prototype.serverQuery = function(document2) {
      return removeClientSetsFromDocument(document2);
    };
    LocalState2.prototype.prepareContext = function(context) {
      var cache2 = this.cache;
      return __assign(__assign({}, context), {
        cache: cache2,
        // Getting an entry's cache key is useful for local state resolvers.
        getCacheKey: function(obj) {
          return cache2.identify(obj);
        }
      });
    };
    LocalState2.prototype.addExportedVariables = function(document_1) {
      return __awaiter(this, arguments, void 0, function(document2, variables, context) {
        if (variables === void 0) {
          variables = {};
        }
        if (context === void 0) {
          context = {};
        }
        return __generator(this, function(_a) {
          if (document2) {
            return [2, this.resolveDocument(document2, this.buildRootValueFromCache(document2, variables) || {}, this.prepareContext(context), variables).then(function(data) {
              return __assign(__assign({}, variables), data.exportedVariables);
            })];
          }
          return [2, __assign({}, variables)];
        });
      });
    };
    LocalState2.prototype.shouldForceResolvers = function(document2) {
      var forceResolvers = false;
      visit(document2, {
        Directive: {
          enter: function(node) {
            if (node.name.value === "client" && node.arguments) {
              forceResolvers = node.arguments.some(function(arg) {
                return arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true;
              });
              if (forceResolvers) {
                return BREAK;
              }
            }
          }
        }
      });
      return forceResolvers;
    };
    LocalState2.prototype.buildRootValueFromCache = function(document2, variables) {
      return this.cache.diff({
        query: buildQueryFromSelectionSet(document2),
        variables,
        returnPartialData: true,
        optimistic: false
      }).result;
    };
    LocalState2.prototype.resolveDocument = function(document_1, rootValue_1) {
      return __awaiter(this, arguments, void 0, function(document2, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {
        var mainDefinition, fragments, fragmentMap, selectionsToResolve, definitionOperation, defaultOperationType, _a, cache2, client, execContext, isClientFieldDescendant;
        if (context === void 0) {
          context = {};
        }
        if (variables === void 0) {
          variables = {};
        }
        if (fragmentMatcher === void 0) {
          fragmentMatcher = function() {
            return true;
          };
        }
        if (onlyRunForcedResolvers === void 0) {
          onlyRunForcedResolvers = false;
        }
        return __generator(this, function(_b) {
          mainDefinition = getMainDefinition(document2);
          fragments = getFragmentDefinitions(document2);
          fragmentMap = createFragmentMap(fragments);
          selectionsToResolve = this.collectSelectionsToResolve(mainDefinition, fragmentMap);
          definitionOperation = mainDefinition.operation;
          defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : "Query";
          _a = this, cache2 = _a.cache, client = _a.client;
          execContext = {
            fragmentMap,
            context: __assign(__assign({}, context), { cache: cache2, client }),
            variables,
            fragmentMatcher,
            defaultOperationType,
            exportedVariables: {},
            selectionsToResolve,
            onlyRunForcedResolvers
          };
          isClientFieldDescendant = false;
          return [2, this.resolveSelectionSet(mainDefinition.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(result) {
            return {
              result,
              exportedVariables: execContext.exportedVariables
            };
          })];
        });
      });
    };
    LocalState2.prototype.resolveSelectionSet = function(selectionSet, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var fragmentMap, context, variables, resultsToMerge, execute2;
        var _this = this;
        return __generator(this, function(_a) {
          fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;
          resultsToMerge = [rootValue];
          execute2 = function(selection) {
            return __awaiter(_this, void 0, void 0, function() {
              var fragment, typeCondition;
              return __generator(this, function(_a2) {
                if (!isClientFieldDescendant && !execContext.selectionsToResolve.has(selection)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (!shouldInclude(selection, variables)) {
                  return [
                    2
                    /*return*/
                  ];
                }
                if (isField(selection)) {
                  return [2, this.resolveField(selection, isClientFieldDescendant, rootValue, execContext).then(function(fieldResult) {
                    var _a3;
                    if (typeof fieldResult !== "undefined") {
                      resultsToMerge.push((_a3 = {}, _a3[resultKeyNameFromField(selection)] = fieldResult, _a3));
                    }
                  })];
                }
                if (isInlineFragment(selection)) {
                  fragment = selection;
                } else {
                  fragment = fragmentMap[selection.name.value];
                  invariant(fragment, 19, selection.name.value);
                }
                if (fragment && fragment.typeCondition) {
                  typeCondition = fragment.typeCondition.name.value;
                  if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {
                    return [2, this.resolveSelectionSet(fragment.selectionSet, isClientFieldDescendant, rootValue, execContext).then(function(fragmentResult) {
                      resultsToMerge.push(fragmentResult);
                    })];
                  }
                }
                return [
                  2
                  /*return*/
                ];
              });
            });
          };
          return [2, Promise.all(selectionSet.selections.map(execute2)).then(function() {
            return mergeDeepArray(resultsToMerge);
          })];
        });
      });
    };
    LocalState2.prototype.resolveField = function(field, isClientFieldDescendant, rootValue, execContext) {
      return __awaiter(this, void 0, void 0, function() {
        var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;
        var _this = this;
        return __generator(this, function(_a) {
          if (!rootValue) {
            return [2, null];
          }
          variables = execContext.variables;
          fieldName = field.name.value;
          aliasedFieldName = resultKeyNameFromField(field);
          aliasUsed = fieldName !== aliasedFieldName;
          defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];
          resultPromise = Promise.resolve(defaultResult);
          if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {
            resolverType = rootValue.__typename || execContext.defaultOperationType;
            resolverMap = this.resolvers && this.resolvers[resolverType];
            if (resolverMap) {
              resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];
              if (resolve) {
                resultPromise = Promise.resolve(
                  // In case the resolve function accesses reactive variables,
                  // set cacheSlot to the current cache instance.
                  cacheSlot.withValue(this.cache, resolve, [
                    rootValue,
                    argumentsObjectFromField(field, variables),
                    execContext.context,
                    { field, fragmentMap: execContext.fragmentMap }
                  ])
                );
              }
            }
          }
          return [2, resultPromise.then(function(result) {
            var _a2, _b;
            if (result === void 0) {
              result = defaultResult;
            }
            if (field.directives) {
              field.directives.forEach(function(directive) {
                if (directive.name.value === "export" && directive.arguments) {
                  directive.arguments.forEach(function(arg) {
                    if (arg.name.value === "as" && arg.value.kind === "StringValue") {
                      execContext.exportedVariables[arg.value.value] = result;
                    }
                  });
                }
              });
            }
            if (!field.selectionSet) {
              return result;
            }
            if (result == null) {
              return result;
            }
            var isClientField = (_b = (_a2 = field.directives) === null || _a2 === void 0 ? void 0 : _a2.some(function(d) {
              return d.name.value === "client";
            })) !== null && _b !== void 0 ? _b : false;
            if (Array.isArray(result)) {
              return _this.resolveSubSelectedArray(field, isClientFieldDescendant || isClientField, result, execContext);
            }
            if (field.selectionSet) {
              return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant || isClientField, result, execContext);
            }
          })];
        });
      });
    };
    LocalState2.prototype.resolveSubSelectedArray = function(field, isClientFieldDescendant, result, execContext) {
      var _this = this;
      return Promise.all(result.map(function(item) {
        if (item === null) {
          return null;
        }
        if (Array.isArray(item)) {
          return _this.resolveSubSelectedArray(field, isClientFieldDescendant, item, execContext);
        }
        if (field.selectionSet) {
          return _this.resolveSelectionSet(field.selectionSet, isClientFieldDescendant, item, execContext);
        }
      }));
    };
    LocalState2.prototype.collectSelectionsToResolve = function(mainDefinition, fragmentMap) {
      var isSingleASTNode = function(node) {
        return !Array.isArray(node);
      };
      var selectionsToResolveCache = this.selectionsToResolveCache;
      function collectByDefinition(definitionNode) {
        if (!selectionsToResolveCache.has(definitionNode)) {
          var matches_1 = /* @__PURE__ */ new Set();
          selectionsToResolveCache.set(definitionNode, matches_1);
          visit(definitionNode, {
            Directive: function(node, _2, __, ___, ancestors) {
              if (node.name.value === "client") {
                ancestors.forEach(function(node2) {
                  if (isSingleASTNode(node2) && isSelectionNode(node2)) {
                    matches_1.add(node2);
                  }
                });
              }
            },
            FragmentSpread: function(spread, _2, __, ___, ancestors) {
              var fragment = fragmentMap[spread.name.value];
              invariant(fragment, 20, spread.name.value);
              var fragmentSelections = collectByDefinition(fragment);
              if (fragmentSelections.size > 0) {
                ancestors.forEach(function(node) {
                  if (isSingleASTNode(node) && isSelectionNode(node)) {
                    matches_1.add(node);
                  }
                });
                matches_1.add(spread);
                fragmentSelections.forEach(function(selection) {
                  matches_1.add(selection);
                });
              }
            }
          });
        }
        return selectionsToResolveCache.get(definitionNode);
      }
      return collectByDefinition(mainDefinition);
    };
    return LocalState2;
  }()
);
var hasSuggestedDevtools = false;
var ApolloClient = (
  /** @class */
  function() {
    function ApolloClient2(options) {
      var _this = this;
      var _a;
      this.resetStoreCallbacks = [];
      this.clearStoreCallbacks = [];
      if (!options.cache) {
        throw newInvariantError(16);
      }
      var uri = options.uri, credentials = options.credentials, headers = options.headers, cache2 = options.cache, documentTransform = options.documentTransform, _b = options.ssrMode, ssrMode = _b === void 0 ? false : _b, _c = options.ssrForceFetchDelay, ssrForceFetchDelay = _c === void 0 ? 0 : _c, connectToDevTools = options.connectToDevTools, _d = options.queryDeduplication, queryDeduplication = _d === void 0 ? true : _d, defaultOptions2 = options.defaultOptions, defaultContext = options.defaultContext, _e = options.assumeImmutableResults, assumeImmutableResults = _e === void 0 ? cache2.assumeImmutableResults : _e, resolvers = options.resolvers, typeDefs = options.typeDefs, fragmentMatcher = options.fragmentMatcher, clientAwarenessName = options.name, clientAwarenessVersion = options.version, devtools = options.devtools, dataMasking = options.dataMasking;
      var link = options.link;
      if (!link) {
        link = uri ? new HttpLink({ uri, credentials, headers }) : ApolloLink.empty();
      }
      this.link = link;
      this.cache = cache2;
      this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;
      this.queryDeduplication = queryDeduplication;
      this.defaultOptions = defaultOptions2 || /* @__PURE__ */ Object.create(null);
      this.typeDefs = typeDefs;
      this.devtoolsConfig = __assign(__assign({}, devtools), { enabled: (_a = devtools === null || devtools === void 0 ? void 0 : devtools.enabled) !== null && _a !== void 0 ? _a : connectToDevTools });
      if (this.devtoolsConfig.enabled === void 0) {
        this.devtoolsConfig.enabled = globalThis.__DEV__ !== false;
      }
      if (ssrForceFetchDelay) {
        setTimeout(function() {
          return _this.disableNetworkFetches = false;
        }, ssrForceFetchDelay);
      }
      this.watchQuery = this.watchQuery.bind(this);
      this.query = this.query.bind(this);
      this.mutate = this.mutate.bind(this);
      this.watchFragment = this.watchFragment.bind(this);
      this.resetStore = this.resetStore.bind(this);
      this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);
      this.version = version$1;
      this.localState = new LocalState({
        cache: cache2,
        client: this,
        resolvers,
        fragmentMatcher
      });
      this.queryManager = new QueryManager({
        cache: this.cache,
        link: this.link,
        defaultOptions: this.defaultOptions,
        defaultContext,
        documentTransform,
        queryDeduplication,
        ssrMode,
        dataMasking: !!dataMasking,
        clientAwareness: {
          name: clientAwarenessName,
          version: clientAwarenessVersion
        },
        localState: this.localState,
        assumeImmutableResults,
        onBroadcast: this.devtoolsConfig.enabled ? function() {
          if (_this.devToolsHookCb) {
            _this.devToolsHookCb({
              action: {},
              state: {
                queries: _this.queryManager.getQueryStore(),
                mutations: _this.queryManager.mutationStore || {}
              },
              dataWithOptimisticResults: _this.cache.extract(true)
            });
          }
        } : void 0
      });
      if (this.devtoolsConfig.enabled)
        this.connectToDevTools();
    }
    ApolloClient2.prototype.connectToDevTools = function() {
      if (typeof window === "undefined") {
        return;
      }
      var windowWithDevTools = window;
      var devtoolsSymbol = Symbol.for("apollo.devtools");
      (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
      windowWithDevTools.__APOLLO_CLIENT__ = this;
      if (!hasSuggestedDevtools && globalThis.__DEV__ !== false) {
        hasSuggestedDevtools = true;
        if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
          setTimeout(function() {
            if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
              var nav = window.navigator;
              var ua = nav && nav.userAgent;
              var url = void 0;
              if (typeof ua === "string") {
                if (ua.indexOf("Chrome/") > -1) {
                  url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
                } else if (ua.indexOf("Firefox/") > -1) {
                  url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
                }
              }
              if (url) {
                globalThis.__DEV__ !== false && invariant.log("Download the Apollo DevTools for a better development experience: %s", url);
              }
            }
          }, 1e4);
        }
      }
    };
    Object.defineProperty(ApolloClient2.prototype, "documentTransform", {
      /**
       * The `DocumentTransform` used to modify GraphQL documents before a request
       * is made. If a custom `DocumentTransform` is not provided, this will be the
       * default document transform.
       */
      get: function() {
        return this.queryManager.documentTransform;
      },
      enumerable: false,
      configurable: true
    });
    ApolloClient2.prototype.stop = function() {
      this.queryManager.stop();
    };
    ApolloClient2.prototype.watchQuery = function(options) {
      if (this.defaultOptions.watchQuery) {
        options = mergeOptions(this.defaultOptions.watchQuery, options);
      }
      if (this.disableNetworkFetches && (options.fetchPolicy === "network-only" || options.fetchPolicy === "cache-and-network")) {
        options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.watchQuery(options);
    };
    ApolloClient2.prototype.query = function(options) {
      if (this.defaultOptions.query) {
        options = mergeOptions(this.defaultOptions.query, options);
      }
      invariant(options.fetchPolicy !== "cache-and-network", 17);
      if (this.disableNetworkFetches && options.fetchPolicy === "network-only") {
        options = __assign(__assign({}, options), { fetchPolicy: "cache-first" });
      }
      return this.queryManager.query(options);
    };
    ApolloClient2.prototype.mutate = function(options) {
      if (this.defaultOptions.mutate) {
        options = mergeOptions(this.defaultOptions.mutate, options);
      }
      return this.queryManager.mutate(options);
    };
    ApolloClient2.prototype.subscribe = function(options) {
      var _this = this;
      var id2 = this.queryManager.generateQueryId();
      return this.queryManager.startGraphQLSubscription(options).map(function(result) {
        return __assign(__assign({}, result), { data: _this.queryManager.maskOperation({
          document: options.query,
          data: result.data,
          fetchPolicy: options.fetchPolicy,
          id: id2
        }) });
      });
    };
    ApolloClient2.prototype.readQuery = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readQuery(options, optimistic);
    };
    ApolloClient2.prototype.watchFragment = function(options) {
      var _a;
      return this.cache.watchFragment(__assign(__assign({}, options), (_a = {}, _a[Symbol.for("apollo.dataMasking")] = this.queryManager.dataMasking, _a)));
    };
    ApolloClient2.prototype.readFragment = function(options, optimistic) {
      if (optimistic === void 0) {
        optimistic = false;
      }
      return this.cache.readFragment(options, optimistic);
    };
    ApolloClient2.prototype.writeQuery = function(options) {
      var ref = this.cache.writeQuery(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.writeFragment = function(options) {
      var ref = this.cache.writeFragment(options);
      if (options.broadcast !== false) {
        this.queryManager.broadcastQueries();
      }
      return ref;
    };
    ApolloClient2.prototype.__actionHookForDevTools = function(cb) {
      this.devToolsHookCb = cb;
    };
    ApolloClient2.prototype.__requestRaw = function(payload) {
      return execute(this.link, payload);
    };
    ApolloClient2.prototype.resetStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: false
        });
      }).then(function() {
        return Promise.all(_this.resetStoreCallbacks.map(function(fn) {
          return fn();
        }));
      }).then(function() {
        return _this.reFetchObservableQueries();
      });
    };
    ApolloClient2.prototype.clearStore = function() {
      var _this = this;
      return Promise.resolve().then(function() {
        return _this.queryManager.clearStore({
          discardWatches: true
        });
      }).then(function() {
        return Promise.all(_this.clearStoreCallbacks.map(function(fn) {
          return fn();
        }));
      });
    };
    ApolloClient2.prototype.onResetStore = function(cb) {
      var _this = this;
      this.resetStoreCallbacks.push(cb);
      return function() {
        _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.onClearStore = function(cb) {
      var _this = this;
      this.clearStoreCallbacks.push(cb);
      return function() {
        _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function(c) {
          return c !== cb;
        });
      };
    };
    ApolloClient2.prototype.reFetchObservableQueries = function(includeStandby) {
      return this.queryManager.reFetchObservableQueries(includeStandby);
    };
    ApolloClient2.prototype.refetchQueries = function(options) {
      var map = this.queryManager.refetchQueries(options);
      var queries = [];
      var results2 = [];
      map.forEach(function(result2, obsQuery) {
        queries.push(obsQuery);
        results2.push(result2);
      });
      var result = Promise.all(results2);
      result.queries = queries;
      result.results = results2;
      result.catch(function(error) {
        globalThis.__DEV__ !== false && invariant.debug(18, error);
      });
      return result;
    };
    ApolloClient2.prototype.getObservableQueries = function(include) {
      if (include === void 0) {
        include = "active";
      }
      return this.queryManager.getObservableQueries(include);
    };
    ApolloClient2.prototype.extract = function(optimistic) {
      return this.cache.extract(optimistic);
    };
    ApolloClient2.prototype.restore = function(serializedState) {
      return this.cache.restore(serializedState);
    };
    ApolloClient2.prototype.addResolvers = function(resolvers) {
      this.localState.addResolvers(resolvers);
    };
    ApolloClient2.prototype.setResolvers = function(resolvers) {
      this.localState.setResolvers(resolvers);
    };
    ApolloClient2.prototype.getResolvers = function() {
      return this.localState.getResolvers();
    };
    ApolloClient2.prototype.setLocalStateFragmentMatcher = function(fragmentMatcher) {
      this.localState.setFragmentMatcher(fragmentMatcher);
    };
    ApolloClient2.prototype.setLink = function(newLink) {
      this.link = this.queryManager.link = newLink;
    };
    Object.defineProperty(ApolloClient2.prototype, "defaultContext", {
      get: function() {
        return this.queryManager.defaultContext;
      },
      enumerable: false,
      configurable: true
    });
    return ApolloClient2;
  }()
);
if (globalThis.__DEV__ !== false) {
  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
}
var contextKey = canUseSymbol ? Symbol.for("__APOLLO_CONTEXT__") : "__APOLLO_CONTEXT__";
function getApolloContext() {
  invariant("createContext" in React, 54);
  var context = React.createContext[contextKey];
  if (!context) {
    Object.defineProperty(React.createContext, contextKey, {
      value: context = React.createContext({}),
      enumerable: false,
      writable: false,
      configurable: true
    });
    context.displayName = "ApolloContext";
  }
  return context;
}
var ApolloProvider = function(_a) {
  var client = _a.client, children = _a.children;
  var ApolloContext = getApolloContext();
  var parentContext = React.useContext(ApolloContext);
  var context = React.useMemo(function() {
    return __assign(__assign({}, parentContext), { client: client || parentContext.client });
  }, [parentContext, client]);
  invariant(context.client, 55);
  return React.createElement(ApolloContext.Provider, { value: context }, children);
};
function useApolloClient(override) {
  var context = React.useContext(getApolloContext());
  var client = override || context.client;
  invariant(!!client, 58);
  return client;
}
var didWarnUncachedGetSnapshot = false;
var uSESKey = "useSyncExternalStore";
var realHook = React[uSESKey];
var useSyncExternalStore = realHook || function(subscribe, getSnapshot, getServerSnapshot) {
  var value = getSnapshot();
  if (
    // DEVIATION: Using __DEV__
    globalThis.__DEV__ !== false && !didWarnUncachedGetSnapshot && // DEVIATION: Not using Object.is because we know our snapshots will never
    // be exotic primitive values like NaN, which is !== itself.
    value !== getSnapshot()
  ) {
    didWarnUncachedGetSnapshot = true;
    globalThis.__DEV__ !== false && invariant.error(68);
  }
  var _a = React.useState({
    inst: { value, getSnapshot }
  }), inst = _a[0].inst, forceUpdate = _a[1];
  if (canUseLayoutEffect) {
    React.useLayoutEffect(function() {
      Object.assign(inst, { value, getSnapshot });
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    }, [subscribe, value, getSnapshot]);
  } else {
    Object.assign(inst, { value, getSnapshot });
  }
  React.useEffect(function() {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({ inst });
    }
    return subscribe(function handleStoreChange() {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({ inst });
      }
    });
  }, [subscribe]);
  return value;
};
function checkIfSnapshotChanged(_a) {
  var value = _a.value, getSnapshot = _a.getSnapshot;
  try {
    return value !== getSnapshot();
  } catch (_b) {
    return true;
  }
}
var DocumentType;
(function(DocumentType2) {
  DocumentType2[DocumentType2["Query"] = 0] = "Query";
  DocumentType2[DocumentType2["Mutation"] = 1] = "Mutation";
  DocumentType2[DocumentType2["Subscription"] = 2] = "Subscription";
})(DocumentType || (DocumentType = {}));
var cache;
function operationName(type2) {
  var name2;
  switch (type2) {
    case DocumentType.Query:
      name2 = "Query";
      break;
    case DocumentType.Mutation:
      name2 = "Mutation";
      break;
    case DocumentType.Subscription:
      name2 = "Subscription";
      break;
  }
  return name2;
}
function parser(document2) {
  if (!cache) {
    cache = new AutoCleanedWeakCache(
      cacheSizes.parser || 1e3
      /* defaultCacheSizes.parser */
    );
  }
  var cached = cache.get(document2);
  if (cached)
    return cached;
  var variables, type2, name2;
  invariant(!!document2 && !!document2.kind, 70, document2);
  var fragments = [];
  var queries = [];
  var mutations = [];
  var subscriptions = [];
  for (var _i = 0, _a = document2.definitions; _i < _a.length; _i++) {
    var x2 = _a[_i];
    if (x2.kind === "FragmentDefinition") {
      fragments.push(x2);
      continue;
    }
    if (x2.kind === "OperationDefinition") {
      switch (x2.operation) {
        case "query":
          queries.push(x2);
          break;
        case "mutation":
          mutations.push(x2);
          break;
        case "subscription":
          subscriptions.push(x2);
          break;
      }
    }
  }
  invariant(!fragments.length || queries.length || mutations.length || subscriptions.length, 71);
  invariant(
    queries.length + mutations.length + subscriptions.length <= 1,
    72,
    document2,
    queries.length,
    subscriptions.length,
    mutations.length
  );
  type2 = queries.length ? DocumentType.Query : DocumentType.Mutation;
  if (!queries.length && !mutations.length)
    type2 = DocumentType.Subscription;
  var definitions = queries.length ? queries : mutations.length ? mutations : subscriptions;
  invariant(definitions.length === 1, 73, document2, definitions.length);
  var definition = definitions[0];
  variables = definition.variableDefinitions || [];
  if (definition.name && definition.name.kind === "Name") {
    name2 = definition.name.value;
  } else {
    name2 = "data";
  }
  var payload = { name: name2, type: type2, variables };
  cache.set(document2, payload);
  return payload;
}
parser.resetCache = function() {
  cache = void 0;
};
if (globalThis.__DEV__ !== false) {
  registerGlobalCache("parser", function() {
    return cache ? cache.size : 0;
  });
}
function verifyDocumentType(document2, type2) {
  var operation = parser(document2);
  var requiredOperationName = operationName(type2);
  var usedOperationName = operationName(operation.type);
  invariant(
    operation.type === type2,
    74,
    requiredOperationName,
    requiredOperationName,
    usedOperationName
  );
}
var useIsomorphicLayoutEffect$1 = canUseDOM ? React.useLayoutEffect : React.useEffect;
var wrapperSymbol = Symbol.for("apollo.hook.wrappers");
function wrapHook(hookName, useHook, clientOrObsQuery) {
  var queryManager = clientOrObsQuery["queryManager"];
  var wrappers = queryManager && queryManager[wrapperSymbol];
  var wrapper = wrappers && wrappers[hookName];
  return wrapper ? wrapper(useHook) : useHook;
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function noop$2() {
}
var lastWatchOptions = Symbol();
function useQuery(query, options) {
  if (options === void 0) {
    options = /* @__PURE__ */ Object.create(null);
  }
  return wrapHook("useQuery", _useQuery, useApolloClient(options && options.client))(query, options);
}
function _useQuery(query, options) {
  var _a = useQueryInternals(query, options), result = _a.result, obsQueryFields = _a.obsQueryFields;
  return React.useMemo(function() {
    return __assign(__assign({}, result), obsQueryFields);
  }, [result, obsQueryFields]);
}
function useInternalState(client, query, options, renderPromises, makeWatchQueryOptions) {
  function createInternalState(previous) {
    var _a2;
    verifyDocumentType(query, DocumentType.Query);
    var internalState2 = {
      client,
      query,
      observable: (
        // See if there is an existing observable that was used to fetch the same
        // data and if so, use it instead since it will contain the proper queryId
        // to fetch the result set. This is used during SSR.
        renderPromises && renderPromises.getSSRObservable(makeWatchQueryOptions()) || client.watchQuery(getObsQueryOptions(void 0, client, options, makeWatchQueryOptions()))
      ),
      resultData: {
        // Reuse previousData from previous InternalState (if any) to provide
        // continuity of previousData even if/when the query or client changes.
        previousData: (_a2 = previous === null || previous === void 0 ? void 0 : previous.resultData.current) === null || _a2 === void 0 ? void 0 : _a2.data
      }
    };
    return internalState2;
  }
  var _a = React.useState(createInternalState), internalState = _a[0], updateInternalState = _a[1];
  function onQueryExecuted(watchQueryOptions) {
    var _a2;
    var _b;
    Object.assign(internalState.observable, (_a2 = {}, _a2[lastWatchOptions] = watchQueryOptions, _a2));
    var resultData = internalState.resultData;
    updateInternalState(__assign(__assign({}, internalState), {
      // might be a different query
      query: watchQueryOptions.query,
      resultData: Object.assign(resultData, {
        // We need to modify the previous `resultData` object as we rely on the
        // object reference in other places
        previousData: ((_b = resultData.current) === null || _b === void 0 ? void 0 : _b.data) || resultData.previousData,
        current: void 0
      })
    }));
  }
  if (client !== internalState.client || query !== internalState.query) {
    var newInternalState = createInternalState(internalState);
    updateInternalState(newInternalState);
    return [newInternalState, onQueryExecuted];
  }
  return [internalState, onQueryExecuted];
}
function useQueryInternals(query, options) {
  var client = useApolloClient(options.client);
  var renderPromises = React.useContext(getApolloContext()).renderPromises;
  var isSyncSSR = !!renderPromises;
  var disableNetworkFetches = client.disableNetworkFetches;
  var ssrAllowed = options.ssr !== false && !options.skip;
  var partialRefetch = options.partialRefetch;
  var makeWatchQueryOptions = createMakeWatchQueryOptions(client, query, options, isSyncSSR);
  var _a = useInternalState(client, query, options, renderPromises, makeWatchQueryOptions), _b = _a[0], observable = _b.observable, resultData = _b.resultData, onQueryExecuted = _a[1];
  var watchQueryOptions = makeWatchQueryOptions(observable);
  useResubscribeIfNecessary(
    resultData,
    // might get mutated during render
    observable,
    // might get mutated during render
    client,
    options,
    watchQueryOptions
  );
  var obsQueryFields = React.useMemo(function() {
    return bindObservableMethods(observable);
  }, [observable]);
  useRegisterSSRObservable(observable, renderPromises, ssrAllowed);
  var result = useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, {
    onCompleted: options.onCompleted || noop$2,
    onError: options.onError || noop$2
  });
  return {
    result,
    obsQueryFields,
    observable,
    resultData,
    client,
    onQueryExecuted
  };
}
function useObservableSubscriptionResult(resultData, observable, client, options, watchQueryOptions, disableNetworkFetches, partialRefetch, isSyncSSR, callbacks) {
  var callbackRef = React.useRef(callbacks);
  React.useEffect(function() {
    callbackRef.current = callbacks;
  });
  var resultOverride = (isSyncSSR || disableNetworkFetches) && options.ssr === false && !options.skip ? (
    // If SSR has been explicitly disabled, and this function has been called
    // on the server side, return the default loading state.
    ssrDisabledResult
  ) : options.skip || watchQueryOptions.fetchPolicy === "standby" ? (
    // When skipping a query (ie. we're not querying for data but still want to
    // render children), make sure the `data` is cleared out and `loading` is
    // set to `false` (since we aren't loading anything).
    //
    // NOTE: We no longer think this is the correct behavior. Skipping should
    // not automatically set `data` to `undefined`, but instead leave the
    // previous data in place. In other words, skipping should not mandate that
    // previously received data is all of a sudden removed. Unfortunately,
    // changing this is breaking, so we'll have to wait until Apollo Client 4.0
    // to address this.
    skipStandbyResult
  ) : void 0;
  var previousData = resultData.previousData;
  var currentResultOverride = React.useMemo(function() {
    return resultOverride && toQueryResult(resultOverride, previousData, observable, client);
  }, [client, observable, resultOverride, previousData]);
  return useSyncExternalStore(React.useCallback(function(handleStoreChange) {
    if (isSyncSSR) {
      return function() {
      };
    }
    var onNext = function() {
      var previousResult = resultData.current;
      var result = observable.getCurrentResult();
      if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal$1(previousResult.data, result.data)) {
        return;
      }
      setResult(result, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
    };
    var onError = function(error) {
      subscription.current.unsubscribe();
      subscription.current = observable.resubscribeAfterError(onNext, onError);
      if (!hasOwnProperty.call(error, "graphQLErrors")) {
        throw error;
      }
      var previousResult = resultData.current;
      if (!previousResult || previousResult && previousResult.loading || !equal$1(error, previousResult.error)) {
        setResult({
          data: previousResult && previousResult.data,
          error,
          loading: false,
          networkStatus: NetworkStatus.error
        }, resultData, observable, client, partialRefetch, handleStoreChange, callbackRef.current);
      }
    };
    var subscription = { current: observable.subscribe(onNext, onError) };
    return function() {
      setTimeout(function() {
        return subscription.current.unsubscribe();
      });
    };
  }, [
    disableNetworkFetches,
    isSyncSSR,
    observable,
    resultData,
    partialRefetch,
    client
  ]), function() {
    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
  }, function() {
    return currentResultOverride || getCurrentResult(resultData, observable, callbackRef.current, partialRefetch, client);
  });
}
function useRegisterSSRObservable(observable, renderPromises, ssrAllowed) {
  if (renderPromises && ssrAllowed) {
    renderPromises.registerSSRObservable(observable);
    if (observable.getCurrentResult().loading) {
      renderPromises.addObservableQueryPromise(observable);
    }
  }
}
function useResubscribeIfNecessary(resultData, observable, client, options, watchQueryOptions) {
  var _a;
  if (observable[lastWatchOptions] && !equal$1(observable[lastWatchOptions], watchQueryOptions)) {
    observable.reobserve(getObsQueryOptions(observable, client, options, watchQueryOptions));
    resultData.previousData = ((_a = resultData.current) === null || _a === void 0 ? void 0 : _a.data) || resultData.previousData;
    resultData.current = void 0;
  }
  observable[lastWatchOptions] = watchQueryOptions;
}
function createMakeWatchQueryOptions(client, query, _a, isSyncSSR) {
  if (_a === void 0) {
    _a = {};
  }
  var skip = _a.skip;
  _a.ssr;
  _a.onCompleted;
  _a.onError;
  var defaultOptions2 = _a.defaultOptions, otherOptions = __rest(_a, ["skip", "ssr", "onCompleted", "onError", "defaultOptions"]);
  return function(observable) {
    var watchQueryOptions = Object.assign(otherOptions, { query });
    if (isSyncSSR && (watchQueryOptions.fetchPolicy === "network-only" || watchQueryOptions.fetchPolicy === "cache-and-network")) {
      watchQueryOptions.fetchPolicy = "cache-first";
    }
    if (!watchQueryOptions.variables) {
      watchQueryOptions.variables = {};
    }
    if (skip) {
      watchQueryOptions.initialFetchPolicy = watchQueryOptions.initialFetchPolicy || watchQueryOptions.fetchPolicy || getDefaultFetchPolicy(defaultOptions2, client.defaultOptions);
      watchQueryOptions.fetchPolicy = "standby";
    } else if (!watchQueryOptions.fetchPolicy) {
      watchQueryOptions.fetchPolicy = (observable === null || observable === void 0 ? void 0 : observable.options.initialFetchPolicy) || getDefaultFetchPolicy(defaultOptions2, client.defaultOptions);
    }
    return watchQueryOptions;
  };
}
function getObsQueryOptions(observable, client, queryHookOptions, watchQueryOptions) {
  var toMerge = [];
  var globalDefaults = client.defaultOptions.watchQuery;
  if (globalDefaults)
    toMerge.push(globalDefaults);
  if (queryHookOptions.defaultOptions) {
    toMerge.push(queryHookOptions.defaultOptions);
  }
  toMerge.push(compact(observable && observable.options, watchQueryOptions));
  return toMerge.reduce(mergeOptions);
}
function setResult(nextResult, resultData, observable, client, partialRefetch, forceUpdate, callbacks) {
  var previousResult = resultData.current;
  if (previousResult && previousResult.data) {
    resultData.previousData = previousResult.data;
  }
  if (!nextResult.error && isNonEmptyArray(nextResult.errors)) {
    nextResult.error = new ApolloError({ graphQLErrors: nextResult.errors });
  }
  resultData.current = toQueryResult(unsafeHandlePartialRefetch(nextResult, observable, partialRefetch), resultData.previousData, observable, client);
  forceUpdate();
  handleErrorOrCompleted(nextResult, previousResult === null || previousResult === void 0 ? void 0 : previousResult.networkStatus, callbacks);
}
function handleErrorOrCompleted(result, previousNetworkStatus, callbacks) {
  if (!result.loading) {
    var error_1 = toApolloError(result);
    Promise.resolve().then(function() {
      if (error_1) {
        callbacks.onError(error_1);
      } else if (result.data && previousNetworkStatus !== result.networkStatus && result.networkStatus === NetworkStatus.ready) {
        callbacks.onCompleted(result.data);
      }
    }).catch(function(error) {
      globalThis.__DEV__ !== false && invariant.warn(error);
    });
  }
}
function getCurrentResult(resultData, observable, callbacks, partialRefetch, client) {
  if (!resultData.current) {
    setResult(observable.getCurrentResult(), resultData, observable, client, partialRefetch, function() {
    }, callbacks);
  }
  return resultData.current;
}
function getDefaultFetchPolicy(queryHookDefaultOptions, clientDefaultOptions) {
  var _a;
  return (queryHookDefaultOptions === null || queryHookDefaultOptions === void 0 ? void 0 : queryHookDefaultOptions.fetchPolicy) || ((_a = clientDefaultOptions === null || clientDefaultOptions === void 0 ? void 0 : clientDefaultOptions.watchQuery) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || "cache-first";
}
function toApolloError(result) {
  return isNonEmptyArray(result.errors) ? new ApolloError({ graphQLErrors: result.errors }) : result.error;
}
function toQueryResult(result, previousData, observable, client) {
  var data = result.data;
  result.partial;
  var resultWithoutPartial = __rest(result, ["data", "partial"]);
  var queryResult = __assign(__assign({ data }, resultWithoutPartial), { client, observable, variables: observable.variables, called: result !== ssrDisabledResult && result !== skipStandbyResult, previousData });
  return queryResult;
}
function unsafeHandlePartialRefetch(result, observable, partialRefetch) {
  if (result.partial && partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && observable.options.fetchPolicy !== "cache-only") {
    observable.refetch();
    return __assign(__assign({}, result), { loading: true, networkStatus: NetworkStatus.refetch });
  }
  return result;
}
var ssrDisabledResult = maybeDeepFreeze({
  loading: true,
  data: void 0,
  error: void 0,
  networkStatus: NetworkStatus.loading
});
var skipStandbyResult = maybeDeepFreeze({
  loading: false,
  data: void 0,
  error: void 0,
  networkStatus: NetworkStatus.ready
});
function bindObservableMethods(observable) {
  return {
    refetch: observable.refetch.bind(observable),
    reobserve: observable.reobserve.bind(observable),
    fetchMore: observable.fetchMore.bind(observable),
    updateQuery: observable.updateQuery.bind(observable),
    startPolling: observable.startPolling.bind(observable),
    stopPolling: observable.stopPolling.bind(observable),
    subscribeToMore: observable.subscribeToMore.bind(observable)
  };
}
var EAGER_METHODS = [
  "refetch",
  "reobserve",
  "fetchMore",
  "updateQuery",
  "startPolling",
  "stopPolling",
  "subscribeToMore"
];
function useLazyQuery(query, options) {
  var _a;
  var execOptionsRef = React.useRef(void 0);
  var optionsRef = React.useRef(void 0);
  var queryRef = React.useRef(void 0);
  var merged = mergeOptions(options, execOptionsRef.current || {});
  var document2 = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;
  optionsRef.current = options;
  queryRef.current = document2;
  var queryHookOptions = __assign(__assign({}, merged), { skip: !execOptionsRef.current });
  var _b = useQueryInternals(document2, queryHookOptions), obsQueryFields = _b.obsQueryFields, useQueryResult = _b.result, client = _b.client, resultData = _b.resultData, observable = _b.observable, onQueryExecuted = _b.onQueryExecuted;
  var initialFetchPolicy = observable.options.initialFetchPolicy || getDefaultFetchPolicy(queryHookOptions.defaultOptions, client.defaultOptions);
  var forceUpdateState = React.useReducer(function(tick) {
    return tick + 1;
  }, 0)[1];
  var eagerMethods = React.useMemo(function() {
    var eagerMethods2 = {};
    var _loop_1 = function(key2) {
      var method = obsQueryFields[key2];
      eagerMethods2[key2] = function() {
        if (!execOptionsRef.current) {
          execOptionsRef.current = /* @__PURE__ */ Object.create(null);
          forceUpdateState();
        }
        return method.apply(this, arguments);
      };
    };
    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {
      var key = EAGER_METHODS_1[_i];
      _loop_1(key);
    }
    return eagerMethods2;
  }, [forceUpdateState, obsQueryFields]);
  var called = !!execOptionsRef.current;
  var result = React.useMemo(function() {
    return __assign(__assign(__assign({}, useQueryResult), eagerMethods), { called });
  }, [useQueryResult, eagerMethods, called]);
  var execute2 = React.useCallback(function(executeOptions) {
    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), { fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy }) : {
      fetchPolicy: initialFetchPolicy
    };
    var options2 = mergeOptions(optionsRef.current, __assign({ query: queryRef.current }, execOptionsRef.current));
    var promise = executeQuery(resultData, observable, client, document2, __assign(__assign({}, options2), { skip: false }), onQueryExecuted).then(function(queryResult) {
      return Object.assign(queryResult, eagerMethods);
    });
    promise.catch(function() {
    });
    return promise;
  }, [
    client,
    document2,
    eagerMethods,
    initialFetchPolicy,
    observable,
    resultData,
    onQueryExecuted
  ]);
  var executeRef = React.useRef(execute2);
  useIsomorphicLayoutEffect$1(function() {
    executeRef.current = execute2;
  });
  var stableExecute = React.useCallback(function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return executeRef.current.apply(executeRef, args);
  }, []);
  return [stableExecute, result];
}
function executeQuery(resultData, observable, client, currentQuery, options, onQueryExecuted) {
  var query = options.query || currentQuery;
  var watchQueryOptions = createMakeWatchQueryOptions(client, query, options, false)(observable);
  var concast = observable.reobserveAsConcast(getObsQueryOptions(observable, client, options, watchQueryOptions));
  onQueryExecuted(watchQueryOptions);
  return new Promise(function(resolve) {
    var result;
    concast.subscribe({
      next: function(value) {
        result = value;
      },
      error: function() {
        resolve(toQueryResult(observable.getCurrentResult(), resultData.previousData, observable, client));
      },
      complete: function() {
        resolve(toQueryResult(observable["maskResult"](result), resultData.previousData, observable, client));
      }
    });
  });
}
function useMutation(mutation, options) {
  var client = useApolloClient(options === null || options === void 0 ? void 0 : options.client);
  verifyDocumentType(mutation, DocumentType.Mutation);
  var _a = React.useState({
    called: false,
    loading: false,
    client
  }), result = _a[0], setResult2 = _a[1];
  var ref = React.useRef({
    result,
    mutationId: 0,
    isMounted: true,
    client,
    mutation,
    options
  });
  useIsomorphicLayoutEffect$1(function() {
    Object.assign(ref.current, { client, options, mutation });
  });
  var execute2 = React.useCallback(function(executeOptions) {
    if (executeOptions === void 0) {
      executeOptions = {};
    }
    var _a2 = ref.current, options2 = _a2.options, mutation2 = _a2.mutation;
    var baseOptions = __assign(__assign({}, options2), { mutation: mutation2 });
    var client2 = executeOptions.client || ref.current.client;
    if (!ref.current.result.loading && !baseOptions.ignoreResults && ref.current.isMounted) {
      setResult2(ref.current.result = {
        loading: true,
        error: void 0,
        data: void 0,
        called: true,
        client: client2
      });
    }
    var mutationId = ++ref.current.mutationId;
    var clientOptions = mergeOptions(baseOptions, executeOptions);
    return client2.mutate(clientOptions).then(function(response) {
      var _a3, _b;
      var data = response.data, errors = response.errors;
      var error = errors && errors.length > 0 ? new ApolloError({ graphQLErrors: errors }) : void 0;
      var onError = executeOptions.onError || ((_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.onError);
      if (error && onError) {
        onError(error, clientOptions);
      }
      if (mutationId === ref.current.mutationId && !clientOptions.ignoreResults) {
        var result_1 = {
          called: true,
          loading: false,
          data,
          error,
          client: client2
        };
        if (ref.current.isMounted && !equal$1(ref.current.result, result_1)) {
          setResult2(ref.current.result = result_1);
        }
      }
      var onCompleted = executeOptions.onCompleted || ((_b = ref.current.options) === null || _b === void 0 ? void 0 : _b.onCompleted);
      if (!error) {
        onCompleted === null || onCompleted === void 0 ? void 0 : onCompleted(response.data, clientOptions);
      }
      return response;
    }).catch(function(error) {
      var _a3;
      if (mutationId === ref.current.mutationId && ref.current.isMounted) {
        var result_2 = {
          loading: false,
          error,
          data: void 0,
          called: true,
          client: client2
        };
        if (!equal$1(ref.current.result, result_2)) {
          setResult2(ref.current.result = result_2);
        }
      }
      var onError = executeOptions.onError || ((_a3 = ref.current.options) === null || _a3 === void 0 ? void 0 : _a3.onError);
      if (onError) {
        onError(error, clientOptions);
        return { data: void 0, errors: error };
      }
      throw error;
    });
  }, []);
  var reset = React.useCallback(function() {
    if (ref.current.isMounted) {
      var result_3 = {
        called: false,
        loading: false,
        client: ref.current.client
      };
      Object.assign(ref.current, { mutationId: 0, result: result_3 });
      setResult2(result_3);
    }
  }, []);
  React.useEffect(function() {
    var current = ref.current;
    current.isMounted = true;
    return function() {
      current.isMounted = false;
    };
  }, []);
  return [execute2, __assign({ reset }, result)];
}
function useCallbackRef(callback, deps = []) {
  const callbackRef = useRef(callback);
  useEffect(() => {
    callbackRef.current = callback;
  });
  return useCallback((...args) => {
    var _a;
    return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
  }, deps);
}
function useEventListener(target, event, handler, options) {
  const listener = useCallbackRef(handler);
  useEffect(() => {
    const node = typeof target === "function" ? target() : target ?? document;
    if (!handler || !node)
      return;
    node.addEventListener(event, listener, options);
    return () => {
      node.removeEventListener(event, listener, options);
    };
  }, [event, target, options, listener, handler]);
  return () => {
    const node = typeof target === "function" ? target() : target ?? document;
    node == null ? void 0 : node.removeEventListener(event, listener, options);
  };
}
function useAnimationState(props) {
  const { isOpen, ref } = props;
  const [mounted, setMounted] = useState(isOpen);
  const [once, setOnce] = useState(false);
  useEffect(() => {
    if (!once) {
      setMounted(isOpen);
      setOnce(true);
    }
  }, [isOpen, once, mounted]);
  useEventListener(
    () => ref.current,
    "animationend",
    () => {
      setMounted(isOpen);
    }
  );
  const hidden = isOpen ? false : !mounted;
  return {
    present: !hidden,
    onComplete() {
      var _a;
      const win = getOwnerWindow(ref.current);
      const evt = new win.CustomEvent("animationend", { bubbles: true });
      (_a = ref.current) == null ? void 0 : _a.dispatchEvent(evt);
    }
  };
}
function useClipboard(value, optionsOrTimeout = {}) {
  const [hasCopied, setHasCopied] = useState(false);
  const [valueState, setValueState] = useState(value);
  useEffect(() => setValueState(value), [value]);
  const { timeout = 1500, ...copyOptions } = typeof optionsOrTimeout === "number" ? { timeout: optionsOrTimeout } : optionsOrTimeout;
  const onCopy = useCallback(
    (valueToCopy) => {
      const value2 = typeof valueToCopy === "string" ? valueToCopy : valueState;
      if ("clipboard" in navigator) {
        navigator.clipboard.writeText(value2).then(() => setHasCopied(true)).catch(() => setHasCopied(copy(value2, copyOptions)));
      } else {
        setHasCopied(copy(value2, copyOptions));
      }
    },
    [valueState, copyOptions]
  );
  useEffect(() => {
    let timeoutId = null;
    if (hasCopied) {
      timeoutId = window.setTimeout(() => {
        setHasCopied(false);
      }, timeout);
    }
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [timeout, hasCopied]);
  return {
    value: valueState,
    setValue: setValueState,
    onCopy,
    hasCopied
  };
}
function useControllableState(props) {
  const {
    value: valueProp,
    defaultValue,
    onChange,
    shouldUpdate = (prev, next2) => prev !== next2
  } = props;
  const onChangeProp = useCallbackRef(onChange);
  const shouldUpdateProp = useCallbackRef(shouldUpdate);
  const [uncontrolledState, setUncontrolledState] = useState(defaultValue);
  const controlled = valueProp !== void 0;
  const value = controlled ? valueProp : uncontrolledState;
  const setValue = useCallbackRef(
    (next2) => {
      const setter = next2;
      const nextValue = typeof next2 === "function" ? setter(value) : next2;
      if (!shouldUpdateProp(value, nextValue)) {
        return;
      }
      if (!controlled) {
        setUncontrolledState(nextValue);
      }
      onChangeProp(nextValue);
    },
    [controlled, onChangeProp, value, shouldUpdateProp]
  );
  return [value, setValue];
}
function useDisclosure(props = {}) {
  const {
    onClose: onCloseProp,
    onOpen: onOpenProp,
    isOpen: isOpenProp,
    id: idProp
  } = props;
  const handleOpen = useCallbackRef(onOpenProp);
  const handleClose = useCallbackRef(onCloseProp);
  const [isOpenState, setIsOpen] = useState(props.defaultIsOpen || false);
  const isOpen = isOpenProp !== void 0 ? isOpenProp : isOpenState;
  const isControlled = isOpenProp !== void 0;
  const uid = useId$1();
  const id2 = idProp ?? `disclosure-${uid}`;
  const onClose = useCallback(() => {
    if (!isControlled) {
      setIsOpen(false);
    }
    handleClose == null ? void 0 : handleClose();
  }, [isControlled, handleClose]);
  const onOpen = useCallback(() => {
    if (!isControlled) {
      setIsOpen(true);
    }
    handleOpen == null ? void 0 : handleOpen();
  }, [isControlled, handleOpen]);
  const onToggle = useCallback(() => {
    if (isOpen) {
      onClose();
    } else {
      onOpen();
    }
  }, [isOpen, onOpen, onClose]);
  function getButtonProps(props2 = {}) {
    return {
      ...props2,
      "aria-expanded": isOpen,
      "aria-controls": id2,
      onClick(event) {
        var _a;
        (_a = props2.onClick) == null ? void 0 : _a.call(props2, event);
        onToggle();
      }
    };
  }
  function getDisclosureProps(props2 = {}) {
    return {
      ...props2,
      hidden: !isOpen,
      id: id2
    };
  }
  return {
    isOpen,
    onOpen,
    onClose,
    onToggle,
    isControlled,
    getButtonProps,
    getDisclosureProps
  };
}
const useSafeLayoutEffect$2 = Boolean(globalThis == null ? void 0 : globalThis.document) ? useLayoutEffect : useEffect;
const useUpdateEffect = (effect2, deps) => {
  const renderCycleRef = useRef(false);
  const effectCycleRef = useRef(false);
  useEffect(() => {
    const isMounted = renderCycleRef.current;
    const shouldRun = isMounted && effectCycleRef.current;
    if (shouldRun) {
      return effect2();
    }
    effectCycleRef.current = true;
  }, deps);
  useEffect(() => {
    renderCycleRef.current = true;
    return () => {
      renderCycleRef.current = false;
    };
  }, []);
};
function preventReturnFocus(containerRef) {
  const el = containerRef.current;
  if (!el)
    return false;
  const activeElement = getActiveElement(el);
  if (!activeElement)
    return false;
  if (el.contains(activeElement))
    return false;
  if (isTabbable(activeElement))
    return true;
  return false;
}
function useFocusOnHide(containerRef, options) {
  const { shouldFocus: shouldFocusProp, visible, focusRef } = options;
  const shouldFocus = shouldFocusProp && !visible;
  useUpdateEffect(() => {
    if (!shouldFocus)
      return;
    if (preventReturnFocus(containerRef)) {
      return;
    }
    const el = (focusRef == null ? void 0 : focusRef.current) || containerRef.current;
    let rafId;
    if (el) {
      rafId = requestAnimationFrame(() => {
        el.focus({ preventScroll: true });
      });
      return () => {
        cancelAnimationFrame(rafId);
      };
    }
  }, [shouldFocus, containerRef, focusRef]);
}
function useId(idProp, prefix2) {
  const id2 = useId$1();
  return useMemo(
    () => idProp || [prefix2, id2].filter(Boolean).join("-"),
    [idProp, prefix2, id2]
  );
}
function useIds$1(idProp, ...prefixes) {
  const id2 = useId(idProp);
  return useMemo(() => {
    return prefixes.map((prefix2) => `${prefix2}-${id2}`);
  }, [id2, prefixes]);
}
function assignRef(ref, value) {
  if (ref == null)
    return;
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  try {
    ref.current = value;
  } catch (error) {
    throw new Error(`Cannot assign value '${value}' to ref '${ref}'`);
  }
}
function mergeRefs(...refs) {
  return (node) => {
    refs.forEach((ref) => {
      assignRef(ref, node);
    });
  };
}
function useMergeRefs(...refs) {
  return useMemo(() => mergeRefs(...refs), refs);
}
function useOutsideClick(props) {
  const { ref, handler, enabled = true } = props;
  const savedHandler = useCallbackRef(handler);
  const stateRef = useRef({
    isPointerDown: false,
    ignoreEmulatedMouseEvents: false
  });
  const state2 = stateRef.current;
  useEffect(() => {
    if (!enabled)
      return;
    const onPointerDown = (e) => {
      if (isValidEvent(e, ref)) {
        state2.isPointerDown = true;
      }
    };
    const onMouseUp = (event) => {
      if (state2.ignoreEmulatedMouseEvents) {
        state2.ignoreEmulatedMouseEvents = false;
        return;
      }
      if (state2.isPointerDown && handler && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const onTouchEnd = (event) => {
      state2.ignoreEmulatedMouseEvents = true;
      if (handler && state2.isPointerDown && isValidEvent(event, ref)) {
        state2.isPointerDown = false;
        savedHandler(event);
      }
    };
    const doc = getOwnerDocument$1(ref.current);
    doc.addEventListener("mousedown", onPointerDown, true);
    doc.addEventListener("mouseup", onMouseUp, true);
    doc.addEventListener("touchstart", onPointerDown, true);
    doc.addEventListener("touchend", onTouchEnd, true);
    return () => {
      doc.removeEventListener("mousedown", onPointerDown, true);
      doc.removeEventListener("mouseup", onMouseUp, true);
      doc.removeEventListener("touchstart", onPointerDown, true);
      doc.removeEventListener("touchend", onTouchEnd, true);
    };
  }, [handler, ref, savedHandler, state2, enabled]);
}
function isValidEvent(event, ref) {
  var _a, _b;
  const target = ((_a = event.composedPath) == null ? void 0 : _a.call(event)[0]) ?? event.target;
  if (target) {
    const doc = getOwnerDocument$1(target);
    if (!doc.contains(target))
      return false;
  }
  return !((_b = ref.current) == null ? void 0 : _b.contains(target));
}
function getOwnerDocument$1(node) {
  return (node == null ? void 0 : node.ownerDocument) ?? document;
}
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
function useTimeout(callback, delay2) {
  const fn = useCallbackRef(callback);
  useEffect(() => {
    if (delay2 == null)
      return void 0;
    let timeoutId = null;
    timeoutId = window.setTimeout(() => {
      fn();
    }, delay2);
    return () => {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    };
  }, [delay2, fn]);
}
const state = {
  open: (str, post) => `${str}[data-open], ${str}[open], ${str}[data-state=open] ${post}`,
  closed: (str, post) => `${str}[data-closed], ${str}[data-state=closed] ${post}`,
  hover: (str, post) => `${str}:hover ${post}, ${str}[data-hover] ${post}`,
  focus: (str, post) => `${str}:focus ${post}, ${str}[data-focus] ${post}`,
  focusVisible: (str, post) => `${str}:focus-visible ${post}`,
  focusWithin: (str, post) => `${str}:focus-within ${post}`,
  active: (str, post) => `${str}:active ${post}, ${str}[data-active] ${post}`,
  disabled: (str, post) => `${str}:disabled ${post}, ${str}[data-disabled] ${post}`,
  invalid: (str, post) => `${str}:invalid ${post}, ${str}[data-invalid] ${post}`,
  checked: (str, post) => `${str}:checked ${post}, ${str}[data-checked] ${post}`,
  indeterminate: (str, post) => `${str}:indeterminate ${post}, ${str}[aria-checked=mixed] ${post}, ${str}[data-indeterminate] ${post}`,
  readOnly: (str, post) => `${str}:read-only ${post}, ${str}[readonly] ${post}, ${str}[data-read-only] ${post}`,
  expanded: (str, post) => `${str}:read-only ${post}, ${str}[aria-expanded=true] ${post}, ${str}[data-expanded] ${post}`,
  placeholderShown: (str, post) => `${str}:placeholder-shown ${post}`
};
const toGroup = (fn) => merge((v2) => fn(v2, "&"), "[role=group]", "[data-group]", ".group");
const toPeer = (fn) => merge((v2) => fn(v2, "~ &"), "[data-peer]", ".peer");
const merge = (fn, ...selectors) => selectors.map(fn).join(", ");
const pseudoSelectors = {
  /**
   * Styles for CSS selector `&:hover`
   */
  _hover: "&:hover, &[data-hover]",
  /**
   * Styles for CSS Selector `&:active`
   */
  _active: "&:active, &[data-active]",
  /**
   * Styles for CSS selector `&:focus`
   *
   */
  _focus: "&:focus, &[data-focus]",
  /**
   * Styles for the highlighted state.
   */
  _highlighted: "&[data-highlighted]",
  /**
   * Styles to apply when a child of this element has received focus
   * - CSS Selector `&:focus-within`
   */
  _focusWithin: "&:focus-within, &[data-focus-within]",
  /**
   * Styles to apply when this element has received focus via tabbing
   * - CSS Selector `&:focus-visible`
   */
  _focusVisible: "&:focus-visible, &[data-focus-visible]",
  /**
   * Styles to apply when this element is disabled. The passed styles are applied to these CSS selectors:
   * - `&[aria-disabled=true]`
   * - `&:disabled`
   * - `&[data-disabled]`
   * - `&[disabled]`
   */
  _disabled: "&:disabled, &[disabled], &[aria-disabled=true], &[data-disabled]",
  /**
   * Styles for CSS Selector `&:readonly`
   */
  _readOnly: "&[aria-readonly=true], &[readonly], &[data-readonly]",
  /**
   * Styles for CSS selector `&::before`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _before={{content:`""` }}/>
   * ```
   */
  _before: "&::before",
  /**
   * Styles for CSS selector `&::after`
   *
   * NOTE:When using this, ensure the `content` is wrapped in a backtick.
   * @example
   * ```jsx
   * <Box _after={{content:`""` }}/>
   * ```
   */
  _after: "&::after",
  /**
   * Styles for CSS selector `&:empty`
   */
  _empty: "&:empty, &[data-empty]",
  /**
   * Styles to apply when the ARIA attribute `aria-expanded` is `true`
   * - CSS selector `&[aria-expanded=true]`
   */
  _expanded: "&[aria-expanded=true], &[data-expanded], &[data-state=expanded]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `true`
   * - CSS selector `&[aria-checked=true]`
   */
  _checked: "&[aria-checked=true], &[data-checked], &[data-state=checked]",
  /**
   * Styles to apply when the ARIA attribute `aria-grabbed` is `true`
   * - CSS selector `&[aria-grabbed=true]`
   */
  _grabbed: "&[aria-grabbed=true], &[data-grabbed]",
  /**
   * Styles for CSS Selector `&[aria-pressed=true]`
   * Typically used to style the current "pressed" state of toggle buttons
   */
  _pressed: "&[aria-pressed=true], &[data-pressed]",
  /**
   * Styles to apply when the ARIA attribute `aria-invalid` is `true`
   * - CSS selector `&[aria-invalid=true]`
   */
  _invalid: "&[aria-invalid=true], &[data-invalid]",
  /**
   * Styles for the valid state
   * - CSS selector `&[data-valid], &[data-state=valid]`
   */
  _valid: "&[data-valid], &[data-state=valid]",
  /**
   * Styles for CSS Selector `&[aria-busy=true]` or `&[data-loading=true]`.
   * Useful for styling loading states
   */
  _loading: "&[data-loading], &[aria-busy=true]",
  /**
   * Styles to apply when the ARIA attribute `aria-selected` is `true`
   *
   * - CSS selector `&[aria-selected=true]`
   */
  _selected: "&[aria-selected=true], &[data-selected]",
  /**
   * Styles for CSS Selector `[hidden=true]`
   */
  _hidden: "&[hidden], &[data-hidden]",
  /**
   * Styles for CSS Selector `&:-webkit-autofill`
   */
  _autofill: "&:-webkit-autofill",
  /**
   * Styles for CSS Selector `&:nth-child(even)`
   */
  _even: "&:nth-of-type(even)",
  /**
   * Styles for CSS Selector `&:nth-child(odd)`
   */
  _odd: "&:nth-of-type(odd)",
  /**
   * Styles for CSS Selector `&:first-of-type`
   */
  _first: "&:first-of-type",
  /**
   * Styles for CSS selector `&::first-letter`
   *
   * NOTE: This selector is only applied for block-level elements and not preceded by an image or table.
   * @example
   * ```jsx
   * <Text _firstLetter={{ textDecoration: 'underline' }}>Once upon a time</Text>
   * ```
   */
  _firstLetter: "&::first-letter",
  /**
   * Styles for CSS Selector `&:last-of-type`
   */
  _last: "&:last-of-type",
  /**
   * Styles for CSS Selector `&:not(:first-of-type)`
   */
  _notFirst: "&:not(:first-of-type)",
  /**
   * Styles for CSS Selector `&:not(:last-of-type)`
   */
  _notLast: "&:not(:last-of-type)",
  /**
   * Styles for CSS Selector `&:visited`
   */
  _visited: "&:visited",
  /**
   * Used to style the active link in a navigation
   * Styles for CSS Selector `&[aria-current=page]`
   */
  _activeLink: "&[aria-current=page]",
  /**
   * Used to style the current step within a process
   * Styles for CSS Selector `&[aria-current=step]`
   */
  _activeStep: "&[aria-current=step]",
  /**
   * Styles to apply when the ARIA attribute `aria-checked` is `mixed`
   * - CSS selector `&[aria-checked=mixed]`
   */
  _indeterminate: "&:indeterminate, &[aria-checked=mixed], &[data-indeterminate], &[data-state=indeterminate]",
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is open
   */
  _groupOpen: toGroup(state.open),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is closed
   */
  _groupClosed: toGroup(state.closed),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is hovered
   */
  _groupHover: toGroup(state.hover),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is hovered
   */
  _peerHover: toPeer(state.hover),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is focused
   */
  _groupFocus: toGroup(state.focus),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is focused
   */
  _peerFocus: toPeer(state.focus),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` has visible focus
   */
  _groupFocusVisible: toGroup(state.focusVisible),
  /**
   * Styles to apply when a sibling element with `.peer`or `data-peer` has visible focus
   */
  _peerFocusVisible: toPeer(state.focusVisible),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is active
   */
  _groupActive: toGroup(state.active),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is active
   */
  _peerActive: toPeer(state.active),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is disabled
   */
  _groupDisabled: toGroup(state.disabled),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is disabled
   */
  _peerDisabled: toPeer(state.disabled),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` is invalid
   */
  _groupInvalid: toGroup(state.invalid),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` is invalid
   */
  _peerInvalid: toPeer(state.invalid),
  /**
   * Styles to apply when a parent element with `.group`, `data-group` or `role=group` is checked
   */
  _groupChecked: toGroup(state.checked),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` is checked
   */
  _peerChecked: toPeer(state.checked),
  /**
   *  Styles to apply when a parent element with `.group`, `data-group` or `role=group` has focus within
   */
  _groupFocusWithin: toGroup(state.focusWithin),
  /**
   *  Styles to apply when a sibling element with `.peer` or `data-peer` has focus within
   */
  _peerFocusWithin: toPeer(state.focusWithin),
  /**
   * Styles to apply when a sibling element with `.peer` or `data-peer` has placeholder shown
   */
  _peerPlaceholderShown: toPeer(state.placeholderShown),
  /**
   * Styles for CSS Selector `&::placeholder`.
   */
  _placeholder: "&::placeholder, &[data-placeholder]",
  /**
   * Styles for CSS Selector `&:placeholder-shown`.
   */
  _placeholderShown: "&:placeholder-shown, &[data-placeholder-shown]",
  /**
   * Styles for CSS Selector `&:fullscreen`.
   */
  _fullScreen: "&:fullscreen, &[data-fullscreen]",
  /**
   * Styles for CSS Selector `&::selection`
   */
  _selection: "&::selection",
  /**
   * Styles for CSS Selector `[dir=rtl] &`
   * It is applied when a parent element or this element has `dir="rtl"`
   */
  _rtl: "[dir=rtl] &, &[dir=rtl]",
  /**
   * Styles for CSS Selector `[dir=ltr] &`
   * It is applied when a parent element or this element has `dir="ltr"`
   */
  _ltr: "[dir=ltr] &, &[dir=ltr]",
  /**
   * Styles for CSS Selector `@media (prefers-color-scheme: dark)`
   * It is used when the user has requested the system use a light or dark color theme.
   */
  _mediaDark: "@media (prefers-color-scheme: dark)",
  /**
   * Styles for CSS Selector `@media (prefers-reduced-motion: reduce)`
   * It is used when the user has requested the system to reduce the amount of animations.
   */
  _mediaReduceMotion: "@media (prefers-reduced-motion: reduce)",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _dark: ".chakra-ui-dark &:not([data-theme]),[data-theme=dark] &:not([data-theme]),&[data-theme=dark]",
  /**
   * Styles for when `data-theme` is applied to any parent of
   * this component or element.
   */
  _light: ".chakra-ui-light &:not([data-theme]),[data-theme=light] &:not([data-theme]),&[data-theme=light]",
  /**
   * Styles for the CSS Selector `&[data-orientation=horizontal]`
   */
  _horizontal: "&[data-orientation=horizontal]",
  /**
   * Styles for the CSS Selector `&[data-orientation=vertical]`
   */
  _vertical: "&[data-orientation=vertical]",
  /**
   * Styles for the CSS Selector `&[data-open], &[open], &[data-state=open]`
   */
  _open: "&[data-open], &[open], &[data-state=open]",
  /**
   * Styles for the CSS Selector `&[data-closed], &[data-state=closed]`
   */
  _closed: "&[data-closed], &[data-state=closed]",
  /**
   * Styles for the CSS Selector `&[data-complete]`
   */
  _complete: "&[data-complete]",
  /**
   * Styles for the CSS Selector `&[data-incomplete]`
   */
  _incomplete: "&[data-incomplete]",
  /**
   * Styles for the CSS Selector `&[data-current]`
   */
  _current: "&[data-current]"
};
const pseudoPropNames = Object.keys(
  pseudoSelectors
);
const isImportant = (value) => /!(important)?$/.test(value);
const withoutImportant = (value) => typeof value === "string" ? value.replace(/!(important)?$/, "").trim() : value;
const tokenToCSSVar = (scale2, value) => (theme2) => {
  const valueStr = String(value);
  const important = isImportant(valueStr);
  const valueWithoutImportant = withoutImportant(valueStr);
  const key = scale2 ? `${scale2}.${valueWithoutImportant}` : valueWithoutImportant;
  let transformed = isObject(theme2.__cssMap) && key in theme2.__cssMap ? theme2.__cssMap[key].varRef : value;
  transformed = withoutImportant(transformed);
  return important ? `${transformed} !important` : transformed;
};
function createTransform(options) {
  const { scale: scale2, transform: transform2, compose } = options;
  const fn = (value, theme2) => {
    const _value = tokenToCSSVar(scale2, value)(theme2);
    let result = (transform2 == null ? void 0 : transform2(_value, theme2)) ?? _value;
    if (compose) {
      result = compose(result, theme2);
    }
    return result;
  };
  return fn;
}
const pipe$2 = (...fns) => (v2) => fns.reduce((a, b) => b(a), v2);
function toConfig(scale2, transform2) {
  return (property) => {
    const result = { property, scale: scale2 };
    result.transform = createTransform({
      scale: scale2,
      transform: transform2
    });
    return result;
  };
}
const getRtl = ({ rtl, ltr }) => (theme2) => theme2.direction === "rtl" ? rtl : ltr;
function logical(options) {
  const { property, scale: scale2, transform: transform2 } = options;
  return {
    scale: scale2,
    property: getRtl(property),
    transform: scale2 ? createTransform({
      scale: scale2,
      compose: transform2
    }) : transform2
  };
}
const transformTemplate = [
  "rotate(var(--chakra-rotate, 0))",
  "scaleX(var(--chakra-scale-x, 1))",
  "scaleY(var(--chakra-scale-y, 1))",
  "skewX(var(--chakra-skew-x, 0))",
  "skewY(var(--chakra-skew-y, 0))"
];
function getTransformTemplate() {
  return [
    "translateX(var(--chakra-translate-x, 0))",
    "translateY(var(--chakra-translate-y, 0))",
    ...transformTemplate
  ].join(" ");
}
function getTransformGpuTemplate() {
  return [
    "translate3d(var(--chakra-translate-x, 0), var(--chakra-translate-y, 0), 0)",
    ...transformTemplate
  ].join(" ");
}
const filterTemplate = {
  "--chakra-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-sepia": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-drop-shadow": "var(--chakra-empty,/*!*/ /*!*/)",
  filter: [
    "var(--chakra-blur)",
    "var(--chakra-brightness)",
    "var(--chakra-contrast)",
    "var(--chakra-grayscale)",
    "var(--chakra-hue-rotate)",
    "var(--chakra-invert)",
    "var(--chakra-saturate)",
    "var(--chakra-sepia)",
    "var(--chakra-drop-shadow)"
  ].join(" ")
};
const backdropFilterTemplate = {
  backdropFilter: [
    "var(--chakra-backdrop-blur)",
    "var(--chakra-backdrop-brightness)",
    "var(--chakra-backdrop-contrast)",
    "var(--chakra-backdrop-grayscale)",
    "var(--chakra-backdrop-hue-rotate)",
    "var(--chakra-backdrop-invert)",
    "var(--chakra-backdrop-opacity)",
    "var(--chakra-backdrop-saturate)",
    "var(--chakra-backdrop-sepia)"
  ].join(" "),
  "--chakra-backdrop-blur": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-brightness": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-contrast": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-grayscale": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-hue-rotate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-invert": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-opacity": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-saturate": "var(--chakra-empty,/*!*/ /*!*/)",
  "--chakra-backdrop-sepia": "var(--chakra-empty,/*!*/ /*!*/)"
};
function getRingTemplate(value) {
  return {
    "--chakra-ring-offset-shadow": `var(--chakra-ring-inset) 0 0 0 var(--chakra-ring-offset-width) var(--chakra-ring-offset-color)`,
    "--chakra-ring-shadow": `var(--chakra-ring-inset) 0 0 0 calc(var(--chakra-ring-width) + var(--chakra-ring-offset-width)) var(--chakra-ring-color)`,
    "--chakra-ring-width": value,
    boxShadow: [
      `var(--chakra-ring-offset-shadow)`,
      `var(--chakra-ring-shadow)`,
      `var(--chakra-shadow, 0 0 #0000)`
    ].join(", ")
  };
}
const flexDirectionTemplate = {
  "row-reverse": {
    space: "--chakra-space-x-reverse",
    divide: "--chakra-divide-x-reverse"
  },
  "column-reverse": {
    space: "--chakra-space-y-reverse",
    divide: "--chakra-divide-y-reverse"
  }
};
const directionMap = {
  "to-t": "to top",
  "to-tr": "to top right",
  "to-r": "to right",
  "to-br": "to bottom right",
  "to-b": "to bottom",
  "to-bl": "to bottom left",
  "to-l": "to left",
  "to-tl": "to top left"
};
const valueSet = new Set(Object.values(directionMap));
const globalSet = /* @__PURE__ */ new Set([
  "none",
  "-moz-initial",
  "inherit",
  "initial",
  "revert",
  "unset"
]);
const trimSpace = (str) => str.trim();
function parseGradient(value, theme2) {
  if (value == null || globalSet.has(value))
    return value;
  const prevent = isCSSFunction(value) || globalSet.has(value);
  if (!prevent)
    return `url('${value}')`;
  const regex = /(^[a-z-A-Z]+)\((.*)\)/g;
  const results2 = regex.exec(value);
  const type2 = results2 == null ? void 0 : results2[1];
  const values = results2 == null ? void 0 : results2[2];
  if (!type2 || !values)
    return value;
  const _type = type2.includes("-gradient") ? type2 : `${type2}-gradient`;
  const [maybeDirection, ...stops] = values.split(",").map(trimSpace).filter(Boolean);
  if ((stops == null ? void 0 : stops.length) === 0)
    return value;
  const direction = maybeDirection in directionMap ? directionMap[maybeDirection] : maybeDirection;
  stops.unshift(direction);
  const _values = stops.map((stop) => {
    if (valueSet.has(stop))
      return stop;
    const firstStop = stop.indexOf(" ");
    const [_color, _stop] = firstStop !== -1 ? [stop.substr(0, firstStop), stop.substr(firstStop + 1)] : [stop];
    const _stopOrFunc = isCSSFunction(_stop) ? _stop : _stop && _stop.split(" ");
    const key = `colors.${_color}`;
    const color2 = key in theme2.__cssMap ? theme2.__cssMap[key].varRef : _color;
    return _stopOrFunc ? [
      color2,
      ...Array.isArray(_stopOrFunc) ? _stopOrFunc : [_stopOrFunc]
    ].join(" ") : color2;
  });
  return `${_type}(${_values.join(", ")})`;
}
const isCSSFunction = (value) => {
  return typeof value === "string" && value.includes("(") && value.includes(")");
};
const gradientTransform = (value, theme2) => parseGradient(value, theme2 ?? {});
function isCssVar$1(value) {
  return /^var\(--.+\)$/.test(value);
}
const analyzeCSSValue = (value) => {
  const num = parseFloat(value.toString());
  const unit = value.toString().replace(String(num), "");
  return { unitless: !unit, value: num, unit };
};
const wrap = (str) => (value) => `${str}(${value})`;
const transformFunctions = {
  filter(value) {
    return value !== "auto" ? value : filterTemplate;
  },
  backdropFilter(value) {
    return value !== "auto" ? value : backdropFilterTemplate;
  },
  ring(value) {
    return getRingTemplate(transformFunctions.px(value));
  },
  bgClip(value) {
    return value === "text" ? { color: "transparent", backgroundClip: "text" } : { backgroundClip: value };
  },
  transform(value) {
    if (value === "auto")
      return getTransformTemplate();
    if (value === "auto-gpu")
      return getTransformGpuTemplate();
    return value;
  },
  vh(value) {
    return value === "$100vh" ? "var(--chakra-vh)" : value;
  },
  px(value) {
    if (value == null)
      return value;
    const { unitless } = analyzeCSSValue(value);
    return unitless || typeof value === "number" ? `${value}px` : value;
  },
  fraction(value) {
    return !(typeof value === "number") || value > 1 ? value : `${value * 100}%`;
  },
  float(value, theme2) {
    const map = { left: "right", right: "left" };
    return theme2.direction === "rtl" ? map[value] : value;
  },
  degree(value) {
    if (isCssVar$1(value) || value == null)
      return value;
    const unitless = typeof value === "string" && !value.endsWith("deg");
    return typeof value === "number" || unitless ? `${value}deg` : value;
  },
  gradient: gradientTransform,
  blur: wrap("blur"),
  opacity: wrap("opacity"),
  brightness: wrap("brightness"),
  contrast: wrap("contrast"),
  dropShadow: wrap("drop-shadow"),
  grayscale: wrap("grayscale"),
  hueRotate: (value) => wrap("hue-rotate")(transformFunctions.degree(value)),
  invert: wrap("invert"),
  saturate: wrap("saturate"),
  sepia: wrap("sepia"),
  bgImage(value) {
    if (value == null)
      return value;
    const prevent = isCSSFunction(value) || globalSet.has(value);
    return !prevent ? `url(${value})` : value;
  },
  outline(value) {
    const isNoneOrZero = String(value) === "0" || String(value) === "none";
    return value !== null && isNoneOrZero ? { outline: "2px solid transparent", outlineOffset: "2px" } : { outline: value };
  },
  flexDirection(value) {
    const { space: space2, divide: divide2 } = flexDirectionTemplate[value] ?? {};
    const result = { flexDirection: value };
    if (space2)
      result[space2] = 1;
    if (divide2)
      result[divide2] = 1;
    return result;
  }
};
const t = {
  borderWidths: toConfig("borderWidths"),
  borderStyles: toConfig("borderStyles"),
  colors: toConfig("colors"),
  borders: toConfig("borders"),
  gradients: toConfig("gradients", transformFunctions.gradient),
  radii: toConfig("radii", transformFunctions.px),
  space: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
  spaceT: toConfig("space", pipe$2(transformFunctions.vh, transformFunctions.px)),
  degreeT(property) {
    return { property, transform: transformFunctions.degree };
  },
  prop(property, scale2, transform2) {
    return {
      property,
      scale: scale2,
      ...scale2 && {
        transform: createTransform({ scale: scale2, transform: transform2 })
      }
    };
  },
  propT(property, transform2) {
    return { property, transform: transform2 };
  },
  sizes: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.px)),
  sizesT: toConfig("sizes", pipe$2(transformFunctions.vh, transformFunctions.fraction)),
  shadows: toConfig("shadows"),
  logical,
  blur: toConfig("blur", transformFunctions.blur)
};
const background = {
  background: t.colors("background"),
  backgroundColor: t.colors("backgroundColor"),
  backgroundImage: t.gradients("backgroundImage"),
  backgroundSize: true,
  backgroundPosition: true,
  backgroundRepeat: true,
  backgroundAttachment: true,
  backgroundClip: { transform: transformFunctions.bgClip },
  bgSize: t.prop("backgroundSize"),
  bgPosition: t.prop("backgroundPosition"),
  bg: t.colors("background"),
  bgColor: t.colors("backgroundColor"),
  bgPos: t.prop("backgroundPosition"),
  bgRepeat: t.prop("backgroundRepeat"),
  bgAttachment: t.prop("backgroundAttachment"),
  bgGradient: t.gradients("backgroundImage"),
  bgClip: { transform: transformFunctions.bgClip }
};
Object.assign(background, {
  bgImage: background.backgroundImage,
  bgImg: background.backgroundImage
});
const border = {
  border: t.borders("border"),
  borderWidth: t.borderWidths("borderWidth"),
  borderStyle: t.borderStyles("borderStyle"),
  borderColor: t.colors("borderColor"),
  borderRadius: t.radii("borderRadius"),
  borderTop: t.borders("borderTop"),
  borderBlockStart: t.borders("borderBlockStart"),
  borderTopLeftRadius: t.radii("borderTopLeftRadius"),
  borderStartStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopLeftRadius",
      rtl: "borderTopRightRadius"
    }
  }),
  borderEndStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomLeftRadius",
      rtl: "borderBottomRightRadius"
    }
  }),
  borderTopRightRadius: t.radii("borderTopRightRadius"),
  borderStartEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderTopRightRadius",
      rtl: "borderTopLeftRadius"
    }
  }),
  borderEndEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: "borderBottomRightRadius",
      rtl: "borderBottomLeftRadius"
    }
  }),
  borderRight: t.borders("borderRight"),
  borderInlineEnd: t.borders("borderInlineEnd"),
  borderBottom: t.borders("borderBottom"),
  borderBlockEnd: t.borders("borderBlockEnd"),
  borderBottomLeftRadius: t.radii("borderBottomLeftRadius"),
  borderBottomRightRadius: t.radii("borderBottomRightRadius"),
  borderLeft: t.borders("borderLeft"),
  borderInlineStart: {
    property: "borderInlineStart",
    scale: "borders"
  },
  borderInlineStartRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopLeftRadius", "borderBottomLeftRadius"],
      rtl: ["borderTopRightRadius", "borderBottomRightRadius"]
    }
  }),
  borderInlineEndRadius: t.logical({
    scale: "radii",
    property: {
      ltr: ["borderTopRightRadius", "borderBottomRightRadius"],
      rtl: ["borderTopLeftRadius", "borderBottomLeftRadius"]
    }
  }),
  borderX: t.borders(["borderLeft", "borderRight"]),
  borderInline: t.borders("borderInline"),
  borderY: t.borders(["borderTop", "borderBottom"]),
  borderBlock: t.borders("borderBlock"),
  borderTopWidth: t.borderWidths("borderTopWidth"),
  borderBlockStartWidth: t.borderWidths("borderBlockStartWidth"),
  borderTopColor: t.colors("borderTopColor"),
  borderBlockStartColor: t.colors("borderBlockStartColor"),
  borderTopStyle: t.borderStyles("borderTopStyle"),
  borderBlockStartStyle: t.borderStyles("borderBlockStartStyle"),
  borderBottomWidth: t.borderWidths("borderBottomWidth"),
  borderBlockEndWidth: t.borderWidths("borderBlockEndWidth"),
  borderBottomColor: t.colors("borderBottomColor"),
  borderBlockEndColor: t.colors("borderBlockEndColor"),
  borderBottomStyle: t.borderStyles("borderBottomStyle"),
  borderBlockEndStyle: t.borderStyles("borderBlockEndStyle"),
  borderLeftWidth: t.borderWidths("borderLeftWidth"),
  borderInlineStartWidth: t.borderWidths("borderInlineStartWidth"),
  borderLeftColor: t.colors("borderLeftColor"),
  borderInlineStartColor: t.colors("borderInlineStartColor"),
  borderLeftStyle: t.borderStyles("borderLeftStyle"),
  borderInlineStartStyle: t.borderStyles("borderInlineStartStyle"),
  borderRightWidth: t.borderWidths("borderRightWidth"),
  borderInlineEndWidth: t.borderWidths("borderInlineEndWidth"),
  borderRightColor: t.colors("borderRightColor"),
  borderInlineEndColor: t.colors("borderInlineEndColor"),
  borderRightStyle: t.borderStyles("borderRightStyle"),
  borderInlineEndStyle: t.borderStyles("borderInlineEndStyle"),
  borderTopRadius: t.radii(["borderTopLeftRadius", "borderTopRightRadius"]),
  borderBottomRadius: t.radii([
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ]),
  borderLeftRadius: t.radii(["borderTopLeftRadius", "borderBottomLeftRadius"]),
  borderRightRadius: t.radii([
    "borderTopRightRadius",
    "borderBottomRightRadius"
  ])
};
Object.assign(border, {
  rounded: border.borderRadius,
  roundedTop: border.borderTopRadius,
  roundedTopLeft: border.borderTopLeftRadius,
  roundedTopRight: border.borderTopRightRadius,
  roundedTopStart: border.borderStartStartRadius,
  roundedTopEnd: border.borderStartEndRadius,
  roundedBottom: border.borderBottomRadius,
  roundedBottomLeft: border.borderBottomLeftRadius,
  roundedBottomRight: border.borderBottomRightRadius,
  roundedBottomStart: border.borderEndStartRadius,
  roundedBottomEnd: border.borderEndEndRadius,
  roundedLeft: border.borderLeftRadius,
  roundedRight: border.borderRightRadius,
  roundedStart: border.borderInlineStartRadius,
  roundedEnd: border.borderInlineEndRadius,
  borderStart: border.borderInlineStart,
  borderEnd: border.borderInlineEnd,
  borderTopStartRadius: border.borderStartStartRadius,
  borderTopEndRadius: border.borderStartEndRadius,
  borderBottomStartRadius: border.borderEndStartRadius,
  borderBottomEndRadius: border.borderEndEndRadius,
  borderStartRadius: border.borderInlineStartRadius,
  borderEndRadius: border.borderInlineEndRadius,
  borderStartWidth: border.borderInlineStartWidth,
  borderEndWidth: border.borderInlineEndWidth,
  borderStartColor: border.borderInlineStartColor,
  borderEndColor: border.borderInlineEndColor,
  borderStartStyle: border.borderInlineStartStyle,
  borderEndStyle: border.borderInlineEndStyle
});
const color$1 = {
  color: t.colors("color"),
  textColor: t.colors("color"),
  fill: t.colors("fill"),
  stroke: t.colors("stroke"),
  accentColor: t.colors("accentColor"),
  textFillColor: t.colors("textFillColor")
};
const flexbox = {
  alignItems: true,
  alignContent: true,
  justifyItems: true,
  justifyContent: true,
  flexWrap: true,
  flexDirection: { transform: transformFunctions.flexDirection },
  flex: true,
  flexFlow: true,
  flexGrow: true,
  flexShrink: true,
  flexBasis: t.sizes("flexBasis"),
  justifySelf: true,
  alignSelf: true,
  order: true,
  placeItems: true,
  placeContent: true,
  placeSelf: true,
  gap: t.space("gap"),
  rowGap: t.space("rowGap"),
  columnGap: t.space("columnGap")
};
Object.assign(flexbox, {
  flexDir: flexbox.flexDirection
});
const layout = {
  width: t.sizesT("width"),
  inlineSize: t.sizesT("inlineSize"),
  height: t.sizes("height"),
  blockSize: t.sizes("blockSize"),
  boxSize: t.sizes(["width", "height"]),
  minWidth: t.sizes("minWidth"),
  minInlineSize: t.sizes("minInlineSize"),
  minHeight: t.sizes("minHeight"),
  minBlockSize: t.sizes("minBlockSize"),
  maxWidth: t.sizes("maxWidth"),
  maxInlineSize: t.sizes("maxInlineSize"),
  maxHeight: t.sizes("maxHeight"),
  maxBlockSize: t.sizes("maxBlockSize"),
  overflow: true,
  overflowX: true,
  overflowY: true,
  overscrollBehavior: true,
  overscrollBehaviorX: true,
  overscrollBehaviorY: true,
  display: true,
  aspectRatio: true,
  hideFrom: {
    scale: "breakpoints",
    transform: (value, theme2) => {
      var _a, _b;
      const breakpoint = ((_b = (_a = theme2.__breakpoints) == null ? void 0 : _a.get(value)) == null ? void 0 : _b.minW) ?? value;
      const mq = `@media screen and (min-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  hideBelow: {
    scale: "breakpoints",
    transform: (value, theme2) => {
      var _a, _b;
      const breakpoint = ((_b = (_a = theme2.__breakpoints) == null ? void 0 : _a.get(value)) == null ? void 0 : _b._minW) ?? value;
      const mq = `@media screen and (max-width: ${breakpoint})`;
      return { [mq]: { display: "none" } };
    }
  },
  verticalAlign: true,
  boxSizing: true,
  boxDecorationBreak: true,
  float: t.propT("float", transformFunctions.float),
  objectFit: true,
  objectPosition: true,
  visibility: true,
  isolation: true
};
Object.assign(layout, {
  w: layout.width,
  h: layout.height,
  minW: layout.minWidth,
  maxW: layout.maxWidth,
  minH: layout.minHeight,
  maxH: layout.maxHeight,
  overscroll: layout.overscrollBehavior,
  overscrollX: layout.overscrollBehaviorX,
  overscrollY: layout.overscrollBehaviorY
});
const filter$1 = {
  filter: { transform: transformFunctions.filter },
  blur: t.blur("--chakra-blur"),
  brightness: t.propT("--chakra-brightness", transformFunctions.brightness),
  contrast: t.propT("--chakra-contrast", transformFunctions.contrast),
  hueRotate: t.propT("--chakra-hue-rotate", transformFunctions.hueRotate),
  invert: t.propT("--chakra-invert", transformFunctions.invert),
  saturate: t.propT("--chakra-saturate", transformFunctions.saturate),
  dropShadow: t.propT("--chakra-drop-shadow", transformFunctions.dropShadow),
  backdropFilter: { transform: transformFunctions.backdropFilter },
  backdropBlur: t.blur("--chakra-backdrop-blur"),
  backdropBrightness: t.propT(
    "--chakra-backdrop-brightness",
    transformFunctions.brightness
  ),
  backdropContrast: t.propT("--chakra-backdrop-contrast", transformFunctions.contrast),
  backdropHueRotate: t.propT(
    "--chakra-backdrop-hue-rotate",
    transformFunctions.hueRotate
  ),
  backdropInvert: t.propT("--chakra-backdrop-invert", transformFunctions.invert),
  backdropSaturate: t.propT("--chakra-backdrop-saturate", transformFunctions.saturate)
};
const ring = {
  ring: { transform: transformFunctions.ring },
  ringColor: t.colors("--chakra-ring-color"),
  ringOffset: t.prop("--chakra-ring-offset-width"),
  ringOffsetColor: t.colors("--chakra-ring-offset-color"),
  ringInset: t.prop("--chakra-ring-inset")
};
const interactivity = {
  appearance: true,
  cursor: true,
  resize: true,
  userSelect: true,
  pointerEvents: true,
  outline: { transform: transformFunctions.outline },
  outlineOffset: true,
  outlineColor: t.colors("outlineColor")
};
const grid = {
  gridGap: t.space("gridGap"),
  gridColumnGap: t.space("gridColumnGap"),
  gridRowGap: t.space("gridRowGap"),
  gridColumn: true,
  gridRow: true,
  gridAutoFlow: true,
  gridAutoColumns: true,
  gridColumnStart: true,
  gridColumnEnd: true,
  gridRowStart: true,
  gridRowEnd: true,
  gridAutoRows: true,
  gridTemplate: true,
  gridTemplateColumns: true,
  gridTemplateRows: true,
  gridTemplateAreas: true,
  gridArea: true
};
function get(obj, path, fallback, index) {
  const key = typeof path === "string" ? path.split(".") : [path];
  for (index = 0; index < key.length; index += 1) {
    if (!obj)
      break;
    obj = obj[key[index]];
  }
  return obj === void 0 ? fallback : obj;
}
const memoize = (fn) => {
  const cache2 = /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj, path, fallback, index) => {
    if (typeof obj === "undefined") {
      return fn(obj, path, fallback);
    }
    if (!cache2.has(obj)) {
      cache2.set(obj, /* @__PURE__ */ new Map());
    }
    const map = cache2.get(obj);
    if (map.has(path)) {
      return map.get(path);
    }
    const value = fn(obj, path, fallback, index);
    map.set(path, value);
    return value;
  };
  return memoizedFn;
};
const memoizedGet = memoize(get);
const srOnly = {
  border: "0px",
  clip: "rect(0, 0, 0, 0)",
  width: "1px",
  height: "1px",
  margin: "-1px",
  padding: "0px",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
const srFocusable = {
  position: "static",
  width: "auto",
  height: "auto",
  clip: "auto",
  padding: "0",
  margin: "0",
  overflow: "visible",
  whiteSpace: "normal"
};
const getWithPriority = (theme2, key, styles2) => {
  const result = {};
  const obj = memoizedGet(theme2, key, {});
  for (const prop in obj) {
    const isInStyles = prop in styles2 && styles2[prop] != null;
    if (!isInStyles)
      result[prop] = obj[prop];
  }
  return result;
};
const others = {
  srOnly: {
    transform(value) {
      if (value === true)
        return srOnly;
      if (value === "focusable")
        return srFocusable;
      return {};
    }
  },
  layerStyle: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, `layerStyles.${value}`, styles2)
  },
  textStyle: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, `textStyles.${value}`, styles2)
  },
  apply: {
    processResult: true,
    transform: (value, theme2, styles2) => getWithPriority(theme2, value, styles2)
  }
};
const position = {
  position: true,
  pos: t.prop("position"),
  zIndex: t.prop("zIndex", "zIndices"),
  inset: t.spaceT("inset"),
  insetX: t.spaceT(["left", "right"]),
  insetInline: t.spaceT("insetInline"),
  insetY: t.spaceT(["top", "bottom"]),
  insetBlock: t.spaceT("insetBlock"),
  top: t.spaceT("top"),
  insetBlockStart: t.spaceT("insetBlockStart"),
  bottom: t.spaceT("bottom"),
  insetBlockEnd: t.spaceT("insetBlockEnd"),
  left: t.spaceT("left"),
  insetInlineStart: t.logical({
    scale: "space",
    property: { ltr: "left", rtl: "right" }
  }),
  right: t.spaceT("right"),
  insetInlineEnd: t.logical({
    scale: "space",
    property: { ltr: "right", rtl: "left" }
  })
};
Object.assign(position, {
  insetStart: position.insetInlineStart,
  insetEnd: position.insetInlineEnd
});
const effect = {
  boxShadow: t.shadows("boxShadow"),
  mixBlendMode: true,
  blendMode: t.prop("mixBlendMode"),
  backgroundBlendMode: true,
  bgBlendMode: t.prop("backgroundBlendMode"),
  opacity: true
};
Object.assign(effect, {
  shadow: effect.boxShadow
});
const space = {
  margin: t.spaceT("margin"),
  marginTop: t.spaceT("marginTop"),
  marginBlockStart: t.spaceT("marginBlockStart"),
  marginRight: t.spaceT("marginRight"),
  marginInlineEnd: t.spaceT("marginInlineEnd"),
  marginBottom: t.spaceT("marginBottom"),
  marginBlockEnd: t.spaceT("marginBlockEnd"),
  marginLeft: t.spaceT("marginLeft"),
  marginInlineStart: t.spaceT("marginInlineStart"),
  marginX: t.spaceT(["marginInlineStart", "marginInlineEnd"]),
  marginInline: t.spaceT("marginInline"),
  marginY: t.spaceT(["marginTop", "marginBottom"]),
  marginBlock: t.spaceT("marginBlock"),
  padding: t.space("padding"),
  paddingTop: t.space("paddingTop"),
  paddingBlockStart: t.space("paddingBlockStart"),
  paddingRight: t.space("paddingRight"),
  paddingBottom: t.space("paddingBottom"),
  paddingBlockEnd: t.space("paddingBlockEnd"),
  paddingLeft: t.space("paddingLeft"),
  paddingInlineStart: t.space("paddingInlineStart"),
  paddingInlineEnd: t.space("paddingInlineEnd"),
  paddingX: t.space(["paddingInlineStart", "paddingInlineEnd"]),
  paddingInline: t.space("paddingInline"),
  paddingY: t.space(["paddingTop", "paddingBottom"]),
  paddingBlock: t.space("paddingBlock")
};
Object.assign(space, {
  m: space.margin,
  mt: space.marginTop,
  mr: space.marginRight,
  me: space.marginInlineEnd,
  marginEnd: space.marginInlineEnd,
  mb: space.marginBottom,
  ml: space.marginLeft,
  ms: space.marginInlineStart,
  marginStart: space.marginInlineStart,
  mx: space.marginX,
  my: space.marginY,
  p: space.padding,
  pt: space.paddingTop,
  py: space.paddingY,
  px: space.paddingX,
  pb: space.paddingBottom,
  pl: space.paddingLeft,
  ps: space.paddingInlineStart,
  paddingStart: space.paddingInlineStart,
  pr: space.paddingRight,
  pe: space.paddingInlineEnd,
  paddingEnd: space.paddingInlineEnd
});
const scroll = {
  scrollBehavior: true,
  scrollSnapAlign: true,
  scrollSnapStop: true,
  scrollSnapType: true,
  // scroll margin
  scrollMargin: t.spaceT("scrollMargin"),
  scrollMarginTop: t.spaceT("scrollMarginTop"),
  scrollMarginBottom: t.spaceT("scrollMarginBottom"),
  scrollMarginLeft: t.spaceT("scrollMarginLeft"),
  scrollMarginRight: t.spaceT("scrollMarginRight"),
  scrollMarginX: t.spaceT(["scrollMarginLeft", "scrollMarginRight"]),
  scrollMarginY: t.spaceT(["scrollMarginTop", "scrollMarginBottom"]),
  // scroll padding
  scrollPadding: t.spaceT("scrollPadding"),
  scrollPaddingTop: t.spaceT("scrollPaddingTop"),
  scrollPaddingBottom: t.spaceT("scrollPaddingBottom"),
  scrollPaddingLeft: t.spaceT("scrollPaddingLeft"),
  scrollPaddingRight: t.spaceT("scrollPaddingRight"),
  scrollPaddingX: t.spaceT(["scrollPaddingLeft", "scrollPaddingRight"]),
  scrollPaddingY: t.spaceT(["scrollPaddingTop", "scrollPaddingBottom"])
};
const typography = {
  fontFamily: t.prop("fontFamily", "fonts"),
  fontSize: t.prop("fontSize", "fontSizes", transformFunctions.px),
  fontWeight: t.prop("fontWeight", "fontWeights"),
  lineHeight: t.prop("lineHeight", "lineHeights"),
  letterSpacing: t.prop("letterSpacing", "letterSpacings"),
  textAlign: true,
  fontStyle: true,
  textIndent: true,
  wordBreak: true,
  overflowWrap: true,
  textOverflow: true,
  textTransform: true,
  whiteSpace: true,
  isTruncated: {
    transform(value) {
      if (value === true) {
        return {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        };
      }
    }
  },
  noOfLines: {
    static: {
      overflow: "hidden",
      textOverflow: "ellipsis",
      display: "-webkit-box",
      WebkitBoxOrient: "vertical",
      //@ts-ignore
      WebkitLineClamp: "var(--chakra-line-clamp)"
    },
    property: "--chakra-line-clamp"
  }
};
const textDecoration = {
  textDecorationColor: t.colors("textDecorationColor"),
  textDecoration: true,
  textDecor: { property: "textDecoration" },
  textDecorationLine: true,
  textDecorationStyle: true,
  textDecorationThickness: true,
  textUnderlineOffset: true,
  textShadow: t.shadows("textShadow")
};
const transform = {
  clipPath: true,
  transform: t.propT("transform", transformFunctions.transform),
  transformOrigin: true,
  translateX: t.spaceT("--chakra-translate-x"),
  translateY: t.spaceT("--chakra-translate-y"),
  skewX: t.degreeT("--chakra-skew-x"),
  skewY: t.degreeT("--chakra-skew-y"),
  scaleX: t.prop("--chakra-scale-x"),
  scaleY: t.prop("--chakra-scale-y"),
  scale: t.prop(["--chakra-scale-x", "--chakra-scale-y"]),
  rotate: t.degreeT("--chakra-rotate")
};
const list = {
  listStyleType: true,
  listStylePosition: true,
  listStylePos: t.prop("listStylePosition"),
  listStyleImage: true,
  listStyleImg: t.prop("listStyleImage")
};
const transition = {
  transition: true,
  transitionDelay: true,
  animation: true,
  willChange: true,
  transitionDuration: t.prop("transitionDuration", "transition.duration"),
  transitionProperty: t.prop("transitionProperty", "transition.property"),
  transitionTimingFunction: t.prop(
    "transitionTimingFunction",
    "transition.easing"
  )
};
const systemProps = mergeWith(
  {},
  background,
  border,
  color$1,
  flexbox,
  layout,
  filter$1,
  ring,
  interactivity,
  grid,
  others,
  position,
  effect,
  space,
  scroll,
  typography,
  textDecoration,
  transform,
  list,
  transition
);
const layoutSystem = Object.assign({}, space, layout, flexbox, grid, position);
const layoutPropNames = Object.keys(
  layoutSystem
);
const propNames = [...Object.keys(systemProps), ...pseudoPropNames];
const styleProps = { ...systemProps, ...pseudoSelectors };
const isStyleProp = (prop) => prop in styleProps;
const expandResponsive = (styles2) => (theme2) => {
  if (!theme2.__breakpoints)
    return styles2;
  const { isResponsive, toArrayValue, media: medias } = theme2.__breakpoints;
  const computedStyles = {};
  for (const key in styles2) {
    let value = runIfFn(styles2[key], theme2);
    if (value == null)
      continue;
    value = isObject(value) && isResponsive(value) ? toArrayValue(value) : value;
    if (!Array.isArray(value)) {
      computedStyles[key] = value;
      continue;
    }
    const queries = value.slice(0, medias.length).length;
    for (let index = 0; index < queries; index += 1) {
      const media = medias == null ? void 0 : medias[index];
      if (!media) {
        computedStyles[key] = value[index];
        continue;
      }
      computedStyles[media] = computedStyles[media] || {};
      if (value[index] == null) {
        continue;
      }
      computedStyles[media][key] = value[index];
    }
  }
  return computedStyles;
};
function splitByComma(value) {
  const chunks = [];
  let chunk = "";
  let inParens = false;
  for (let i = 0; i < value.length; i++) {
    const char = value[i];
    if (char === "(") {
      inParens = true;
      chunk += char;
    } else if (char === ")") {
      inParens = false;
      chunk += char;
    } else if (char === "," && !inParens) {
      chunks.push(chunk);
      chunk = "";
    } else {
      chunk += char;
    }
  }
  chunk = chunk.trim();
  if (chunk) {
    chunks.push(chunk);
  }
  return chunks;
}
function isCssVar(value) {
  return /^var\(--.+\)$/.test(value);
}
const isCSSVariableTokenValue = (key, value) => key.startsWith("--") && typeof value === "string" && !isCssVar(value);
const resolveTokenValue = (theme2, value) => {
  if (value == null)
    return value;
  const getVar = (val) => {
    var _a, _b;
    return (_b = (_a = theme2.__cssMap) == null ? void 0 : _a[val]) == null ? void 0 : _b.varRef;
  };
  const getValue = (val) => getVar(val) ?? val;
  const [tokenValue, fallbackValue] = splitByComma(value);
  value = getVar(tokenValue) ?? getValue(fallbackValue) ?? getValue(value);
  return value;
};
function getCss(options) {
  const { configs = {}, pseudos = {}, theme: theme2 } = options;
  const css2 = (stylesOrFn, nested = false) => {
    var _a;
    const _styles = runIfFn(stylesOrFn, theme2);
    const styles2 = expandResponsive(_styles)(theme2);
    let computedStyles = {};
    for (let key in styles2) {
      const valueOrFn = styles2[key];
      let value = runIfFn(valueOrFn, theme2);
      if (key in pseudos) {
        key = pseudos[key];
      }
      if (isCSSVariableTokenValue(key, value)) {
        value = resolveTokenValue(theme2, value);
      }
      let config2 = configs[key];
      if (config2 === true) {
        config2 = { property: key };
      }
      if (isObject(value)) {
        computedStyles[key] = computedStyles[key] ?? {};
        computedStyles[key] = mergeWith(
          {},
          computedStyles[key],
          css2(value, true)
        );
        continue;
      }
      let rawValue = ((_a = config2 == null ? void 0 : config2.transform) == null ? void 0 : _a.call(config2, value, theme2, _styles)) ?? value;
      rawValue = (config2 == null ? void 0 : config2.processResult) ? css2(rawValue, true) : rawValue;
      const configProperty = runIfFn(config2 == null ? void 0 : config2.property, theme2);
      if (!nested && (config2 == null ? void 0 : config2.static)) {
        const staticStyles = runIfFn(config2.static, theme2);
        computedStyles = mergeWith({}, computedStyles, staticStyles);
      }
      if (configProperty && Array.isArray(configProperty)) {
        for (const property of configProperty) {
          computedStyles[property] = rawValue;
        }
        continue;
      }
      if (configProperty) {
        if (configProperty === "&" && isObject(rawValue)) {
          computedStyles = mergeWith({}, computedStyles, rawValue);
        } else {
          computedStyles[configProperty] = rawValue;
        }
        continue;
      }
      if (isObject(rawValue)) {
        computedStyles = mergeWith({}, computedStyles, rawValue);
        continue;
      }
      computedStyles[key] = rawValue;
    }
    return computedStyles;
  };
  return css2;
}
const css$2 = (styles2) => (theme2) => {
  const cssFn = getCss({
    theme: theme2,
    pseudos: pseudoSelectors,
    configs: systemProps
  });
  return cssFn(styles2);
};
function defineStyle(styles2) {
  return styles2;
}
function defineStyleConfig(config2) {
  return config2;
}
function createMultiStyleConfigHelpers(parts) {
  return {
    definePartsStyle(config2) {
      return config2;
    },
    defineMultiStyleConfig(config2) {
      return { parts, ...config2 };
    }
  };
}
function getCSSVar(theme2, scale2, value) {
  var _a, _b;
  return ((_b = (_a = theme2.__cssMap) == null ? void 0 : _a[`${scale2}.${value}`]) == null ? void 0 : _b.varRef) ?? value;
}
function normalize$1(value, toArray) {
  if (Array.isArray(value))
    return value;
  if (isObject(value))
    return toArray(value);
  if (value != null)
    return [value];
}
function getNextIndex$1(values, i) {
  for (let j2 = i + 1; j2 < values.length; j2++) {
    if (values[j2] != null)
      return j2;
  }
  return -1;
}
function createResolver(theme2) {
  const breakpointUtil = theme2.__breakpoints;
  return function resolver(config2, prop, value, props) {
    var _a, _b;
    if (!breakpointUtil)
      return;
    const result = {};
    const normalized = normalize$1(value, breakpointUtil.toArrayValue);
    if (!normalized)
      return result;
    const len = normalized.length;
    const isSingle = len === 1;
    const isMultipart = !!config2.parts;
    for (let i = 0; i < len; i++) {
      const key = breakpointUtil.details[i];
      const nextKey = breakpointUtil.details[getNextIndex$1(normalized, i)];
      const query = toMediaQueryString(key.minW, nextKey == null ? void 0 : nextKey._minW);
      const styles2 = runIfFn((_a = config2[prop]) == null ? void 0 : _a[normalized[i]], props);
      if (!styles2)
        continue;
      if (isMultipart) {
        (_b = config2.parts) == null ? void 0 : _b.forEach((part) => {
          mergeWith(result, {
            [part]: isSingle ? styles2[part] : { [query]: styles2[part] }
          });
        });
        continue;
      }
      if (!isMultipart) {
        if (isSingle)
          mergeWith(result, styles2);
        else
          result[query] = styles2;
        continue;
      }
      result[query] = styles2;
    }
    return result;
  };
}
function resolveStyleConfig(config2) {
  return (props) => {
    const { variant, size, theme: theme2 } = props;
    const recipe = createResolver(theme2);
    return mergeWith(
      {},
      runIfFn(config2.baseStyle ?? {}, props),
      recipe(config2, "sizes", size, props),
      recipe(config2, "variants", variant, props)
    );
  };
}
function omitThemingProps(props) {
  return omit(props, ["styleConfig", "size", "variant", "colorScheme"]);
}
function resolveReference(operand) {
  if (isObject(operand) && operand.reference) {
    return operand.reference;
  }
  return String(operand);
}
const toExpression = (operator, ...operands) => operands.map(resolveReference).join(` ${operator} `).replace(/calc/g, "");
const add = (...operands) => `calc(${toExpression("+", ...operands)})`;
const subtract = (...operands) => `calc(${toExpression("-", ...operands)})`;
const multiply = (...operands) => `calc(${toExpression("*", ...operands)})`;
const divide = (...operands) => `calc(${toExpression("/", ...operands)})`;
const negate = (x2) => {
  const value = resolveReference(x2);
  if (value != null && !Number.isNaN(parseFloat(value))) {
    return String(value).startsWith("-") ? String(value).slice(1) : `-${value}`;
  }
  return multiply(value, -1);
};
const calc = Object.assign(
  (x2) => ({
    add: (...operands) => calc(add(x2, ...operands)),
    subtract: (...operands) => calc(subtract(x2, ...operands)),
    multiply: (...operands) => calc(multiply(x2, ...operands)),
    divide: (...operands) => calc(divide(x2, ...operands)),
    negate: () => calc(negate(x2)),
    toString: () => x2.toString()
  }),
  {
    add,
    subtract,
    multiply,
    divide,
    negate
  }
);
function replaceWhiteSpace(value, replaceValue = "-") {
  return value.replace(/\s+/g, replaceValue);
}
function escape(value) {
  const valueStr = replaceWhiteSpace(value.toString());
  return escapeSymbol(escapeDot(valueStr));
}
function escapeDot(value) {
  if (value.includes("\\."))
    return value;
  const isDecimal = !Number.isInteger(parseFloat(value.toString()));
  return isDecimal ? value.replace(".", `\\.`) : value;
}
function escapeSymbol(value) {
  return value.replace(/[!-,/:-@[-^`{-~]/g, "\\$&");
}
function addPrefix(value, prefix2 = "") {
  return [prefix2, value].filter(Boolean).join("-");
}
function toVarReference(name2, fallback) {
  return `var(${name2}${fallback ? `, ${fallback}` : ""})`;
}
function toVarDefinition(value, prefix2 = "") {
  return escape(`--${addPrefix(value, prefix2)}`);
}
function cssVar(name2, fallback, cssVarPrefix) {
  const cssVariable = toVarDefinition(name2, cssVarPrefix);
  return {
    variable: cssVariable,
    reference: toVarReference(cssVariable, fallback)
  };
}
const tokens = [
  "colors",
  "borders",
  "borderWidths",
  "borderStyles",
  "fonts",
  "fontSizes",
  "fontWeights",
  "gradients",
  "letterSpacings",
  "lineHeights",
  "radii",
  "space",
  "shadows",
  "sizes",
  "zIndices",
  "transition",
  "blur",
  "breakpoints"
];
function extractTokens(theme2) {
  const _tokens = tokens;
  return pick(theme2, _tokens);
}
function extractSemanticTokens(theme2) {
  return theme2.semanticTokens;
}
function omitVars(rawTheme) {
  const { __cssMap, __cssVars, __breakpoints, ...cleanTheme } = rawTheme;
  return cleanTheme;
}
function flattenTokens(theme2) {
  const tokens2 = extractTokens(theme2);
  const semanticTokens = extractSemanticTokens(theme2);
  const isSemanticCondition = (key) => (
    // @ts-ignore
    pseudoPropNames.includes(key) || "default" === key
  );
  const result = {};
  walkObject(tokens2, (value, path) => {
    if (value == null)
      return;
    result[path.join(".")] = { isSemantic: false, value };
  });
  walkObject(
    semanticTokens,
    (value, path) => {
      if (value == null)
        return;
      result[path.join(".")] = { isSemantic: true, value };
    },
    {
      stop: (value) => Object.keys(value).every(isSemanticCondition)
    }
  );
  return result;
}
function tokenToCssVar(token2, prefix2) {
  return cssVar(String(token2).replace(/\./g, "-"), void 0, prefix2);
}
function createThemeVars(theme2) {
  var _a;
  const flatTokens = flattenTokens(theme2);
  const cssVarPrefix = (_a = theme2.config) == null ? void 0 : _a.cssVarPrefix;
  let cssVars2 = {};
  const cssMap = {};
  function lookupToken(token2, maybeToken) {
    const scale2 = String(token2).split(".")[0];
    const withScale = [scale2, maybeToken].join(".");
    const resolvedTokenValue = flatTokens[withScale];
    if (!resolvedTokenValue)
      return maybeToken;
    const { reference } = tokenToCssVar(withScale, cssVarPrefix);
    return reference;
  }
  for (const [token2, tokenValue] of Object.entries(flatTokens)) {
    const { isSemantic, value } = tokenValue;
    const { variable, reference } = tokenToCssVar(token2, cssVarPrefix);
    if (!isSemantic) {
      if (token2.startsWith("space")) {
        const keys = token2.split(".");
        const [firstKey, ...referenceKeys] = keys;
        const negativeLookupKey = `${firstKey}.-${referenceKeys.join(".")}`;
        const negativeValue = calc.negate(value);
        const negatedReference = calc.negate(reference);
        cssMap[negativeLookupKey] = {
          value: negativeValue,
          var: variable,
          varRef: negatedReference
        };
      }
      cssVars2[variable] = value;
      cssMap[token2] = {
        value,
        var: variable,
        varRef: reference
      };
      continue;
    }
    const normalizedValue = isObject(value) ? value : { default: value };
    cssVars2 = mergeWith(
      cssVars2,
      Object.entries(normalizedValue).reduce(
        (acc, [conditionAlias, conditionValue]) => {
          if (!conditionValue)
            return acc;
          const tokenReference = lookupToken(token2, `${conditionValue}`);
          if (conditionAlias === "default") {
            acc[variable] = tokenReference;
            return acc;
          }
          const conditionSelector = (pseudoSelectors == null ? void 0 : pseudoSelectors[conditionAlias]) ?? conditionAlias;
          acc[conditionSelector] = { [variable]: tokenReference };
          return acc;
        },
        {}
      )
    );
    cssMap[token2] = {
      value: reference,
      var: variable,
      varRef: reference
    };
  }
  return {
    cssVars: cssVars2,
    cssMap
  };
}
function toCSSVar(rawTheme) {
  const theme2 = omitVars(rawTheme);
  const {
    /**
     * This is more like a dictionary of tokens users will type `green.500`,
     * and their equivalent css variable.
     */
    cssMap,
    /**
     * The extracted css variables will be stored here, and used in
     * the emotion's <Global/> component to attach variables to `:root`
     */
    cssVars: cssVars2
  } = createThemeVars(theme2);
  const defaultCssVars = {
    "--chakra-ring-inset": "var(--chakra-empty,/*!*/ /*!*/)",
    "--chakra-ring-offset-width": "0px",
    "--chakra-ring-offset-color": "#fff",
    "--chakra-ring-color": "rgba(66, 153, 225, 0.6)",
    "--chakra-ring-offset-shadow": "0 0 #0000",
    "--chakra-ring-shadow": "0 0 #0000",
    "--chakra-space-x-reverse": "0",
    "--chakra-space-y-reverse": "0"
  };
  Object.assign(theme2, {
    __cssVars: { ...defaultCssVars, ...cssVars2 },
    __cssMap: cssMap,
    __breakpoints: analyzeBreakpoints(theme2.breakpoints)
  });
  return theme2;
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character = 0;
  while (true) {
    previous = character;
    character = peek();
    if (previous === 38 && character === 12) {
      points[index] = 1;
    }
    if (token(character)) {
      break;
    }
    next();
  }
  return slice(begin, position$1);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character = 44;
  do {
    switch (token(character)) {
      case 0:
        if (character === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position$1 - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character);
        break;
      case 4:
        if (character === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character);
    }
  } while (character = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value;
  var parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length) {
  switch (hash(value, length)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length > 6)
        switch (charat(value, length + 1)) {
          case 109:
            if (charat(value, length + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy$1(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy$1(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy$1(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy$1(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy$1(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node) {
      var dataEmotionAttribute = node.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node);
      node.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node) {
        var attrib = node.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify$1, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var isBrowser$1 = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else if (className) {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser$1 === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag) {
  registerStyles(cache2, serialized, isStringTag);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
var isDevelopment$1 = false;
var EmotionCacheContext = /* @__PURE__ */ React$1.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ forwardRef$1(function(props, ref) {
    var cache2 = useContext(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext = /* @__PURE__ */ React$1.createContext({});
var getTheme$1 = function getTheme(outerTheme, theme2) {
  if (typeof theme2 === "function") {
    var mergedTheme = theme2(outerTheme);
    return mergedTheme;
  }
  return _extends({}, outerTheme, theme2);
};
var createCacheWithTheme = /* @__PURE__ */ weakMemoize(function(outerTheme) {
  return weakMemoize(function(theme2) {
    return getTheme$1(outerTheme, theme2);
  });
});
var ThemeProvider$1 = function ThemeProvider(props) {
  var theme2 = React$1.useContext(ThemeContext);
  if (props.theme !== theme2) {
    theme2 = createCacheWithTheme(theme2)(props.theme);
  }
  return /* @__PURE__ */ React$1.createElement(ThemeContext.Provider, {
    value: theme2
  }, props.children);
};
var hasOwn = {}.hasOwnProperty;
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var _key in props) {
    if (hasOwn.call(props, _key)) {
      newProps[_key] = props[_key];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion$1 = function Insertion(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache2, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache2.registered[cssProp] !== void 0) {
    cssProp = cache2.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache2.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, React$1.useContext(ThemeContext));
  className += cache2.key + "-" + serialized.name;
  var newProps = {};
  for (var _key2 in props) {
    if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment$1) {
      newProps[_key2] = props[_key2];
    }
  }
  newProps.className = className;
  if (ref) {
    newProps.ref = ref;
  }
  return /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement(Insertion$1, {
    cache: cache2,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ React$1.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type2, props) {
  var args = arguments;
  if (props == null || !hasOwn.call(props, "css")) {
    return React$1.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return React$1.createElement.apply(null, createElementArgArray);
};
(function(_jsx) {
  var JSX;
  /* @__PURE__ */ (function(_JSX) {
  })(JSX || (JSX = _jsx.JSX || (_jsx.JSX = {})));
})(jsx || (jsx = {}));
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, React$1.useContext(ThemeContext));
  var sheetRef = React$1.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node !== null) {
      rehydrating = true;
      node.setAttribute("data-emotion", key);
      sheet.hydrate([node]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
function keyframes$1() {
  var insertable = css$1.apply(void 0, arguments);
  var name2 = "animation-" + insertable.name;
  return {
    name: name2,
    styles: "@keyframes " + name2 + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
}
const ColorModeContext = createContext({});
ColorModeContext.displayName = "ColorModeContext";
function useColorMode() {
  const context = useContext(ColorModeContext);
  if (context === void 0) {
    throw new Error("useColorMode must be used within a ColorModeProvider");
  }
  return context;
}
const classNames = {
  light: "chakra-ui-light",
  dark: "chakra-ui-dark"
};
function getColorModeUtils(options = {}) {
  const { preventTransition = true, nonce } = options;
  const utils = {
    setDataset: (value) => {
      const cleanup = preventTransition ? utils.preventTransition() : void 0;
      document.documentElement.dataset.theme = value;
      document.documentElement.style.colorScheme = value;
      cleanup == null ? void 0 : cleanup();
    },
    setClassName(dark) {
      document.body.classList.add(dark ? classNames.dark : classNames.light);
      document.body.classList.remove(dark ? classNames.light : classNames.dark);
    },
    query() {
      return window.matchMedia("(prefers-color-scheme: dark)");
    },
    getSystemTheme(fallback) {
      const dark = utils.query().matches ?? fallback === "dark";
      return dark ? "dark" : "light";
    },
    addListener(fn) {
      const mql = utils.query();
      const listener = (e) => {
        fn(e.matches ? "dark" : "light");
      };
      if (typeof mql.addListener === "function")
        mql.addListener(listener);
      else
        mql.addEventListener("change", listener);
      return () => {
        if (typeof mql.removeListener === "function")
          mql.removeListener(listener);
        else
          mql.removeEventListener("change", listener);
      };
    },
    preventTransition() {
      const css2 = document.createElement("style");
      css2.appendChild(
        document.createTextNode(
          `*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}`
        )
      );
      if (nonce !== void 0) {
        css2.nonce = nonce;
      }
      document.head.appendChild(css2);
      return () => {
        (() => window.getComputedStyle(document.body))();
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            document.head.removeChild(css2);
          });
        });
      };
    }
  };
  return utils;
}
const STORAGE_KEY = "chakra-ui-color-mode";
function createLocalStorageManager(key) {
  return {
    ssr: false,
    type: "localStorage",
    get(init) {
      if (!(globalThis == null ? void 0 : globalThis.document))
        return init;
      let value;
      try {
        value = localStorage.getItem(key) || init;
      } catch (e) {
      }
      return value || init;
    },
    set(value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
      }
    }
  };
}
const localStorageManager = createLocalStorageManager(STORAGE_KEY);
const noop$1 = () => {
};
const useSafeLayoutEffect$1 = isBrowser$2() ? useLayoutEffect : useEffect;
function getTheme2(manager, fallback) {
  return manager.type === "cookie" && manager.ssr ? manager.get(fallback) : fallback;
}
const ColorModeProvider = withEmotionCache(function ColorModeProvider2(props, cache2) {
  const {
    value,
    children,
    options: {
      useSystemColorMode,
      initialColorMode,
      disableTransitionOnChange
    } = {},
    colorModeManager = localStorageManager
  } = props;
  const defaultColorMode = initialColorMode === "dark" ? "dark" : "light";
  const [colorMode, rawSetColorMode] = useState(
    () => getTheme2(colorModeManager, defaultColorMode)
  );
  const [resolvedColorMode, setResolvedColorMode] = useState(
    () => getTheme2(colorModeManager)
  );
  const { getSystemTheme, setClassName, setDataset, addListener } = useMemo(
    () => getColorModeUtils({
      preventTransition: disableTransitionOnChange,
      nonce: cache2 == null ? void 0 : cache2.nonce
    }),
    [disableTransitionOnChange, cache2 == null ? void 0 : cache2.nonce]
  );
  const resolvedValue = initialColorMode === "system" && !colorMode ? resolvedColorMode : colorMode;
  const setColorMode = useCallback(
    (value2) => {
      const resolved = value2 === "system" ? getSystemTheme() : value2;
      rawSetColorMode(resolved);
      setClassName(resolved === "dark");
      setDataset(resolved);
      colorModeManager.set(resolved);
    },
    [colorModeManager, getSystemTheme, setClassName, setDataset]
  );
  useSafeLayoutEffect$1(() => {
    if (initialColorMode === "system") {
      setResolvedColorMode(getSystemTheme());
    }
  }, []);
  useEffect(() => {
    const managerValue = colorModeManager.get();
    if (managerValue) {
      setColorMode(managerValue);
      return;
    }
    if (initialColorMode === "system") {
      setColorMode("system");
      return;
    }
    setColorMode(defaultColorMode);
  }, [colorModeManager, defaultColorMode, initialColorMode, setColorMode]);
  const toggleColorMode = useCallback(() => {
    setColorMode(resolvedValue === "dark" ? "light" : "dark");
  }, [resolvedValue, setColorMode]);
  useEffect(() => {
    if (!useSystemColorMode)
      return;
    return addListener(setColorMode);
  }, [useSystemColorMode, addListener, setColorMode]);
  const context = useMemo(
    () => ({
      colorMode: value ?? resolvedValue,
      toggleColorMode: value ? noop$1 : toggleColorMode,
      setColorMode: value ? noop$1 : setColorMode,
      forced: value !== void 0
    }),
    [resolvedValue, toggleColorMode, setColorMode, value]
  );
  return /* @__PURE__ */ jsx$1(ColorModeContext.Provider, { value: context, children });
});
ColorModeProvider.displayName = "ColorModeProvider";
function LightMode(props) {
  const context = useMemo(
    () => ({
      colorMode: "light",
      toggleColorMode: noop$1,
      setColorMode: noop$1,
      forced: true
    }),
    []
  );
  return /* @__PURE__ */ jsx$1(ColorModeContext.Provider, { value: context, ...props });
}
LightMode.displayName = "LightMode";
const css = String.raw;
const vhPolyfill = css`
  :root,
  :host {
    --chakra-vh: 100vh;
  }

  @supports (height: -webkit-fill-available) {
    :root,
    :host {
      --chakra-vh: -webkit-fill-available;
    }
  }

  @supports (height: -moz-fill-available) {
    :root,
    :host {
      --chakra-vh: -moz-fill-available;
    }
  }

  @supports (height: 100dvh) {
    :root,
    :host {
      --chakra-vh: 100dvh;
    }
  }
`;
const CSSPolyfill = () => /* @__PURE__ */ jsx$1(Global, { styles: vhPolyfill });
const CSSReset = ({ scope = "" }) => /* @__PURE__ */ jsx$1(
  Global,
  {
    styles: css`
      html {
        line-height: 1.5;
        -webkit-text-size-adjust: 100%;
        font-family: system-ui, sans-serif;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
        -moz-osx-font-smoothing: grayscale;
        touch-action: manipulation;
      }

      body {
        position: relative;
        min-height: 100%;
        margin: 0;
        font-feature-settings: "kern";
      }

      ${scope} :where(*, *::before, *::after) {
        border-width: 0;
        border-style: solid;
        box-sizing: border-box;
        word-wrap: break-word;
      }

      main {
        display: block;
      }

      ${scope} hr {
        border-top-width: 1px;
        box-sizing: content-box;
        height: 0;
        overflow: visible;
      }

      ${scope} :where(pre, code, kbd,samp) {
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, monospace;
        font-size: 1em;
      }

      ${scope} a {
        background-color: transparent;
        color: inherit;
        text-decoration: inherit;
      }

      ${scope} abbr[title] {
        border-bottom: none;
        text-decoration: underline;
        -webkit-text-decoration: underline dotted;
        text-decoration: underline dotted;
      }

      ${scope} :where(b, strong) {
        font-weight: bold;
      }

      ${scope} small {
        font-size: 80%;
      }

      ${scope} :where(sub,sup) {
        font-size: 75%;
        line-height: 0;
        position: relative;
        vertical-align: baseline;
      }

      ${scope} sub {
        bottom: -0.25em;
      }

      ${scope} sup {
        top: -0.5em;
      }

      ${scope} img {
        border-style: none;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        font-family: inherit;
        font-size: 100%;
        line-height: 1.15;
        margin: 0;
      }

      ${scope} :where(button, input) {
        overflow: visible;
      }

      ${scope} :where(button, select) {
        text-transform: none;
      }

      ${scope} :where(
          button::-moz-focus-inner,
          [type="button"]::-moz-focus-inner,
          [type="reset"]::-moz-focus-inner,
          [type="submit"]::-moz-focus-inner
        ) {
        border-style: none;
        padding: 0;
      }

      ${scope} fieldset {
        padding: 0.35em 0.75em 0.625em;
      }

      ${scope} legend {
        box-sizing: border-box;
        color: inherit;
        display: table;
        max-width: 100%;
        padding: 0;
        white-space: normal;
      }

      ${scope} progress {
        vertical-align: baseline;
      }

      ${scope} textarea {
        overflow: auto;
      }

      ${scope} :where([type="checkbox"], [type="radio"]) {
        box-sizing: border-box;
        padding: 0;
      }

      ${scope} input[type="number"]::-webkit-inner-spin-button,
      ${scope} input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none !important;
      }

      ${scope} input[type="number"] {
        -moz-appearance: textfield;
      }

      ${scope} input[type="search"] {
        -webkit-appearance: textfield;
        outline-offset: -2px;
      }

      ${scope} input[type="search"]::-webkit-search-decoration {
        -webkit-appearance: none !important;
      }

      ${scope} ::-webkit-file-upload-button {
        -webkit-appearance: button;
        font: inherit;
      }

      ${scope} details {
        display: block;
      }

      ${scope} summary {
        display: list-item;
      }

      template {
        display: none;
      }

      [hidden] {
        display: none !important;
      }

      ${scope} :where(
          blockquote,
          dl,
          dd,
          h1,
          h2,
          h3,
          h4,
          h5,
          h6,
          hr,
          figure,
          p,
          pre
        ) {
        margin: 0;
      }

      ${scope} button {
        background: transparent;
        padding: 0;
      }

      ${scope} fieldset {
        margin: 0;
        padding: 0;
      }

      ${scope} :where(ol, ul) {
        margin: 0;
        padding: 0;
      }

      ${scope} textarea {
        resize: vertical;
      }

      ${scope} :where(button, [role="button"]) {
        cursor: pointer;
      }

      ${scope} button::-moz-focus-inner {
        border: 0 !important;
      }

      ${scope} table {
        border-collapse: collapse;
      }

      ${scope} :where(h1, h2, h3, h4, h5, h6) {
        font-size: inherit;
        font-weight: inherit;
      }

      ${scope} :where(button, input, optgroup, select, textarea) {
        padding: 0;
        line-height: inherit;
        color: inherit;
      }

      ${scope} :where(img, svg, video, canvas, audio, iframe, embed, object) {
        display: block;
      }

      ${scope} :where(img, video) {
        max-width: 100%;
        height: auto;
      }

      [data-js-focus-visible]
        :focus:not([data-focus-visible-added]):not(
          [data-focus-visible-disabled]
        ) {
        outline: none;
        box-shadow: none;
      }

      ${scope} select::-ms-expand {
        display: none;
      }

      ${vhPolyfill}
    `
  }
);
function ThemeProvider2(props) {
  const { cssVarsRoot, theme: theme2, children } = props;
  const computedTheme = useMemo(() => toCSSVar(theme2), [theme2]);
  return /* @__PURE__ */ jsxs(ThemeProvider$1, { theme: computedTheme, children: [
    /* @__PURE__ */ jsx$1(CSSVars, { root: cssVarsRoot }),
    children
  ] });
}
function CSSVars({ root = ":host, :root" }) {
  const selector = [root, `[data-theme]`].join(",");
  return /* @__PURE__ */ jsx$1(Global, { styles: (theme2) => ({ [selector]: theme2.__cssVars }) });
}
createContext$1({
  name: "StylesContext",
  errorMessage: "useStyles: `styles` is undefined. Seems you forgot to wrap the components in `<StylesProvider />` "
});
function createStylesContext(componentName) {
  return createContext$1({
    name: `${componentName}StylesContext`,
    errorMessage: `useStyles: "styles" is undefined. Seems you forgot to wrap the components in "<${componentName} />" `
  });
}
function GlobalStyle() {
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsx$1(
    Global,
    {
      styles: (theme2) => {
        const styleObjectOrFn = memoizedGet$1(theme2, "styles.global");
        const globalStyles = runIfFn(styleObjectOrFn, { theme: theme2, colorMode });
        if (!globalStyles)
          return void 0;
        const styles2 = css$2(globalStyles)(theme2);
        return styles2;
      }
    }
  );
}
const [PortalManagerContextProvider, usePortalManager] = createContext$1({
  strict: false,
  name: "PortalManagerContext"
});
function PortalManager(props) {
  const { children, zIndex } = props;
  return /* @__PURE__ */ jsx$1(PortalManagerContextProvider, { value: { zIndex }, children });
}
PortalManager.displayName = "PortalManager";
const EnvironmentContext = createContext({
  getDocument() {
    return document;
  },
  getWindow() {
    return window;
  }
});
EnvironmentContext.displayName = "EnvironmentContext";
function useEnvironment({ defer } = {}) {
  const [, forceUpdate] = useReducer((c) => c + 1, 0);
  useSafeLayoutEffect$2(() => {
    if (!defer)
      return;
    forceUpdate();
  }, [defer]);
  return useContext(EnvironmentContext);
}
function EnvironmentProvider(props) {
  const { children, environment: environmentProp, disabled } = props;
  const ref = useRef(null);
  const context = useMemo(() => {
    if (environmentProp)
      return environmentProp;
    return {
      getDocument: () => {
        var _a;
        return ((_a = ref.current) == null ? void 0 : _a.ownerDocument) ?? document;
      },
      getWindow: () => {
        var _a;
        return ((_a = ref.current) == null ? void 0 : _a.ownerDocument.defaultView) ?? window;
      }
    };
  }, [environmentProp]);
  const showSpan = !disabled || !environmentProp;
  return /* @__PURE__ */ jsxs(EnvironmentContext.Provider, { value: context, children: [
    children,
    showSpan && /* @__PURE__ */ jsx$1("span", { id: "__chakra_env", hidden: true, ref })
  ] });
}
EnvironmentProvider.displayName = "EnvironmentProvider";
const Provider = (props) => {
  const {
    children,
    colorModeManager,
    portalZIndex,
    resetScope,
    resetCSS = true,
    theme: theme2 = {},
    environment,
    cssVarsRoot,
    disableEnvironment,
    disableGlobalStyle
  } = props;
  const _children = /* @__PURE__ */ jsx$1(
    EnvironmentProvider,
    {
      environment,
      disabled: disableEnvironment,
      children
    }
  );
  return /* @__PURE__ */ jsx$1(ThemeProvider2, { theme: theme2, cssVarsRoot, children: /* @__PURE__ */ jsxs(
    ColorModeProvider,
    {
      colorModeManager,
      options: theme2.config,
      children: [
        resetCSS ? /* @__PURE__ */ jsx$1(CSSReset, { scope: resetScope }) : /* @__PURE__ */ jsx$1(CSSPolyfill, {}),
        !disableGlobalStyle && /* @__PURE__ */ jsx$1(GlobalStyle, {}),
        portalZIndex ? /* @__PURE__ */ jsx$1(PortalManager, { zIndex: portalZIndex, children: _children }) : _children
      ]
    }
  ) });
};
const MotionConfigContext = createContext({
  transformPagePoint: (p) => p,
  isStatic: false,
  reducedMotion: "never"
});
const MotionContext = createContext({});
function useVisualElementContext() {
  return useContext(MotionContext).visualElement;
}
const PresenceContext = createContext(null);
const isBrowser = typeof document !== "undefined";
const useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect;
const LazyContext = createContext({ strict: false });
function useVisualElement(Component, visualState, props, createVisualElement) {
  const parent = useVisualElementContext();
  const lazyContext = useContext(LazyContext);
  const presenceContext = useContext(PresenceContext);
  const reducedMotionConfig = useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = useRef();
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceId: presenceContext ? presenceContext.id : void 0,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  useIsomorphicLayoutEffect(() => {
    visualElement && visualElement.render();
  });
  const useAnimateChangesEffect = window.HandoffAppearAnimations ? useIsomorphicLayoutEffect : useEffect;
  useAnimateChangesEffect(() => {
    if (visualElement && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  return visualElement;
}
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance);
      if (visualElement) {
        instance ? visualElement.mount(instance) : visualElement.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}
const variantProps$1 = [
  "initial",
  "animate",
  "exit",
  "whileHover",
  "whileDrag",
  "whileTap",
  "whileFocus",
  "whileInView"
];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps$1.some((name2) => isVariantLabel(props[name2]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const createDefinition = (propNames2) => ({
  isEnabled: (props) => propNames2.some((name2) => !!props[name2])
});
const featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features) {
  for (const key in features) {
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}
function useConstant(init) {
  const ref = useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
let id$1 = 1;
function useProjectionId() {
  return useConstant(() => {
    if (globalProjectionState.hasEverUpdated) {
      return id$1++;
    }
  });
}
const LayoutGroupContext = createContext({});
class VisualElementHandler extends React__default.Component {
  /**
   * Update visual element props as soon as we know this update is going to be commited.
   */
  getSnapshotBeforeUpdate() {
    const { visualElement, props } = this.props;
    if (visualElement)
      visualElement.setProps(props);
    return null;
  }
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
const SwitchLayoutGroupContext = createContext({});
const motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    let features = null;
    const context = useCreateMotionContext(props);
    const projectionId = isStatic ? void 0 : useProjectionId();
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
      const lazyStrictMode = useContext(LazyContext).strict;
      const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);
      if (context.visualElement) {
        features = context.visualElement.loadFeatures(
          // Note: Pass the full new combined props to correctly re-render dynamic feature components.
          configAndProps,
          lazyStrictMode,
          preloadedFeatures,
          projectionId,
          projectionNodeConstructor || featureDefinitions.projectionNodeConstructor,
          initialLayoutGroupConfig
        );
      }
    }
    return React$1.createElement(
      VisualElementHandler,
      { visualElement: context.visualElement, props: configAndProps },
      features,
      React$1.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))
    );
  }
  const ForwardRefComponent = forwardRef$1(MotionComponent);
  ForwardRefComponent[motionComponentSymbol] = Component;
  return ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom;
  }
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom(key));
      }
      return componentCache.get(key);
    }
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component)
  ) {
    return true;
  }
  return false;
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
const transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key, { layout: layout2, layoutId }) {
  return transformProps.has(key) || key.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}
const isMotionValue = (value) => !!(value === null || value === void 0 ? void 0 : value.getVelocity);
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const sortTransformProps = (a, b) => transformPropOrder.indexOf(a) - transformPropOrder.indexOf(b);
function buildTransform({ transform: transform2, transformKeys: transformKeys2 }, { enableHardwareAcceleration = true, allowTransformNone = true }, transformIsDefault, transformTemplate2) {
  let transformString = "";
  transformKeys2.sort(sortTransformProps);
  for (const key of transformKeys2) {
    transformString += `${translateAlias[key] || key}(${transform2[key]}) `;
  }
  if (enableHardwareAcceleration && !transform2.z) {
    transformString += "translateZ(0)";
  }
  transformString = transformString.trim();
  if (transformTemplate2) {
    transformString = transformTemplate2(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function isCSSVariable$1(key) {
  return key.startsWith("--");
}
const getValueAsType = (value, type2) => {
  return type2 && typeof value === "number" ? type2.transform(value) : value;
};
const clamp = (min, max, v2) => Math.min(Math.max(v2, min), max);
const number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
const alpha = {
  ...number,
  transform: (v2) => clamp(0, 1, v2)
};
const scale$1 = {
  ...number,
  default: 1
};
const sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;
const floatRegex = /(-)?([\d]*\.?[\d])+/g;
const colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi;
const singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString(v2) {
  return typeof v2 === "string";
}
const createUnitType = (unit) => ({
  test: (v2) => isString(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
const degrees = createUnitType("deg");
const percent = createUnitType("%");
const px = createUnitType("px");
const vh = createUnitType("vh");
const vw = createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale: scale$1,
  scaleX: scale$1,
  scaleY: scale$1,
  scaleZ: scale$1,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state2, latestValues, options, transformTemplate2) {
  const { style, vars, transform: transform2, transformKeys: transformKeys2, transformOrigin: transformOrigin2 } = state2;
  transformKeys2.length = 0;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  let transformIsNone = true;
  for (const key in latestValues) {
    const value = latestValues[key];
    if (isCSSVariable$1(key)) {
      vars[key] = value;
      continue;
    }
    const valueType = numberValueTypes[key];
    const valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key)) {
      hasTransform2 = true;
      transform2[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== (valueType.default || 0))
        transformIsNone = false;
    } else if (key.startsWith("origin")) {
      hasTransformOrigin = true;
      transformOrigin2[key] = valueAsType;
    } else {
      style[key] = valueAsType;
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate2) {
      style.transform = buildTransform(state2, options, transformIsNone, transformTemplate2);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin2;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformKeys: [],
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({ transformTemplate: transformTemplate2 }, visualState, isStatic) {
  return useMemo(() => {
    const state2 = createHtmlRenderState();
    buildHTMLStyles(state2, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate2);
    return Object.assign({}, state2.vars, state2.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState, isStatic));
  return props.transformValues ? props.transformValues(style) : style;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {};
  const style = useStyle(props, visualState, isStatic);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  htmlProps.style = style;
  return htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "viewport"
]);
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || validMotionProps.has(key);
}
let shouldForward = (key) => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key) => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a) {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    if (key === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}
function calcOrigin$1(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state2, {
  attrX,
  attrY,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate2) {
  buildHTMLStyles(state2, latest, options, transformTemplate2);
  if (isSVGTag2) {
    if (state2.style.viewBox) {
      state2.attrs.viewBox = state2.style.viewBox;
    }
    return;
  }
  state2.attrs = state2.style;
  state2.style = {};
  const { attrs, style, dimensions } = state2;
  if (attrs.transform) {
    if (dimensions)
      style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
const isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = useMemo(() => {
    const state2 = createSvgRenderState();
    buildSVGAttrs(state2, visualState, { enableHardwareAcceleration: false }, isSVGTag(Component), props.transformTemplate);
    return {
      ...state2.attrs,
      style: { ...state2.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, projectionId, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = {
      ...filteredProps,
      ...visualProps,
      ref
    };
    const { children } = props;
    const renderedChildren = useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
const camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
const isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};
const isCustomValue = (v2) => {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
const resolveFinalValueInKeyframes = (v2) => {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state2 = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  if (onMount) {
    state2.mount = (instance) => onMount(props, instance, state2);
  }
  return state2;
}
const makeUseVisualState = (config2) => (props, isStatic) => {
  const context = useContext(MotionContext);
  const presenceContext = useContext(PresenceContext);
  const make = () => makeState(config2, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate2 === void 0)
      animate2 = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list2 = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list2.forEach((definition) => {
      const resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      const { transitionEnd, transition: transition2, ...target } = resolved;
      for (const key in target) {
        let valueTarget = target[key];
        if (Array.isArray(valueTarget)) {
          const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index];
        }
        if (valueTarget !== null) {
          values[key] = valueTarget;
        }
      }
      for (const key in transitionEnd)
        values[key] = transitionEnd[key];
    });
  }
  return values;
}
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, isSVGTag(instance.tagName), props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component, { forwardMotionProps = false }, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return {
    ...baseConfig,
    preloadedFeatures,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    projectionNodeConstructor,
    Component
  };
}
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function useDomEvent(ref, eventName, handler, options) {
  useEffect(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}
function useFocusGesture({ whileFocus, visualElement }) {
  const { animationState } = visualElement;
  const onFocus = useCallback(() => {
    animationState && animationState.setActive(AnimationType.Focus, true);
  }, [animationState]);
  const onBlur = useCallback(() => {
    animationState && animationState.setActive(AnimationType.Focus, false);
  }, [animationState]);
  useDomEvent(visualElement, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement, "blur", whileFocus ? onBlur : void 0);
}
const isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, eventName, handler && addPointerInfo(handler), options);
}
function createLock(name2) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    if (lock === null) {
      lock = name2;
      return openLock;
    }
    return false;
  };
}
const globalHorizontalLock = createLock("dragHorizontal");
const globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    const openHorizontal = globalHorizontalLock();
    const openVertical = globalVerticalLock();
    if (openHorizontal && openVertical) {
      lock = () => {
        openHorizontal();
        openVertical();
      };
    } else {
      if (openHorizontal)
        openHorizontal();
      if (openVertical)
        openVertical();
    }
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}
function createHoverEvent(visualElement, isActive, applyVariants, callback) {
  return (event, info) => {
    if (event.type === "touch" || isDragActive())
      return;
    if (applyVariants && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Hover, isActive);
    }
    callback && callback(event, info);
  };
}
function useHoverGesture({ onHoverStart, onHoverEnd, whileHover, visualElement }) {
  usePointerEvent(visualElement, "pointerenter", useMemo(() => {
    return onHoverStart || whileHover ? createHoverEvent(visualElement, true, Boolean(whileHover), onHoverStart) : void 0;
  }, [onHoverStart, Boolean(whileHover), visualElement]), { passive: !onHoverStart });
  usePointerEvent(visualElement, "pointerleave", useMemo(() => {
    return onHoverEnd || whileHover ? createHoverEvent(visualElement, false, Boolean(whileHover), onHoverEnd) : void 0;
  }, [onHoverStart, Boolean(whileHover), visualElement]), { passive: !onHoverEnd });
}
const isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};
function useUnmountEffect(callback) {
  return useEffect(() => () => callback(), []);
}
const combineFunctions = (a, b) => (v2) => b(a(v2));
const pipe$1 = (...transformers) => transformers.reduce(combineFunctions);
function useTapGesture({ onTap, onTapStart, onTapCancel, whileTap, visualElement, ...props }) {
  const hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  const isPressing = useRef(false);
  const cancelPointerEndListeners = useRef(null);
  const eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || props["onPointerDown"])
  };
  function removePointerEndListener() {
    cancelPointerEndListeners.current && cancelPointerEndListeners.current();
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    removePointerEndListener();
    isPressing.current = false;
    const latestProps = visualElement.getProps();
    if (latestProps.whileTap && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Tap, false);
    }
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    var _a, _b, _c, _d;
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement.current, event.target) ? (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info) : (_d = (_c = visualElement.getProps()).onTap) === null || _d === void 0 ? void 0 : _d.call(_c, event, info);
  }
  function onPointerCancel(event, info) {
    var _a, _b;
    if (!checkPointerEnd())
      return;
    (_b = (_a = visualElement.getProps()).onTapCancel) === null || _b === void 0 ? void 0 : _b.call(_a, event, info);
  }
  const startPress = useCallback((event, info) => {
    var _a;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe$1(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    const latestProps = visualElement.getProps();
    if (latestProps.whileTap && visualElement.animationState) {
      visualElement.animationState.setActive(AnimationType.Tap, true);
    }
    (_a = latestProps.onTapStart) === null || _a === void 0 ? void 0 : _a.call(latestProps, event, info);
  }, [Boolean(onTapStart), visualElement]);
  usePointerEvent(visualElement, "pointerdown", hasPressListeners ? startPress : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}
const observerCallbacks = /* @__PURE__ */ new WeakMap();
const observers = /* @__PURE__ */ new WeakMap();
const fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
function useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {} }) {
  const state2 = useRef({
    hasEnteredView: false,
    isInView: false
  });
  let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state2.current.hasEnteredView)
    shouldObserve = false;
  const useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state2.current, visualElement, viewport);
}
const thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state2, visualElement, { root, margin: rootMargin, amount = "some", once }) {
  useEffect(() => {
    if (!shouldObserve || !visualElement.current)
      return;
    const options = {
      root: root === null || root === void 0 ? void 0 : root.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const intersectionCallback = (entry) => {
      const { isIntersecting } = entry;
      if (state2.isInView === isIntersecting)
        return;
      state2.isInView = isIntersecting;
      if (once && !isIntersecting && state2.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state2.hasEnteredView = true;
      }
      if (visualElement.animationState) {
        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);
      }
      const props = visualElement.getProps();
      const callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(visualElement.current, options, intersectionCallback);
  }, [shouldObserve, root, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state2, visualElement, { fallback = true }) {
  useEffect(() => {
    if (!shouldObserve || !fallback)
      return;
    requestAnimationFrame(() => {
      state2.hasEnteredView = true;
      const { onViewportEnter } = visualElement.getProps();
      onViewportEnter && onViewportEnter(null);
      if (visualElement.animationState) {
        visualElement.animationState.setActive(AnimationType.InView, true);
      }
    });
  }, [shouldObserve]);
}
const makeRenderlessComponent = (hook) => (props) => {
  hook(props);
  return null;
};
const gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};
function usePresence() {
  const context = useContext(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent: isPresent2, onExitComplete, register } = context;
  const id2 = useId$1();
  useEffect(() => register(id2), []);
  const safeToRemove = () => onExitComplete && onExitComplete(id2);
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}
function useIsPresent() {
  return isPresent(useContext(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
function shallowCompare(next2, prev) {
  if (!Array.isArray(prev))
    return false;
  const prevLength = prev.length;
  if (prevLength !== next2.length)
    return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next2[i])
      return false;
  }
  return true;
}
const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
const frameData = {
  delta: 0,
  timestamp: 0
};
const defaultTimestep = 1 / 60 * 1e3;
const getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
const onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer.indexOf(callback) === -1) {
        buffer.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      const index = toRunNextFrame.indexOf(callback);
      if (index !== -1)
        toRunNextFrame.splice(index, 1);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i = 0; i < numToRun; i++) {
          const callback = toRun[i];
          callback(frameData2);
          if (toKeepAlive.has(callback)) {
            step.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}
const maxElapsed = 40;
let useDefaultElapsed = true;
let runNextFrame = false;
let isProcessing = false;
const stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
const steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
const sync = stepsOrder.reduce((acc, key) => {
  const step = steps[key];
  acc[key] = (process, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step.schedule(process, keepAlive, immediate);
  };
  return acc;
}, {});
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
const flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frameData);
  return acc;
}, {});
const processStep = (stepId) => steps[stepId].process(frameData);
const processFrame = (timestamp) => {
  runNextFrame = false;
  frameData.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frameData.timestamp, maxElapsed), 1);
  frameData.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
const startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1)
    arr.splice(index, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a, b, c);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        const handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "8.5.5";
    this.timeDelta = 0;
    this.lastUpdated = 0;
    this.canTrackVelocity = false;
    this.events = {};
    this.updateAndNotify = (v2, render2 = true) => {
      this.prev = this.current;
      this.current = v2;
      const { delta, timestamp } = frameData;
      if (this.lastUpdated !== timestamp) {
        this.timeDelta = delta;
        this.lastUpdated = timestamp;
        sync.postRender(this.scheduleVelocityCheck);
      }
      if (this.prev !== this.current && this.events.change) {
        this.events.change.notify(this.current);
      }
      if (this.events.velocityChange) {
        this.events.velocityChange.notify(this.getVelocity());
      }
      if (render2 && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.scheduleVelocityCheck = () => sync.postRender(this.velocityCheck);
    this.velocityCheck = ({ timestamp }) => {
      if (timestamp !== this.lastUpdated) {
        this.prev = this.current;
        if (this.events.velocityChange) {
          this.events.velocityChange.notify(this.getVelocity());
        }
      }
    };
    this.hasAnimated = false;
    this.prev = this.current = init;
    this.canTrackVelocity = isFloat(this.current);
    this.owner = options.owner;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        sync.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render2 = true) {
    if (!render2 || !this.passiveEffect) {
      this.updateAndNotify(v2, render2);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = prev;
    this.timeDelta = delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    return this.canTrackVelocity ? (
      // These casts could be avoided if parseFloat would be typed better
      velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
    ) : 0;
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve) || null;
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    this.animation = null;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const isColorString = (type2, testProp) => (v2) => {
  return Boolean(isString(v2) && singleColorRegex.test(v2) && v2.startsWith(type2) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
const splitColor = (aName, bName, cName) => (v2) => {
  if (!isString(v2))
    return v2;
  const [a, b, c, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};
const clampRgbUnit = (v2) => clamp(0, 255, v2);
const rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
const rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v2) {
  let r = "";
  let g2 = "";
  let b = "";
  let a = "";
  if (v2.length > 5) {
    r = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b = v2.substring(5, 7);
    a = v2.substring(7, 9);
  } else {
    r = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b = v2.substring(3, 4);
    a = v2.substring(4, 5);
    r += r;
    g2 += g2;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};
const colorToken = "${c}";
const numberToken = "${n}";
function test(v2) {
  var _a, _b;
  return isNaN(v2) && isString(v2) && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
function analyseComplexValue(v2) {
  if (typeof v2 === "number")
    v2 = `${v2}`;
  const values = [];
  let numColors = 0;
  let numNumbers = 0;
  const colors2 = v2.match(colorRegex);
  if (colors2) {
    numColors = colors2.length;
    v2 = v2.replace(colorRegex, colorToken);
    values.push(...colors2.map(color.parse));
  }
  const numbers = v2.match(floatRegex);
  if (numbers) {
    numNumbers = numbers.length;
    v2 = v2.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, numNumbers, tokenised: v2 };
}
function parse(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { values, numColors, tokenised } = analyseComplexValue(source);
  const numValues = values.length;
  return (v2) => {
    let output = tokenised;
    for (let i = 0; i < numValues; i++) {
      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v2[i]) : sanitize(v2[i]));
    }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parse(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = { test, parse, createTransformer, getAnimatableNone: getAnimatableNone$1 };
const maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name2, value] = v2.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name2 + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g;
const filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
const getDefaultValueType = (key) => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  var _a;
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);
}
const testValueType = (v2) => (type2) => type2.test(v2);
const auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
const findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));
const valueTypes = [...dimensionValueTypes, color, complex];
const findValueType = (v2) => valueTypes.find(testValueType(v2));
function getCurrent(visualElement) {
  const current = {};
  visualElement.values.forEach((value, key) => current[key] = value.get());
  return current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  visualElement.values.forEach((value, key) => velocity[key] = value.getVelocity());
  return velocity;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition: transition2 = {}, ...target } = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {};
  target = { ...target, ...transitionEnd };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
function checkTargetForNewValues(visualElement, target, origin) {
  var _a, _b;
  const newValueKeys = Object.keys(target).filter((key) => !visualElement.hasValue(key));
  const numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (let i = 0; i < numNewValues; i++) {
    const key = newValueKeys[i];
    const targetValue = target[key];
    let value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone(key, targetValue);
    }
    visualElement.addValue(key, motionValue(value, { owner: visualElement }));
    if (origin[key] === void 0) {
      origin[key] = value;
    }
    if (value !== null)
      visualElement.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition2) {
  if (!transition2)
    return;
  const valueTransition = transition2[key] || transition2["default"] || transition2;
  return valueTransition.from;
}
function getOrigin(target, transition2, visualElement) {
  var _a;
  const origin = {};
  for (const key in target) {
    const transitionOrigin = getOriginFromTransition(key, transition2);
    origin[key] = transitionOrigin !== void 0 ? transitionOrigin : (_a = visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.get();
  }
  return origin;
}
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
const secondsToMilliseconds = (seconds) => seconds * 1e3;
const instantAnimationState = {
  current: false
};
const mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;
const reverseEasing = (easing) => (p) => 1 - easing(1 - p);
const easeIn = (p) => p * p;
const easeOut = reverseEasing(easeIn);
const easeInOut = mirrorEasing(easeIn);
const mix = (from2, to, progress2) => -progress2 * from2 + progress2 * to + from2;
function hueToRgb(p, q2, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p + (q2 - p) * 6 * t2;
  if (t2 < 1 / 2)
    return q2;
  if (t2 < 2 / 3)
    return p + (q2 - p) * (2 / 3 - t2) * 6;
  return p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q2;
    red = hueToRgb(p, q2, hue + 1 / 3);
    green = hueToRgb(p, q2, hue);
    blue = hueToRgb(p, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}
const mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  return Math.sqrt(Math.max(0, v2 * (to * to - fromExpo) + fromExpo));
};
const colorTypes = [hex, rgba, hsla];
const getColorType = (v2) => colorTypes.find((type2) => type2.test(v2));
function asRGBA(color2) {
  const type2 = getColorType(color2);
  invariant$2(Boolean(type2), `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
  let model = type2.parse(color2);
  if (type2 === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mix(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba.transform(blended);
  };
};
function getMixer(origin, target) {
  if (typeof origin === "number") {
    return (v2) => mix(origin, target, v2);
  } else if (color.test(origin)) {
    return mixColor(origin, target);
  } else {
    return mixComplex(origin, target);
  }
}
const mixArray = (from2, to) => {
  const output = [...from2];
  const numValues = output.length;
  const blendValue = from2.map((fromThis, i) => getMixer(fromThis, to[i]));
  return (v2) => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](v2);
    }
    return output;
  };
};
const mixObject = (origin, target) => {
  const output = { ...origin, ...target };
  const blendValue = {};
  for (const key in output) {
    if (origin[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin[key], target[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
};
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.numColors === targetStats.numColors && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe$1(mixArray(originStats.values, targetStats.values), template);
  } else {
    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return (p) => `${p > 0 ? target : origin}`;
  }
};
const progress$1 = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};
const mixNumber = (from2, to) => (p) => mix(from2, to, p);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    if (color.test(v2)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
  return mixNumber;
}
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] : ease;
      mixer = pipe$1(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant$2(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant$2(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v2 < input[i + 1])
          break;
      }
    }
    const progressInRange = progress$1(input[i], input[i + 1], v2);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp(input[0], input[inputLength - 1], v2)) : interpolator;
}
const noop = (any) => any;
const calcBezier = (t2, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t2 + (3 * a2 - 6 * a1)) * t2 + 3 * a1) * t2;
const subdivisionPrecision = 1e-7;
const subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}
const circIn = (p) => 1 - Math.sin(Math.acos(p));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circOut);
const backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = reverseEasing(backOut);
const backInOut = mirrorEasing(backIn);
const anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
const easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant$2(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant$2(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
    return easingLookup[definition];
  }
  return definition;
};
const isEasingArray = (ease) => {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o) => o * duration);
}
function keyframes({ keyframes: keyframeValues, ease = easeInOut, times, duration = 300 }) {
  keyframeValues = [...keyframeValues];
  const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  const state2 = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  function createInterpolator() {
    return interpolate(absoluteTimes, keyframeValues, {
      ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state2.value = interpolator(t2);
      state2.done = t2 >= duration;
      return state2;
    },
    flipTarget: () => {
      keyframeValues.reverse();
      interpolator = createInterpolator();
    }
  };
}
const safeMin = 1e-3;
const minDuration = 0.01;
const maxDuration = 10;
const minDamping = 0.05;
const maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);
  duration = clamp(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq2, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - a / b * c;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = (undampedFreq2) => {
      const a = Math.exp(-undampedFreq2 * duration);
      const b = (velocity - undampedFreq2) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      velocity: 0,
      mass: 1
    };
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
const velocitySampleDuration = 5;
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  let origin = keyframes2[0];
  let target = keyframes2[keyframes2.length - 1];
  const state2 = { done: false, value: origin };
  const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let initialVelocity = velocity ? -(velocity / 1e3) : 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  function createSpring() {
    const initialDelta = target - origin;
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    const isGranularScale = Math.abs(initialDelta) < 5;
    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);
    restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => target - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        let currentVelocity = initialVelocity;
        if (t2 !== 0) {
          if (dampingRatio < 1) {
            const prevT = Math.max(0, t2 - velocitySampleDuration);
            currentVelocity = velocityPerSecond(current - resolveSpring(prevT), t2 - prevT);
          } else {
            currentVelocity = 0;
          }
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state2.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state2.done = t2 >= duration;
      }
      state2.value = state2.done ? target : current;
      return state2;
    },
    flipTarget: () => {
      initialVelocity = -initialVelocity;
      [origin, target] = [target, origin];
      createSpring();
    }
  };
}
spring.needsInterpolation = (a, b) => typeof a === "string" || typeof b === "string";
const zero = (_t) => 0;
function decay({
  /**
   * The decay animation dynamically calculates an end of the animation
   * based on the initial keyframe, so we only need to define a single keyframe
   * as default.
   */
  keyframes: keyframes2 = [0],
  velocity = 0,
  power = 0.8,
  timeConstant = 350,
  restDelta = 0.5,
  modifyTarget
}) {
  const origin = keyframes2[0];
  const state2 = { done: false, value: origin };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state2.done = !(delta > restDelta || delta < -restDelta);
      state2.value = state2.done ? target : target + delta;
      return state2;
    },
    flipTarget: () => {
    }
  };
}
const types = {
  decay,
  keyframes,
  tween: keyframes,
  spring
};
function loopElapsed(elapsed, duration, delay2 = 0) {
  return elapsed - duration - delay2;
}
function reverseElapsed(elapsed, duration = 0, delay2 = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;
}
function hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;
}
const framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => sync.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate$1({ duration, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, keyframes: keyframes$12, autoplay = true, onPlay, onStop, onComplete, onRepeat, onUpdate, type: type2 = "keyframes", ...options }) {
  var _a, _b;
  const initialElapsed = elapsed;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = duration;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = types[keyframes$12.length > 2 ? "keyframes" : type2] || keyframes;
  const origin = keyframes$12[0];
  const target = keyframes$12[keyframes$12.length - 1];
  let state2 = { done: false, value: origin };
  if ((_b = (_a = animator).needsInterpolation) === null || _b === void 0 ? void 0 : _b.call(_a, origin, target)) {
    interpolateFromNumber = interpolate([0, 100], [origin, target], {
      clamp: false
    });
    keyframes$12 = [0, 100];
  }
  const animation = animator({
    ...options,
    duration,
    keyframes: keyframes$12
  });
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls && driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      state2 = animation.next(Math.max(0, elapsed));
      if (interpolateFromNumber)
        state2.value = interpolateFromNumber(state2.value);
      isComplete = isForwardPlayback ? state2.done : elapsed <= 0;
    }
    onUpdate && onUpdate(state2.value);
    if (isComplete) {
      if (repeatCount === 0) {
        computedDuration = computedDuration !== void 0 ? computedDuration : elapsed;
      }
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay && onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop && onStop();
      driverControls && driverControls.stop();
    },
    /**
     * Set the current time of the animation. This is purposefully
     * mirroring the WAAPI animation API to make them interchanagable.
     * Going forward this file should be ported more towards
     * https://github.com/motiondivision/motionone/blob/main/packages/animation/src/Animation.ts
     * Which behaviourally adheres to WAAPI as far as possible.
     *
     * WARNING: This is not safe to use for most animations. We currently
     * only use it for handoff from WAAPI within Framer.
     *
     * This animation function consumes time every frame rather than being sampled for time.
     * So the sample() method performs some headless frames to ensure
     * repeats are handled correctly. Ideally in the future we will replace
     * that method with this, once repeat calculations are pure.
     */
    set currentTime(t2) {
      elapsed = initialElapsed;
      update(t2);
    },
    /**
     * animate() can't yet be sampled for time, instead it
     * consumes time. So to sample it we have to run a low
     * temporal-resolution version.
     */
    sample: (t2) => {
      elapsed = initialElapsed;
      const sampleResolution = duration && typeof duration === "number" ? Math.max(duration * 0.5, 50) : 50;
      let sampleElapsed = 0;
      update(0);
      while (sampleElapsed <= t2) {
        const remaining = t2 - sampleElapsed;
        update(Math.min(remaining, sampleResolution));
        sampleElapsed += sampleResolution;
      }
      return state2;
    }
  };
}
function isWaapiSupportedEasing(easing) {
  return !easing || // Default easing
  Array.isArray(easing) || // Bezier curve
  typeof easing === "string" && supportedWaapiEasing[easing];
}
const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`;
const supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (!easing)
    return void 0;
  return Array.isArray(easing) ? cubicBezierAsString(easing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease, times } = {}) {
  return element.animate({ [valueName]: keyframes2, offset: times }, {
    delay: delay2,
    duration,
    easing: mapEasingToNativeEasing(ease),
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
const featureTests = {
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate")
};
const results = {};
const supports = {};
for (const key in featureTests) {
  supports[key] = () => {
    if (results[key] === void 0)
      results[key] = featureTests[key]();
    return results[key];
  };
}
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index];
}
const acceleratedValues = /* @__PURE__ */ new Set(["opacity"]);
const sampleDelta = 10;
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
  const canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0;
  if (!canAccelerateAnimation)
    return false;
  let { keyframes: keyframes2, duration = 300, elapsed = 0, ease } = options;
  if (options.type === "spring" || !isWaapiSupportedEasing(options.ease)) {
    if (options.repeat === Infinity)
      return;
    const sampleAnimation = animate$1({ ...options, elapsed: 0 });
    let state2 = { done: false, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t2 = 0;
    while (!state2.done && t2 < 2e4) {
      state2 = sampleAnimation.sample(t2);
      pregeneratedKeyframes.push(state2.value);
      t2 += sampleDelta;
    }
    keyframes2 = pregeneratedKeyframes;
    duration = t2 - sampleDelta;
    ease = "linear";
  }
  const animation = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    delay: -elapsed,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease
  });
  animation.onfinish = () => {
    value.set(getFinalKeyframe(keyframes2, options));
    sync.update(() => animation.cancel());
    onComplete && onComplete();
  };
  return {
    get currentTime() {
      return animation.currentTime || 0;
    },
    set currentTime(t2) {
      animation.currentTime = t2;
    },
    stop: () => {
      const { currentTime } = animation;
      if (currentTime) {
        const sampleAnimation = animate$1({ ...options, autoplay: false });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      sync.update(() => animation.cancel());
    }
  };
}
function delay(callback, timeout) {
  const start = performance.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelSync.read(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  sync.read(checkElapsed, true);
  return () => cancelSync.read(checkElapsed);
}
function createInstantAnimation({ keyframes: keyframes2, elapsed, onUpdate, onComplete }) {
  const setValue = () => {
    onUpdate && onUpdate(keyframes2[keyframes2.length - 1]);
    onComplete && onComplete();
  };
  return elapsed ? { stop: delay(setValue, -elapsed) } : setValue();
}
function inertia({ keyframes: keyframes2, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  const origin = keyframes2[0];
  let currentAnimation;
  function isOutOfBounds(v2) {
    return min !== void 0 && v2 < min || max !== void 0 && v2 > max;
  }
  function findNearestBoundary(v2) {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
  }
  function startAnimation(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate$1({
      keyframes: [0, 1],
      velocity: 0,
      ...options,
      driver,
      onUpdate: (v2) => {
        var _a;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v2);
        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v2);
      },
      onComplete,
      onStop
    });
  }
  function startSpring(options) {
    startAnimation({
      type: "spring",
      stiffness: bounceStiffness,
      damping: bounceDamping,
      restDelta,
      ...options
    });
  }
  if (isOutOfBounds(origin)) {
    startSpring({
      velocity,
      keyframes: [origin, findNearestBoundary(origin)]
    });
  } else {
    let target = power * velocity + origin;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = findNearestBoundary(target);
    const heading = boundary === min ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = (v2) => {
      prev = current;
      current = v2;
      velocity = velocityPerSecond(v2 - prev, frameData.delta);
      if (heading === 1 && v2 > boundary || heading === -1 && v2 < boundary) {
        startSpring({ keyframes: [v2, boundary], velocity });
      }
    };
    startAnimation({
      type: "decay",
      keyframes: [origin, 0],
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}
const underDampedSpring = () => ({
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
});
const criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const linearTween = () => ({
  type: "keyframes",
  ease: "linear",
  duration: 0.3
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
const defaultTransitions$1 = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
const getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else {
    const factory2 = defaultTransitions$1[valueKey] || defaultTransitions$1.default;
    return factory2(keyframes2[1]);
  }
};
const isAnimatable = (key, value) => {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition2 }) {
  return !!Object.keys(transition2).length;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone("", potentialUnitType);
}
function getValueTransition(transition2, key) {
  return transition2[key] || transition2["default"] || transition2;
}
function getKeyframes(value, valueName, target, transition2) {
  const isTargetAnimatable = isAnimatable(valueName, target);
  let origin = transition2.from !== void 0 ? transition2.from : value.get();
  if (origin === "none" && isTargetAnimatable && typeof target === "string") {
    origin = getAnimatableNone(valueName, target);
  } else if (isZero(origin) && typeof target === "string") {
    origin = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin === "string") {
    target = getZeroUnit(origin);
  }
  if (Array.isArray(target)) {
    if (target[0] === null) {
      target[0] = origin;
    }
    return target;
  } else {
    return [origin, target];
  }
}
const createMotionValueAnimation = (valueName, value, target, transition2 = {}) => {
  return (onComplete) => {
    const valueTransition = getValueTransition(transition2, valueName) || {};
    const delay2 = valueTransition.delay || transition2.delay || 0;
    let { elapsed = 0 } = transition2;
    elapsed = elapsed - secondsToMilliseconds(delay2);
    const keyframes2 = getKeyframes(value, valueName, target, valueTransition);
    const originKeyframe = keyframes2[0];
    const targetKeyframe = keyframes2[keyframes2.length - 1];
    const isOriginAnimatable = isAnimatable(valueName, originKeyframe);
    const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
    warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
    let options = {
      keyframes: keyframes2,
      velocity: value.getVelocity(),
      ...valueTransition,
      elapsed,
      onUpdate: (v2) => {
        value.set(v2);
        valueTransition.onUpdate && valueTransition.onUpdate(v2);
      },
      onComplete: () => {
        onComplete();
        valueTransition.onComplete && valueTransition.onComplete();
      }
    };
    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {
      return createInstantAnimation(options);
    } else if (valueTransition.type === "inertia") {
      return inertia(options);
    }
    if (!isTransitionDefined(valueTransition)) {
      options = {
        ...options,
        ...getDefaultTransition(valueName, options)
      };
    }
    if (options.duration) {
      options.duration = secondsToMilliseconds(options.duration);
    }
    if (options.repeatDelay) {
      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);
    }
    const visualElement = value.owner;
    const element = visualElement && visualElement.current;
    if (visualElement && element instanceof HTMLElement && !(visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onUpdate)) {
      const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
      if (acceleratedAnimation)
        return acceleratedAnimation;
    }
    return animate$1(options);
  };
};
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = animateTarget(visualElement, resolvedDefinition, options);
  }
  return animation.then(() => visualElement.notify("AnimationComplete", definition));
}
function animateVariant(visualElement, variant, options = {}) {
  var _a;
  const resolved = resolveVariant(visualElement, variant, options.custom);
  let { transition: transition2 = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition2 = options.transitionOverride;
  }
  const getAnimation = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();
  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition2;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition2;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(last);
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type: type2 } = {}) {
  var _a;
  let { transition: transition2 = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  if (transitionOverride)
    transition2 = transitionOverride;
  const animations2 = [];
  const animationTypeState = type2 && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type2]);
  for (const key in target) {
    const value = visualElement.getValue(key);
    const valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = { delay: delay2, elapsed: 0, ...transition2 };
    if (window.HandoffAppearAnimations && !value.hasAnimated) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);
      }
    }
    let animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? { type: false } : valueTransition));
    if (isWillChangeMotionValue(willChange)) {
      willChange.add(key);
      animation = animation.then(() => willChange.remove(key));
    }
    animations2.push(animation);
  }
  return Promise.all(animations2).then(() => {
    transitionEnd && setTarget(visualElement, transitionEnd);
  });
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
const variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement);
  const state2 = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition: transition2, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(options, changedActiveType) {
    const props = visualElement.getProps();
    const context = visualElement.getVariantContext(true) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type2 = reversePriorityOrder[i];
      const typeState = state2[type2];
      const prop = props[type2] !== void 0 ? props[type2] : context[type2];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type2 === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i;
      let isInherited = prop === context[type2] && prop !== props[type2] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type2 === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key) => {
        shouldAnimateType = true;
        removedKeys.delete(key);
        typeState.needsAnimating[key] = true;
      };
      for (const key in allKeys) {
        const next2 = resolvedValues[key];
        const prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next2 !== prev) {
          if (isKeyframesTarget(next2) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next2, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next2 !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next2 !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push(...definitionList.map((animation) => ({
          animation,
          options: { type: type2, ...options }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key) => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type2, isActive, options) {
    var _a;
    if (state2[type2].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type2, isActive);
    });
    state2[type2].isActive = isActive;
    const animations2 = animateChanges(options, type2);
    for (const key in state2) {
      state2[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state2
  };
}
function checkVariantsDidChange(prev, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    [AnimationType.Animate]: createTypeState(true),
    [AnimationType.InView]: createTypeState(),
    [AnimationType.Hover]: createTypeState(),
    [AnimationType.Tap]: createTypeState(),
    [AnimationType.Drag]: createTypeState(),
    [AnimationType.Focus]: createTypeState(),
    [AnimationType.Exit]: createTypeState()
  };
}
const animations = {
  animation: makeRenderlessComponent(({ visualElement, animate: animate2 }) => {
    visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));
    if (isAnimationControls(animate2)) {
      useEffect(() => animate2.subscribe(visualElement), [animate2]);
    }
  }),
  exit: makeRenderlessComponent((props) => {
    const { custom, visualElement } = props;
    const [isPresent2, safeToRemove] = usePresence();
    const presenceContext = useContext(PresenceContext);
    useEffect(() => {
      visualElement.isPresent = isPresent2;
      const animation = visualElement.animationState && visualElement.animationState.setActive(AnimationType.Exit, !isPresent2, {
        custom: presenceContext && presenceContext.custom || custom
      });
      if (animation && !isPresent2) {
        animation.then(safeToRemove);
      }
    }, [isPresent2]);
  })
};
const distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      sync.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const { onEnd, onSessionEnd } = this.handlers;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe$1(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelSync.update(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target = 0, maxDistance = 0.01) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}
function applyConstraints(point, { min, max }, elastic) {
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = progress$1(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = progress$1(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({ min: 0, max: 0 });
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y }) {
  return { top: y.min, right: x2.max, bottom: y.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  var _a, _b;
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")
      continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  treeScale.x = snapToDefault(treeScale.x);
  treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  if (Number.isInteger(scale2))
    return scale2;
  return scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms2, [key, scaleKey, originKey]) {
  const axisOrigin = transforms2[originKey] !== void 0 ? transforms2[originKey] : 0.5;
  const originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms2[key], transforms2[scaleKey], originPoint, transforms2.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"];
const yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform2) {
  transformAxis(box.x, transform2, xKeys$1);
  transformAxis(box.y, transform2, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    if (this.visualElement.isPresent === false)
      return;
    const onSessionStart = (event) => {
      this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event, "page").point);
      }
    };
    const onStart = (event, info) => {
      var _a;
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openGlobalLock)
          this.openGlobalLock();
        this.openGlobalLock = getGlobalLock(drag2);
        if (!this.openGlobalLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        var _a2, _b;
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const measuredAxis = (_b = (_a2 = this.visualElement.projection) === null || _a2 === void 0 ? void 0 : _a2.layout) === null || _b === void 0 ? void 0 : _b.layoutBox[axis];
          if (measuredAxis) {
            const length = calcLength(measuredAxis);
            current = length * (parseFloat(current) / 100);
          }
        }
        this.originPoint[axis] = current;
      });
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
      (_a = this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        if (this.currentDirection !== null) {
          onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      this.visualElement.render();
      onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd
    }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
  }
  cancel() {
    var _a, _b;
    this.isDragging = false;
    if (this.visualElement.projection) {
      this.visualElement.projection.isAnimationBlocked = false;
    }
    (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openGlobalLock) {
      this.openGlobalLock();
      this.openGlobalLock = null;
    }
    (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
  }
  updateAxis(axis, _point, offset) {
    const { drag: drag2 } = this.getProps();
    if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    const { dragConstraints, dragElastic } = this.getProps();
    const { layout: layout2 } = this.visualElement.projection || {};
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant$2(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition2 = (constraints === null || constraints === void 0 ? void 0 : constraints[axis]) || {};
      if (dragSnapToOrigin)
        transition2 = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition2
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition2) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(createMotionValueAnimation(axis, axisValue, 0, transition2));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    var _a;
    const dragKey = "_drag" + axis.toUpperCase();
    const externalMotionValue = this.visualElement.getProps()[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, ((_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min, max } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mix(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    var _a;
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate: transformTemplate2 } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
    (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min, max } = this.constraints[axis];
      axisValue.set(mix(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    var _a;
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints)) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();
      projection.updateLayout();
    }
    measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener === null || stopLayoutUpdateListener === void 0 ? void 0 : stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
function useDrag(props) {
  const { dragControls: groupDragControls, visualElement } = props;
  const dragControls = useConstant(() => new VisualElementDragControls(visualElement));
  useEffect(() => groupDragControls && groupDragControls.subscribe(dragControls), [dragControls, groupDragControls]);
  useEffect(() => dragControls.addListeners(), [dragControls]);
}
function usePanGesture({ onPan, onPanStart, onPanEnd, onPanSessionStart, visualElement }) {
  const hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  const panSession = useRef(null);
  const { transformPagePoint } = useContext(MotionConfigContext);
  const handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: (event, info) => {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  useEffect(() => {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(() => panSession.current && panSession.current.end());
}
const drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};
function isCSSVariable(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
const cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match2 = cssVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token2, fallback] = match2;
  return [token2, fallback];
}
const maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant$2(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable(fallback)) {
    return getVariableValue(fallback, element, depth + 1);
  } else {
    return fallback;
  }
}
function resolveCSSVariables(visualElement, { ...target }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = { ...transitionEnd };
  }
  visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariable(current))
      return;
    const resolved = getVariableValue(current, element);
    if (resolved)
      value.set(resolved);
  });
  for (const key in target) {
    const current = target[key];
    if (!isCSSVariable(current))
      continue;
    const resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd && transitionEnd[key] === void 0) {
      transitionEnd[key] = current;
    }
  }
  return { target, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
const isPositionalKey = (key) => positionalKeys.has(key);
const hasPositionalKey = (target) => {
  return Object.keys(target).some(isPositionalKey);
};
const isNumOrPxType = (v2) => v2 === number || v2 === px;
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform: transform2 }) => {
  if (transform2 === "none" || !transform2)
    return 0;
  const matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform2.match(/^matrix\((.+)\)$/);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter((key) => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement.render();
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y }, { paddingTop = "0", paddingBottom = "0" }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y }, { top }) => parseFloat(top) + (y.max - y.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
const convertChangedValueTypes = (target, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox();
  const element = visualElement.current;
  const elementComputedStyle = getComputedStyle(element);
  const { display } = elementComputedStyle;
  const origin = {};
  if (display === "none") {
    visualElement.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach((key) => {
    origin[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  changedKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    value && value.jump(origin[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
const checkAndConvertChangedValueTypes = (visualElement, target, origin = {}, transitionEnd = {}) => {
  target = { ...target };
  transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  let removedTransformValues = [];
  let hasAttemptedToRemoveTransformValues = false;
  const changedValueTypeKeys = [];
  targetPositionalKeys.forEach((key) => {
    const value = visualElement.getValue(key);
    if (!visualElement.hasValue(key))
      return;
    let from2 = origin[key];
    let fromType = findDimensionValueType(from2);
    const to = target[key];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length;
      const fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex];
      fromType = findDimensionValueType(from2);
      for (let i = fromIndex; i < numKeyframes; i++) {
        if (!toType) {
          toType = findDimensionValueType(to[i]);
          invariant$2(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant$2(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to === "string") {
          target[key] = parseFloat(to);
        } else if (Array.isArray(to) && toType === px) {
          target[key] = to.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from2 === 0 || to === 0)) {
        if (from2 === 0) {
          value.set(toType.transform(from2));
        } else {
          target[key] = fromType.transform(to);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        value.jump(to);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    const convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(([key, value]) => {
        visualElement.getValue(key).set(value);
      });
    }
    visualElement.render();
    if (isBrowser && scrollY !== null) {
      window.scrollTo({ top: scrollY });
    }
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement, target, origin, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd) : { target, transitionEnd };
}
const parseDomVariant = (visualElement, target, origin, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement, target, origin, transitionEnd);
};
const prefersReducedMotion = { current: null };
const hasReducedMotionListener = { current: false };
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function updateMotionValuesFromProps(element, next2, prev) {
  const { willChange } = next2;
  for (const key in next2) {
    const nextValue = next2[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (isWillChangeMotionValue(willChange)) {
        willChange.add(key);
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue, { owner: element }));
      if (isWillChangeMotionValue(willChange)) {
        willChange.remove(key);
      }
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key in prev) {
    if (next2[key] === void 0)
      element.removeValue(key);
  }
  return next2;
}
const featureNames = Object.keys(featureDefinitions);
const numFeatures = featureNames.length;
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  constructor({ parent, props, reducedMotionConfig, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.isPresent = true;
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.scheduleRender = () => sync.render(this.render, false, true);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
        if (isWillChangeMotionValue(willChange)) {
          willChange.add(key);
        }
      }
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance) {
    var _a;
    this.current = instance;
    if (this.projection) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (this.parent)
      this.parent.children.add(this);
    this.setProps(this.props);
  }
  unmount() {
    var _a, _b, _c;
    (_a = this.projection) === null || _a === void 0 ? void 0 : _a.unmount();
    cancelSync.update(this.notifyUpdate);
    cancelSync.render(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    (_b = this.removeFromVariantTree) === null || _b === void 0 ? void 0 : _b.call(this);
    (_c = this.parent) === null || _c === void 0 ? void 0 : _c.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && sync.update(this.notifyUpdate, false, true);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type)
      return 0;
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures, projectionId, ProjectionNodeConstructor, initialLayoutGroupConfig) {
    const features = [];
    for (let i = 0; i < numFeatures; i++) {
      const name2 = featureNames[i];
      const { isEnabled, Component } = featureDefinitions[name2];
      if (isEnabled(renderedProps) && Component) {
        features.push(createElement(Component, {
          key: name2,
          ...renderedProps,
          visualElement: this
        }));
      }
    }
    if (!this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(projectionId, this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 === "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return features;
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target, canMutate = true) {
    return this.makeTargetAnimatableFromInstance(target, this.props, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  setProps(props) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    const prevProps = this.props;
    this.props = props;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listener = props["on" + key];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, prevProps), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name2) {
    var _a;
    return (_a = this.props.variants) === null || _a === void 0 ? void 0 : _a[name2];
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    var _a;
    return this.isVariantNode ? this : (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getClosestVariantNode();
  }
  getVariantContext(startAtParent = false) {
    var _a, _b;
    if (startAtParent)
      return (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getVariantContext();
    if (!this.isControllingVariants) {
      const context2 = ((_b = this.parent) === null || _b === void 0 ? void 0 : _b.getVariantContext()) || {};
      if (this.props.initial !== void 0) {
        context2.initial = this.props.initial;
      }
      return context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name2 = variantProps[i];
      const prop = this.props[name2];
      if (isVariantLabel(prop) || prop === false) {
        context[name2] = prop;
      }
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    var _a;
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    if (value !== this.values.get(key)) {
      this.removeValue(key);
      this.bindToMotionValue(key, value);
    }
    this.values.set(key, value);
    this.latestValues[key] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    var _a;
    this.values.delete(key);
    (_a = this.valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();
    this.valueSubscriptions.delete(key);
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue, { owner: this });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key) {
    return this.latestValues[key] !== void 0 || !this.current ? this.latestValues[key] : this.readValueFromInstance(this.current, key, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const { initial } = this.props;
    const valueFromInitial = typeof initial === "string" || typeof initial === "object" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key] : void 0;
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    var _a;
    (_a = this.events[eventName]) === null || _a === void 0 ? void 0 : _a.notify(...args);
  }
}
const variantProps = ["initial", ...variantPriorityOrder];
const numVariantProps = variantProps.length;
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    var _a;
    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];
  }
  removeValueFromRenderState(key, { vars, style }) {
    delete vars[key];
    delete style[key];
  }
  makeTargetAnimatableFromInstance({ transition: transition2, transitionEnd, ...target }, { transformValues }, isMounted) {
    let origin = getOrigin(target, transition2 || {}, this);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin)
        origin = transformValues(origin);
    }
    if (isMounted) {
      checkTargetForNewValues(this, target, origin);
      const parsed = parseDomVariant(this, target, origin, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return {
      transition: transition2,
      transitionEnd,
      ...target
    };
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$1(instance);
      const value = (isCSSVariable$1(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options, props) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current)
          this.current.textContent = `${latest}`;
      });
    }
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.isSVGTag = false;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    var _a;
    if (transformProps.has(key)) {
      return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: false }) : new HTMLVisualElement(options, { enableHardwareAcceleration: true });
};
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x2}% ${y}%`;
  }
};
const varToken = "_$css";
const correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const containsCSSVariables = latest.includes("var(");
    const cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, (match2) => {
        cssVariables.push(match2);
        return varToken;
      });
    }
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    const averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    let output = template(shadow);
    if (containsCSSVariables) {
      let i = 0;
      output = output.replace(varToken, () => {
        const cssVariable = cssVariables[i];
        i++;
        return cssVariable;
      });
    }
    return output;
  }
};
class MeasureLayoutWithContext extends React__default.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent: isPresent2 } = this.props;
    const projection = visualElement.projection;
    if (!projection)
      return null;
    projection.isPresent = isPresent2;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent2) {
      if (isPresent2) {
        projection.promote();
      } else if (!projection.relegate()) {
        sync.postRender(() => {
          var _a;
          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      if (!projection.currentAnimation && projection.isLead()) {
        this.safeToRemove();
      }
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent2, safeToRemove] = usePresence();
  const layoutGroup = useContext(LayoutGroupContext);
  return React__default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const layoutFeatures = {
  measureLayout: MeasureLayout
};
function animate(from2, to, transition2 = {}) {
  const value = isMotionValue(from2) ? from2 : motionValue(from2);
  value.start(createMotionValueAnimation("", value, to, transition2));
  return {
    stop: () => value.stop(),
    isAnimating: () => value.isAnimating()
  };
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
const isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // TODO Reinstate this if only child
      lead.opacity !== void 0 ? lead.opacity : 1,
      easeCrossfadeIn(progress2)
    );
    target.opacityExit = mix(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mix(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2);
  }
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut);
const easeCrossfadeOut = compress(0.5, 0.95, noop);
function compress(min, max, easing) {
  return (p) => {
    if (p < min)
      return 0;
    if (p > max)
      return 1;
    return easing(progress$1(min, max, p));
  };
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mix(originAxis.min, originAxis.max, origin);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms2, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms2[key], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms2, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms2, xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms2, yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a, b) {
  return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex((member) => node === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    var _a;
    const prevLead = this.lead;
    if (node === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {
        node.isLayoutDirty = true;
      }
      const { crossfade } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node) => {
      var _a, _b, _c, _d, _e;
      (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
      (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);
    });
  }
  scheduleRender() {
    this.members.forEach((node) => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  if (xTranslate || yTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { rotate, rotateX, rotateY } = latestTransform;
    if (rotate)
      transform2 += `rotate(${rotate}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}
const compareByDepth = (a, b) => a.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
const transformAxes = ["", "X", "Y", "Z"];
const animationTarget = 1e3;
let id = 0;
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(elementId, latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      this.id = id++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isTransformDirty = false;
      this.isProjectionDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.potentialNodes = /* @__PURE__ */ new Map();
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
      };
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.elementId = elementId;
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      elementId && this.root.registerPotentialNode(elementId, this);
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name2, handler) {
      if (!this.eventHandlers.has(name2)) {
        this.eventHandlers.set(name2, new SubscriptionManager());
      }
      return this.eventHandlers.get(name2).add(handler);
    }
    notifyListeners(name2, ...args) {
      const subscriptionManager = this.eventHandlers.get(name2);
      subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify(...args);
    }
    hasListeners(name2) {
      return this.eventHandlers.has(name2);
    }
    registerPotentialNode(elementId, node) {
      this.potentialNodes.set(elementId, node);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = false) {
      var _a;
      if (this.instance)
        return;
      this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);
      this.elementId && this.root.potentialNodes.delete(this.elementId);
      if (isLayoutDirty && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
          var _a2, _b, _c, _d, _e;
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = (_b = (_a2 = this.options.transition) !== null && _a2 !== void 0 ? _a2 : visualElement.getDefaultTransition()) !== null && _b !== void 0 ? _b : defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const targetChanged = !this.targetLayout || !boxEquals(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || ((_c = this.resumeFrom) === null || _c === void 0 ? void 0 : _c.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged && this.animationProgress === 0) {
              finishAnimation(this);
            }
            this.isLead() && ((_e = (_d = this.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d));
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      var _a, _b;
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);
      (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
      this.instance = void 0;
      cancelSync.preRender(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      var _a;
      return this.isAnimationBlocked || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      var _a;
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      var _a;
      return (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      var _a, _b, _c;
      if (this.root.isUpdateBlocked()) {
        (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);
        return;
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      this.prevTransformTemplateValue = (_c = this.getTransformTemplate()) === null || _c === void 0 ? void 0 : _c(this.latestValues, "");
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    // Note: Currently only running on root node
    didUpdate() {
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating)
        return;
      this.isUpdating = false;
      if (this.potentialNodes.size) {
        this.potentialNodes.forEach(mountNodeEarly);
        this.potentialNodes.clear();
      }
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      flushSync.update();
      flushSync.preRender();
      flushSync.render();
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      sync.preRender(this.updateProjection, false, true);
    }
    scheduleCheckAfterUnmount() {
      sync.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      var _a;
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notify("LayoutMeasure", this.layout.layoutBox, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.layoutBox);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot: checkIsScrollRoot(this.instance),
          offset: measureScroll(this.instance)
        };
      }
    }
    resetTransform() {
      var _a;
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplateValue = (_a = this.getTransformTemplate()) === null || _a === void 0 ? void 0 : _a(this.latestValues, "");
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const { scroll: scroll2 } = this.root;
      if (scroll2) {
        translateAxis(box.x, scroll2.offset.x);
        translateAxis(box.y, scroll2.offset.y);
      }
      return box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const { scroll: scroll2, options } = node;
        if (node !== this.root && scroll2 && options.layoutScroll) {
          if (scroll2.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            if (rootScroll) {
              translateAxis(boxWithoutScroll.x, -rootScroll.offset.x);
              translateAxis(boxWithoutScroll.y, -rootScroll.offset.y);
            }
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues))
          continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      var _a;
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance)
          continue;
        if (!hasTransform(node.latestValues))
          continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layoutBox, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    /**
     *
     */
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.isProjectionDirty = true;
      this.root.scheduleUpdateProjection();
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    /**
     * Frame calculations
     */
    resolveTargetDelta() {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      if (!this.isProjectionDirty && !this.attemptToResolveRelativeTarget)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout) {
          this.relativeParent = relativeParent;
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target) {
          this.relativeParent = relativeParent;
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if ((this.parent.relativeTarget || this.parent.targetDelta || this.parent.options.layoutRoot) && this.parent.layout) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    calcProjection() {
      var _a;
      const { isProjectionDirty, isTransformDirty } = this;
      this.isProjectionDirty = this.isTransformDirty = false;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (isProjectionDirty)
        canSkip = false;
      if (isShared && isTransformDirty)
        canSkip = false;
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      const { target } = lead;
      if (!target)
        return;
      if (!this.projectionDelta) {
        this.projectionDelta = createDelta();
        this.projectionDeltaWithTransform = createDelta();
      }
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
      if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a, _b, _c;
      (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);
      notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      var _a, _b;
      const snapshot = this.snapshot;
      const snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const isSharedLayoutAnimation = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.source) !== ((_a = this.layout) === null || _a === void 0 ? void 0 : _a.source);
      const isOnlyMember = (((_b = this.getStack()) === null || _b === void 0 ? void 0 : _b.members.length) || 0) <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      this.mixTargetDelta = (latest) => {
        var _a2;
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && ((_a2 = this.relativeParent) === null || _a2 === void 0 ? void 0 : _a2.layout)) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      var _a, _b;
      this.notifyListeners("animationStart");
      (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      if (this.resumingFrom) {
        (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
      }
      if (this.pendingAnimation) {
        cancelSync.update(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = sync.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animate(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            var _a2;
            this.mixTargetDelta(latest);
            (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, latest);
          },
          onComplete: () => {
            var _a2;
            (_a2 = options.onComplete) === null || _a2 === void 0 ? void 0 : _a2.call(options);
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      var _a;
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      var _a;
      if (this.currentAnimation) {
        (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      var _a, _b, _c;
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      node.promote({
        transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,
        preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node)
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition: transition2, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition2)
        this.setOptions({ transition: transition2 });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = false;
      const { latestValues } = visualElement;
      if (latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) {
        hasRotate = true;
      }
      if (!hasRotate)
        return;
      const resetValues = {};
      for (let i = 0; i < transformAxes.length; i++) {
        const key = "rotate" + transformAxes[i];
        if (latestValues[key]) {
          resetValues[key] = latestValues[key];
          visualElement.setStaticValue(key, 0);
        }
      }
      visualElement === null || visualElement === void 0 ? void 0 : visualElement.render();
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp = {}) {
      var _a, _b;
      const styles2 = {};
      if (!this.instance || this.isSVG)
        return styles2;
      if (!this.isVisible) {
        return { visibility: "hidden" };
      } else {
        styles2.visibility = "";
      }
      const transformTemplate2 = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles2.opacity = "";
        styles2.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        styles2.transform = transformTemplate2 ? transformTemplate2(this.latestValues, "") : "none";
        return styles2;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate2 ? transformTemplate2({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate2) {
        styles2.transform = transformTemplate2(valuesToRender, styles2.transform);
      }
      const { x: x2, y } = this.projectionDelta;
      styles2.transformOrigin = `${x2.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        styles2.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles2.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key];
        const corrected = styles2.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles2[applyTo[i]] = corrected;
          }
        } else {
          styles2[key] = corrected;
        }
      }
      if (this.options.layoutId) {
        styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
      }
      return styles2;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node) => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a, _b, _c;
  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node.layout;
    const { animationType } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_c = (_b = node.options).onExitComplete) === null || _c === void 0 ? void 0 : _c.call(_b);
  }
  node.options.transition = void 0;
}
function propagateDirtyNodes(node) {
  node.isProjectionDirty || (node.isProjectionDirty = Boolean(node.parent && node.parent.isProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = Boolean(node.parent && node.parent.isTransformDirty));
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  const { visualElement } = node.options;
  if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mix(delta.translate, 0, p);
  output.scale = mix(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p) {
  output.min = mix(from2.min, to.min, p);
  output.max = mix(from2.max, to.max, p);
}
function mixBox(output, from2, to, p) {
  mixAxis(output.x, from2.x, to.x, p);
  mixAxis(output.y, from2.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, elementId) {
  let searchNode = node.root;
  for (let i = node.path.length - 1; i >= 0; i--) {
    if (Boolean(node.path[i].instance)) {
      searchNode = node.path[i];
      break;
    }
  }
  const searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  const element = searchElement.querySelector(`[data-projection-id="${elementId}"]`);
  if (element)
    node.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: void 0
};
const HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const featureBundle = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layoutFeatures
};
const motion = /* @__PURE__ */ createMotionProxy((Component, config2) => createDomMotionConfig(Component, config2, featureBundle, createDomVisualElement, HTMLProjectionNode));
function useIsMounted() {
  const isMounted = useRef(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = useState(0);
  const forceRender = useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  const deferredForceRender = useCallback(() => sync.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}
class PopChildMeasure extends React$1.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0;
      size.width = element.offsetWidth || 0;
      size.top = element.offsetTop;
      size.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent: isPresent2 }) {
  const id2 = useId$1();
  const ref = useRef(null);
  const size = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  useInsertionEffect(() => {
    const { width, height, top, left } = size.current;
    if (isPresent2 || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style = document.createElement("style");
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent2]);
  return React$1.createElement(PopChildMeasure, { isPresent: isPresent2, childRef: ref, sizeRef: size }, React$1.cloneElement(children, { ref }));
}
const PresenceChild = ({ children, initial, isPresent: isPresent2, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id2 = useId$1();
  const context = useMemo(
    () => ({
      id: id2,
      initial,
      isPresent: isPresent2,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent2]
  );
  useMemo(() => {
    presenceChildren.forEach((_2, key) => presenceChildren.set(key, false));
  }, [isPresent2]);
  React$1.useEffect(() => {
    !isPresent2 && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent2]);
  if (mode === "popLayout") {
    children = React$1.createElement(PopChild, { isPresent: isPresent2 }, children);
  }
  return React$1.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
const getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  Children.forEach(children, (child) => {
    if (isValidElement$1(child))
      filtered.push(child);
  });
  return filtered;
}
const AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = "sync" }) => {
  if (exitBeforeEnter) {
    mode = "wait";
  }
  let [forceRender] = useForceUpdate();
  const forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  const isMounted = useIsMounted();
  const filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exiting = /* @__PURE__ */ new Set();
  const presentChildren = useRef(childrenToRender);
  const allChildren = useRef(/* @__PURE__ */ new Map()).current;
  const isInitialRender = useRef(true);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(() => {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return React$1.createElement(React$1.Fragment, null, childrenToRender.map((child) => React$1.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout, mode }, child)));
  }
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey);
  const targetKeys = filteredChildren.map(getChildKey);
  const numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key = presentKeys[i];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    }
  }
  if (mode === "wait" && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach((key) => {
    if (targetKeys.indexOf(key) !== -1)
      return;
    const child = allChildren.get(key);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key);
    const onExit = () => {
      allChildren.delete(key);
      exiting.delete(key);
      const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false)
          return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, React$1.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child));
  });
  childrenToRender = childrenToRender.map((child) => {
    const key = child.key;
    return exiting.has(key) ? child : React$1.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout, mode }, child);
  });
  return React$1.createElement(React$1.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map((child) => cloneElement(child)));
};
const findById = (arr, id2) => arr.find((toast) => toast.id === id2);
function findToast(toasts, id2) {
  const position2 = getToastPosition(toasts, id2);
  const index = position2 ? toasts[position2].findIndex((toast) => toast.id === id2) : -1;
  return {
    position: position2,
    index
  };
}
function getToastPosition(toasts, id2) {
  for (const [position2, values] of Object.entries(toasts)) {
    if (findById(values, id2)) {
      return position2;
    }
  }
}
function getToastStyle(position2) {
  const isRighty = position2.includes("right");
  const isLefty = position2.includes("left");
  let alignItems = "center";
  if (isRighty)
    alignItems = "flex-end";
  if (isLefty)
    alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems
  };
}
function getToastListStyle(position2) {
  const isTopOrBottom = position2 === "top" || position2 === "bottom";
  const margin = isTopOrBottom ? "0 auto" : void 0;
  const top = position2.includes("top") ? "env(safe-area-inset-top, 0px)" : void 0;
  const bottom = position2.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : void 0;
  const right = !position2.includes("left") ? "env(safe-area-inset-right, 0px)" : void 0;
  const left = !position2.includes("right") ? "env(safe-area-inset-left, 0px)" : void 0;
  return {
    position: "fixed",
    zIndex: "var(--toast-z-index, 5500)",
    pointerEvents: "none",
    display: "flex",
    flexDirection: "column",
    margin,
    top,
    bottom,
    right,
    left
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var isDevelopment = false;
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion2 = function Insertion3(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag);
  });
  return null;
};
var createStyled = function createStyled2(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      var templateStringsArr = args[0];
      styles2.push(templateStringsArr[0]);
      var len = args.length;
      var i = 1;
      for (; i < len; i++) {
        styles2.push(args[i], templateStringsArr[i]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = React$1.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (finalShouldForwardProp(_key)) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      if (ref) {
        newProps.ref = ref;
      }
      return /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement(Insertion2, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ React$1.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && isDevelopment) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      var newStyled2 = createStyled2(nextTag, _extends({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      }));
      return newStyled2.apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled.bind(null);
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
const allPropNames = /* @__PURE__ */ new Set([
  ...propNames,
  "textStyle",
  "layerStyle",
  "apply",
  "noOfLines",
  "focusBorderColor",
  "errorBorderColor",
  "as",
  "__css",
  "css",
  "sx"
]);
const validHTMLProps = /* @__PURE__ */ new Set([
  "htmlWidth",
  "htmlHeight",
  "htmlSize",
  "htmlTranslate"
]);
function shouldForwardProp(prop) {
  return (validHTMLProps.has(prop) || !allPropNames.has(prop)) && prop[0] !== "_";
}
const emotion_styled = interopDefault(newStyled);
const toCSSObject = ({ baseStyle: baseStyle2 }) => (props) => {
  const { theme: theme2, css: cssProp, __css, sx, ...restProps } = props;
  const [styleProps2] = splitProps(restProps, isStyleProp);
  const finalBaseStyle = runIfFn(baseStyle2, props);
  const finalStyles = assignAfter(
    {},
    __css,
    finalBaseStyle,
    compact$1(styleProps2),
    sx
  );
  const computedCSS = css$2(finalStyles)(props.theme);
  return cssProp ? [computedCSS, cssProp] : computedCSS;
};
function styled(component, options) {
  const { baseStyle: baseStyle2, ...styledOptions } = options ?? {};
  if (!styledOptions.shouldForwardProp) {
    styledOptions.shouldForwardProp = shouldForwardProp;
  }
  const styleObject = toCSSObject({ baseStyle: baseStyle2 });
  const Component = emotion_styled(
    component,
    styledOptions
  )(styleObject);
  const chakraComponent = forwardRef$1(
    function ChakraComponent2(props, ref) {
      const { children, ...restProps } = props;
      const { colorMode, forced } = useColorMode();
      const dataTheme = forced ? colorMode : void 0;
      return createElement(
        Component,
        { ref, "data-theme": dataTheme, ...restProps },
        children
      );
    }
  );
  return chakraComponent;
}
function factory() {
  const cache2 = /* @__PURE__ */ new Map();
  return new Proxy(styled, {
    /**
     * @example
     * const Div = chakra("div")
     * const WithChakra = chakra(AnotherComponent)
     */
    apply(target, thisArg, argArray) {
      return styled(...argArray);
    },
    /**
     * @example
     * <chakra.div />
     */
    get(_2, element) {
      if (!cache2.has(element)) {
        cache2.set(element, styled(element));
      }
      return cache2.get(element);
    }
  });
}
const chakra = factory();
const toastMotionVariants = {
  initial: (props) => {
    const { position: position2 } = props;
    const dir = ["top", "bottom"].includes(position2) ? "y" : "x";
    let factor = ["top-right", "bottom-right"].includes(position2) ? 1 : -1;
    if (position2 === "bottom")
      factor = 1;
    return {
      opacity: 0,
      [dir]: factor * 24
    };
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
const ToastComponent = memo((props) => {
  const {
    id: id2,
    message,
    onCloseComplete,
    onRequestRemove,
    requestClose = false,
    position: position2 = "bottom",
    duration = 5e3,
    containerStyle,
    motionVariants: motionVariants2 = toastMotionVariants,
    toastSpacing = "0.5rem"
  } = props;
  const [delay2, setDelay] = useState(duration);
  const isPresent2 = useIsPresent();
  useUpdateEffect(() => {
    if (!isPresent2) {
      onCloseComplete == null ? void 0 : onCloseComplete();
    }
  }, [isPresent2]);
  useUpdateEffect(() => {
    setDelay(duration);
  }, [duration]);
  const onMouseEnter = () => setDelay(null);
  const onMouseLeave = () => setDelay(duration);
  const close = () => {
    if (isPresent2)
      onRequestRemove();
  };
  useEffect(() => {
    if (isPresent2 && requestClose) {
      onRequestRemove();
    }
  }, [isPresent2, requestClose, onRequestRemove]);
  useTimeout(close, delay2);
  const containerStyles = useMemo(
    () => ({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: toastSpacing,
      ...containerStyle
    }),
    [containerStyle, toastSpacing]
  );
  const toastStyle = useMemo(() => getToastStyle(position2), [position2]);
  return /* @__PURE__ */ jsx$1(
    motion.div,
    {
      layout: true,
      className: "chakra-toast",
      variants: motionVariants2,
      initial: "initial",
      animate: "animate",
      exit: "exit",
      onHoverStart: onMouseEnter,
      onHoverEnd: onMouseLeave,
      custom: { position: position2 },
      style: toastStyle,
      children: /* @__PURE__ */ jsx$1(
        chakra.div,
        {
          role: "status",
          "aria-atomic": "true",
          className: "chakra-toast__inner",
          __css: containerStyles,
          children: runIfFn(message, { id: id2, onClose: close })
        }
      )
    }
  );
});
ToastComponent.displayName = "ToastComponent";
function forwardRef(component) {
  return forwardRef$1(component);
}
function useTheme() {
  const theme2 = useContext(
    ThemeContext
  );
  if (!theme2) {
    throw Error(
      "useTheme: `theme` is undefined. Seems you forgot to wrap your app in `<ChakraProvider />` or `<ThemeProvider />`"
    );
  }
  return theme2;
}
function useChakra() {
  const colorModeResult = useColorMode();
  const theme2 = useTheme();
  return { ...colorModeResult, theme: theme2 };
}
function getBreakpointValue(theme2, value, fallback) {
  if (value == null)
    return value;
  const getValue = (val) => {
    var _a, _b;
    return (_b = (_a = theme2.__breakpoints) == null ? void 0 : _a.asArray) == null ? void 0 : _b[val];
  };
  return getValue(value) ?? getValue(fallback) ?? fallback;
}
function getTokenValue(theme2, value, fallback) {
  if (value == null)
    return value;
  const getValue = (val) => {
    var _a, _b;
    return (_b = (_a = theme2.__cssMap) == null ? void 0 : _a[val]) == null ? void 0 : _b.value;
  };
  return getValue(value) ?? getValue(fallback) ?? fallback;
}
function useToken(scale2, token2, fallback) {
  const theme2 = useTheme();
  return getToken(scale2, token2, fallback)(theme2);
}
function getToken(scale2, token2, fallback) {
  const _token = Array.isArray(token2) ? token2 : [token2];
  const _fallback = Array.isArray(fallback) ? fallback : [fallback];
  return (theme2) => {
    const fallbackArr = _fallback.filter(Boolean);
    const result = _token.map((token22, index) => {
      if (scale2 === "breakpoints") {
        return getBreakpointValue(theme2, token22, fallbackArr[index] ?? token22);
      }
      const path = `${scale2}.${token22}`;
      return getTokenValue(theme2, path, fallbackArr[index] ?? token22);
    });
    return Array.isArray(token2) ? result : result[0];
  };
}
function useStyleConfigImpl(themeKey, props = {}) {
  const { styleConfig: styleConfigProp, ...rest } = props;
  const { theme: theme2, colorMode } = useChakra();
  const themeStyleConfig = themeKey ? memoizedGet$1(theme2, `components.${themeKey}`) : void 0;
  const styleConfig = styleConfigProp || themeStyleConfig;
  const mergedProps = mergeWith(
    { theme: theme2, colorMode },
    (styleConfig == null ? void 0 : styleConfig.defaultProps) ?? {},
    compact$1(omit(rest, ["children"])),
    (obj, src) => !obj ? src : void 0
  );
  const stylesRef = useRef({});
  if (styleConfig) {
    const getStyles = resolveStyleConfig(styleConfig);
    const styles2 = getStyles(mergedProps);
    const isStyleEqual = isEqual(stylesRef.current, styles2);
    if (!isStyleEqual) {
      stylesRef.current = styles2;
    }
  }
  return stylesRef.current;
}
function useStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
function useMultiStyleConfig(themeKey, props = {}) {
  return useStyleConfigImpl(themeKey, props);
}
const fallbackIcon = {
  path: /* @__PURE__ */ jsxs("g", { stroke: "currentColor", strokeWidth: "1.5", children: [
    /* @__PURE__ */ jsx$1(
      "path",
      {
        strokeLinecap: "round",
        fill: "none",
        d: "M9,9a3,3,0,1,1,4,2.829,1.5,1.5,0,0,0-1,1.415V14.25"
      }
    ),
    /* @__PURE__ */ jsx$1(
      "path",
      {
        fill: "currentColor",
        strokeLinecap: "round",
        d: "M12,17.25a.375.375,0,1,0,.375.375A.375.375,0,0,0,12,17.25h0"
      }
    ),
    /* @__PURE__ */ jsx$1("circle", { fill: "none", strokeMiterlimit: "10", cx: "12", cy: "12", r: "11.25" })
  ] }),
  viewBox: "0 0 24 24"
};
const Icon = forwardRef((props, ref) => {
  const {
    as: element,
    viewBox,
    color: color2 = "currentColor",
    focusable = false,
    children,
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-icon", className);
  const customStyles = useStyleConfig("Icon", props);
  const styles2 = {
    w: "1em",
    h: "1em",
    display: "inline-block",
    lineHeight: "1em",
    flexShrink: 0,
    color: color2,
    ...__css,
    ...customStyles
  };
  const shared = {
    ref,
    focusable,
    className: _className,
    __css: styles2
  };
  const _viewBox = viewBox ?? fallbackIcon.viewBox;
  if (element && typeof element !== "string") {
    return /* @__PURE__ */ jsx$1(chakra.svg, { as: element, ...shared, ...rest });
  }
  const _path = children ?? fallbackIcon.path;
  return /* @__PURE__ */ jsx$1(chakra.svg, { verticalAlign: "middle", viewBox: _viewBox, ...shared, ...rest, children: _path });
});
Icon.displayName = "Icon";
function CheckIcon$1(props) {
  return /* @__PURE__ */ jsx$1(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsx$1(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.014,12.014,0,0,0,12,0Zm6.927,8.2-6.845,9.289a1.011,1.011,0,0,1-1.43.188L5.764,13.769a1,1,0,1,1,1.25-1.562l4.076,3.261,6.227-8.451A1,1,0,1,1,18.927,8.2Z"
    }
  ) });
}
function InfoIcon(props) {
  return /* @__PURE__ */ jsx$1(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsx$1(
    "path",
    {
      fill: "currentColor",
      d: "M12,0A12,12,0,1,0,24,12,12.013,12.013,0,0,0,12,0Zm.25,5a1.5,1.5,0,1,1-1.5,1.5A1.5,1.5,0,0,1,12.25,5ZM14.5,18.5h-4a1,1,0,0,1,0-2h.75a.25.25,0,0,0,.25-.25v-4.5a.25.25,0,0,0-.25-.25H10.5a1,1,0,0,1,0-2h1a2,2,0,0,1,2,2v4.75a.25.25,0,0,0,.25.25h.75a1,1,0,1,1,0,2Z"
    }
  ) });
}
function WarningIcon(props) {
  return /* @__PURE__ */ jsx$1(Icon, { viewBox: "0 0 24 24", ...props, children: /* @__PURE__ */ jsx$1(
    "path",
    {
      fill: "currentColor",
      d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
    }
  ) });
}
const spin = keyframes$1({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
const Spinner = forwardRef((props, ref) => {
  const styles2 = useStyleConfig("Spinner", props);
  const {
    label = "Loading...",
    thickness = "2px",
    speed = "0.45s",
    emptyColor = "transparent",
    className,
    ...rest
  } = omitThemingProps(props);
  const _className = cx("chakra-spinner", className);
  const spinnerStyles = {
    display: "inline-block",
    borderColor: "currentColor",
    borderStyle: "solid",
    borderRadius: "99999px",
    borderWidth: thickness,
    borderBottomColor: emptyColor,
    borderLeftColor: emptyColor,
    animation: `${spin} ${speed} linear infinite`,
    ...styles2
  };
  return /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      ref,
      __css: spinnerStyles,
      className: _className,
      ...rest,
      children: label && /* @__PURE__ */ jsx$1(chakra.span, { srOnly: true, children: label })
    }
  );
});
Spinner.displayName = "Spinner";
const [AlertProvider, useAlertContext] = createContext$1({
  name: "AlertContext",
  hookName: "useAlertContext",
  providerName: "<Alert />"
});
const [AlertStylesProvider, useAlertStyles] = createContext$1({
  name: `AlertStylesContext`,
  hookName: `useAlertStyles`,
  providerName: "<Alert />"
});
const STATUSES = {
  info: { icon: InfoIcon, colorScheme: "blue" },
  warning: { icon: WarningIcon, colorScheme: "orange" },
  success: { icon: CheckIcon$1, colorScheme: "green" },
  error: { icon: WarningIcon, colorScheme: "red" },
  loading: { icon: Spinner, colorScheme: "blue" }
};
function getStatusColorScheme(status) {
  return STATUSES[status].colorScheme;
}
function getStatusIcon(status) {
  return STATUSES[status].icon;
}
const Alert = forwardRef(function Alert2(props, ref) {
  const { status = "info", addRole = true, ...rest } = omitThemingProps(props);
  const colorScheme = props.colorScheme ?? getStatusColorScheme(status);
  const styles2 = useMultiStyleConfig("Alert", { ...props, colorScheme });
  const alertStyles = defineStyle({
    width: "100%",
    display: "flex",
    alignItems: "center",
    position: "relative",
    overflow: "hidden",
    ...styles2.container
  });
  return /* @__PURE__ */ jsx$1(AlertProvider, { value: { status }, children: /* @__PURE__ */ jsx$1(AlertStylesProvider, { value: styles2, children: /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      "data-status": status,
      role: addRole ? "alert" : void 0,
      ref,
      ...rest,
      className: cx("chakra-alert", props.className),
      __css: alertStyles
    }
  ) }) });
});
Alert.displayName = "Alert";
function AlertIcon(props) {
  const { status } = useAlertContext();
  const BaseIcon = getStatusIcon(status);
  const styles2 = useAlertStyles();
  const css2 = status === "loading" ? styles2.spinner : styles2.icon;
  return /* @__PURE__ */ jsx$1(
    chakra.span,
    {
      display: "inherit",
      "data-status": status,
      ...props,
      className: cx("chakra-alert__icon", props.className),
      __css: css2,
      children: props.children || /* @__PURE__ */ jsx$1(BaseIcon, { h: "100%", w: "100%" })
    }
  );
}
AlertIcon.displayName = "AlertIcon";
const AlertTitle = forwardRef(
  function AlertTitle2(props, ref) {
    const styles2 = useAlertStyles();
    const { status } = useAlertContext();
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__title", props.className),
        __css: styles2.title
      }
    );
  }
);
AlertTitle.displayName = "AlertTitle";
const AlertDescription = forwardRef(
  function AlertDescription2(props, ref) {
    const { status } = useAlertContext();
    const styles2 = useAlertStyles();
    const descriptionStyles = defineStyle({
      display: "inline",
      ...styles2.description
    });
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        "data-status": status,
        ...props,
        className: cx("chakra-alert__desc", props.className),
        __css: descriptionStyles
      }
    );
  }
);
AlertDescription.displayName = "AlertDescription";
function CloseIcon(props) {
  return /* @__PURE__ */ jsx$1(Icon, { focusable: "false", "aria-hidden": true, ...props, children: /* @__PURE__ */ jsx$1(
    "path",
    {
      fill: "currentColor",
      d: "M.439,21.44a1.5,1.5,0,0,0,2.122,2.121L11.823,14.3a.25.25,0,0,1,.354,0l9.262,9.263a1.5,1.5,0,1,0,2.122-2.121L14.3,12.177a.25.25,0,0,1,0-.354l9.263-9.262A1.5,1.5,0,0,0,21.439.44L12.177,9.7a.25.25,0,0,1-.354,0L2.561.44A1.5,1.5,0,0,0,.439,2.561L9.7,11.823a.25.25,0,0,1,0,.354Z"
    }
  ) });
}
const CloseButton = forwardRef(
  function CloseButton2(props, ref) {
    const styles2 = useStyleConfig("CloseButton", props);
    const { children, isDisabled, __css, ...rest } = omitThemingProps(props);
    const baseStyle2 = {
      outline: 0,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexShrink: 0
    };
    return /* @__PURE__ */ jsx$1(
      chakra.button,
      {
        type: "button",
        "aria-label": "Close",
        ref,
        disabled: isDisabled,
        __css: {
          ...baseStyle2,
          ...styles2,
          ...__css
        },
        ...rest,
        children: children || /* @__PURE__ */ jsx$1(CloseIcon, { width: "1em", height: "1em" })
      }
    );
  }
);
CloseButton.displayName = "CloseButton";
const Toast = (props) => {
  const {
    status,
    variant = "solid",
    id: id2,
    title,
    isClosable,
    onClose,
    description,
    colorScheme,
    icon
  } = props;
  const ids = id2 ? {
    root: `toast-${id2}`,
    title: `toast-${id2}-title`,
    description: `toast-${id2}-description`
  } : void 0;
  return /* @__PURE__ */ jsxs(
    Alert,
    {
      addRole: false,
      status,
      variant,
      id: ids == null ? void 0 : ids.root,
      alignItems: "start",
      borderRadius: "md",
      boxShadow: "lg",
      paddingEnd: 8,
      textAlign: "start",
      width: "auto",
      colorScheme,
      children: [
        /* @__PURE__ */ jsx$1(AlertIcon, { children: icon }),
        /* @__PURE__ */ jsxs(chakra.div, { flex: "1", maxWidth: "100%", children: [
          title && /* @__PURE__ */ jsx$1(AlertTitle, { id: ids == null ? void 0 : ids.title, children: title }),
          description && /* @__PURE__ */ jsx$1(AlertDescription, { id: ids == null ? void 0 : ids.description, display: "block", children: description })
        ] }),
        isClosable && /* @__PURE__ */ jsx$1(
          CloseButton,
          {
            size: "sm",
            onClick: onClose,
            position: "absolute",
            insetEnd: 1,
            top: 1
          }
        )
      ]
    }
  );
};
function createRenderToast(options = {}) {
  const { render: render2, toastComponent: ToastComponent2 = Toast } = options;
  const renderToast = (props) => {
    if (typeof render2 === "function") {
      return render2({ ...props, ...options });
    }
    return /* @__PURE__ */ jsx$1(ToastComponent2, { ...props, ...options });
  };
  return renderToast;
}
const initialState = {
  top: [],
  "top-left": [],
  "top-right": [],
  "bottom-left": [],
  bottom: [],
  "bottom-right": []
};
const toastStore = createStore(initialState);
function createStore(initialState2) {
  let state2 = initialState2;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (setStateFn) => {
    state2 = setStateFn(state2);
    listeners.forEach((l) => l());
  };
  return {
    getState: () => state2,
    subscribe: (listener) => {
      listeners.add(listener);
      return () => {
        setState(() => initialState2);
        listeners.delete(listener);
      };
    },
    /**
     * Delete a toast record at its position
     */
    removeToast: (id2, position2) => {
      setState((prevState) => ({
        ...prevState,
        // id may be string or number
        // eslint-disable-next-line eqeqeq
        [position2]: prevState[position2].filter((toast) => toast.id != id2)
      }));
    },
    notify: (message, options) => {
      const toast = createToast(message, options);
      const { position: position2, id: id2 } = toast;
      setState((prevToasts) => {
        const isTop = position2.includes("top");
        const toasts = isTop ? [toast, ...prevToasts[position2] ?? []] : [...prevToasts[position2] ?? [], toast];
        return {
          ...prevToasts,
          [position2]: toasts
        };
      });
      return id2;
    },
    update: (id2, options) => {
      if (!id2)
        return;
      setState((prevState) => {
        const nextState = { ...prevState };
        const { position: position2, index } = findToast(nextState, id2);
        if (position2 && index !== -1) {
          nextState[position2][index] = {
            ...nextState[position2][index],
            ...options,
            message: createRenderToast(options)
          };
        }
        return nextState;
      });
    },
    closeAll: ({ positions } = {}) => {
      setState((prev) => {
        const allPositions = [
          "bottom",
          "bottom-right",
          "bottom-left",
          "top",
          "top-left",
          "top-right"
        ];
        const positionsToClose = positions ?? allPositions;
        return positionsToClose.reduce(
          (acc, position2) => {
            acc[position2] = prev[position2].map((toast) => ({
              ...toast,
              requestClose: true
            }));
            return acc;
          },
          { ...prev }
        );
      });
    },
    close: (id2) => {
      setState((prevState) => {
        const position2 = getToastPosition(prevState, id2);
        if (!position2)
          return prevState;
        return {
          ...prevState,
          [position2]: prevState[position2].map((toast) => {
            if (toast.id == id2) {
              return {
                ...toast,
                requestClose: true
              };
            }
            return toast;
          })
        };
      });
    },
    isActive: (id2) => Boolean(findToast(toastStore.getState(), id2).position)
  };
}
let counter = 0;
function createToast(message, options = {}) {
  counter += 1;
  const id2 = options.id ?? counter;
  const position2 = options.position ?? "bottom";
  return {
    id: id2,
    message,
    position: position2,
    duration: options.duration,
    onCloseComplete: options.onCloseComplete,
    onRequestRemove: () => toastStore.removeToast(String(id2), position2),
    status: options.status,
    requestClose: false,
    containerStyle: options.containerStyle
  };
}
const [PortalContextProvider, usePortalContext] = createContext$1({
  strict: false,
  name: "PortalContext"
});
const PORTAL_CLASSNAME = "chakra-portal";
const PORTAL_SELECTOR = `.chakra-portal`;
const Container$1 = (props) => /* @__PURE__ */ jsx$1(
  "div",
  {
    className: "chakra-portal-zIndex",
    style: {
      position: "absolute",
      zIndex: props.zIndex,
      top: 0,
      left: 0,
      right: 0
      // NB: Don't add `bottom: 0`, it makes the entire app unusable
      // @see https://github.com/chakra-ui/chakra-ui/issues/3201
    },
    children: props.children
  }
);
const DefaultPortal = (props) => {
  const { appendToParentPortal, children } = props;
  const [tempNode, setTempNode] = useState(null);
  const portal = useRef(null);
  const [, forceUpdate] = useState({});
  useEffect(() => forceUpdate({}), []);
  const parentPortal = usePortalContext();
  const manager = usePortalManager();
  useSafeLayoutEffect$2(() => {
    if (!tempNode)
      return;
    const doc = tempNode.ownerDocument;
    const host = appendToParentPortal ? parentPortal ?? doc.body : doc.body;
    if (!host)
      return;
    portal.current = doc.createElement("div");
    portal.current.className = PORTAL_CLASSNAME;
    host.appendChild(portal.current);
    forceUpdate({});
    const portalNode = portal.current;
    return () => {
      if (host.contains(portalNode)) {
        host.removeChild(portalNode);
      }
    };
  }, [tempNode]);
  const _children = (manager == null ? void 0 : manager.zIndex) ? /* @__PURE__ */ jsx$1(Container$1, { zIndex: manager == null ? void 0 : manager.zIndex, children }) : children;
  return portal.current ? createPortal(
    /* @__PURE__ */ jsx$1(PortalContextProvider, { value: portal.current, children: _children }),
    portal.current
  ) : /* @__PURE__ */ jsx$1(
    "span",
    {
      ref: (el) => {
        if (el)
          setTempNode(el);
      }
    }
  );
};
const ContainerPortal = (props) => {
  const { children, containerRef, appendToParentPortal } = props;
  const containerEl = containerRef.current;
  const host = containerEl ?? (typeof window !== "undefined" ? document.body : void 0);
  const portal = useMemo(() => {
    const node = containerEl == null ? void 0 : containerEl.ownerDocument.createElement("div");
    if (node)
      node.className = PORTAL_CLASSNAME;
    return node;
  }, [containerEl]);
  const [, forceUpdate] = useState({});
  useSafeLayoutEffect$2(() => forceUpdate({}), []);
  useSafeLayoutEffect$2(() => {
    if (!portal || !host)
      return;
    host.appendChild(portal);
    return () => {
      host.removeChild(portal);
    };
  }, [portal, host]);
  if (host && portal) {
    return createPortal(
      /* @__PURE__ */ jsx$1(PortalContextProvider, { value: appendToParentPortal ? portal : null, children }),
      portal
    );
  }
  return null;
};
function Portal(props) {
  const portalProps = {
    appendToParentPortal: true,
    ...props
  };
  const { containerRef, ...rest } = portalProps;
  return containerRef ? /* @__PURE__ */ jsx$1(ContainerPortal, { containerRef, ...rest }) : /* @__PURE__ */ jsx$1(DefaultPortal, { ...rest });
}
Portal.className = PORTAL_CLASSNAME;
Portal.selector = PORTAL_SELECTOR;
Portal.displayName = "Portal";
const [ToastOptionProvider, useToastOptionContext] = createContext$1({
  name: `ToastOptionsContext`,
  strict: false
});
const ToastProvider = (props) => {
  const state2 = useSyncExternalStore$1(
    toastStore.subscribe,
    toastStore.getState,
    toastStore.getState
  );
  const {
    motionVariants: motionVariants2,
    component: Component = ToastComponent,
    portalProps,
    animatePresenceProps
  } = props;
  const stateKeys = Object.keys(state2);
  const toastList = stateKeys.map((position2) => {
    const toasts = state2[position2];
    return /* @__PURE__ */ jsx$1(
      "div",
      {
        role: "region",
        "aria-live": "polite",
        "aria-label": `Notifications-${position2}`,
        id: `chakra-toast-manager-${position2}`,
        style: getToastListStyle(position2),
        children: /* @__PURE__ */ jsx$1(AnimatePresence, { ...animatePresenceProps, initial: false, children: toasts.map((toast) => /* @__PURE__ */ jsx$1(
          Component,
          {
            motionVariants: motionVariants2,
            ...toast
          },
          toast.id
        )) })
      },
      position2
    );
  });
  return /* @__PURE__ */ jsx$1(Portal, { ...portalProps, children: toastList });
};
const createProvider = (providerTheme) => {
  return function ChakraProvider2({
    children,
    theme: theme2 = providerTheme,
    toastOptions,
    ...restProps
  }) {
    return /* @__PURE__ */ jsxs(Provider, { theme: theme2, ...restProps, children: [
      /* @__PURE__ */ jsx$1(ToastOptionProvider, { value: toastOptions == null ? void 0 : toastOptions.defaultOptions, children }),
      /* @__PURE__ */ jsx$1(ToastProvider, { ...toastOptions })
    ] });
  };
};
const ChakraProvider = createProvider(theme$1);
function sortNodes(nodes) {
  return nodes.sort((a, b) => {
    const compare = a.compareDocumentPosition(b);
    if (compare & Node.DOCUMENT_POSITION_FOLLOWING || compare & Node.DOCUMENT_POSITION_CONTAINED_BY) {
      return -1;
    }
    if (compare & Node.DOCUMENT_POSITION_PRECEDING || compare & Node.DOCUMENT_POSITION_CONTAINS) {
      return 1;
    }
    if (compare & Node.DOCUMENT_POSITION_DISCONNECTED || compare & Node.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC) {
      throw Error("Cannot sort the given nodes.");
    } else {
      return 0;
    }
  });
}
const isElement$1 = (el) => typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
function getNextIndex(current, max, loop) {
  let next2 = current + 1;
  if (loop && next2 >= max)
    next2 = 0;
  return next2;
}
function getPrevIndex(current, max, loop) {
  let next2 = current - 1;
  if (loop && next2 < 0)
    next2 = max;
  return next2;
}
const useSafeLayoutEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
const cast = (value) => value;
var __defProp$1 = Object.defineProperty;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => {
  __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class DescendantsManager {
  constructor() {
    __publicField$1(this, "descendants", /* @__PURE__ */ new Map());
    __publicField$1(this, "register", (nodeOrOptions) => {
      if (nodeOrOptions == null)
        return;
      if (isElement$1(nodeOrOptions)) {
        return this.registerNode(nodeOrOptions);
      }
      return (node) => {
        this.registerNode(node, nodeOrOptions);
      };
    });
    __publicField$1(this, "unregister", (node) => {
      this.descendants.delete(node);
      const sorted = sortNodes(Array.from(this.descendants.keys()));
      this.assignIndex(sorted);
    });
    __publicField$1(this, "destroy", () => {
      this.descendants.clear();
    });
    __publicField$1(this, "assignIndex", (descendants) => {
      this.descendants.forEach((descendant) => {
        const index = descendants.indexOf(descendant.node);
        descendant.index = index;
        descendant.node.dataset["index"] = descendant.index.toString();
      });
    });
    __publicField$1(this, "count", () => this.descendants.size);
    __publicField$1(this, "enabledCount", () => this.enabledValues().length);
    __publicField$1(this, "values", () => {
      const values = Array.from(this.descendants.values());
      return values.sort((a, b) => a.index - b.index);
    });
    __publicField$1(this, "enabledValues", () => {
      return this.values().filter((descendant) => !descendant.disabled);
    });
    __publicField$1(this, "item", (index) => {
      if (this.count() === 0)
        return void 0;
      return this.values()[index];
    });
    __publicField$1(this, "enabledItem", (index) => {
      if (this.enabledCount() === 0)
        return void 0;
      return this.enabledValues()[index];
    });
    __publicField$1(this, "first", () => this.item(0));
    __publicField$1(this, "firstEnabled", () => this.enabledItem(0));
    __publicField$1(this, "last", () => this.item(this.descendants.size - 1));
    __publicField$1(this, "lastEnabled", () => {
      const lastIndex = this.enabledValues().length - 1;
      return this.enabledItem(lastIndex);
    });
    __publicField$1(this, "indexOf", (node) => {
      var _a;
      if (!node)
        return -1;
      return ((_a = this.descendants.get(node)) == null ? void 0 : _a.index) ?? -1;
    });
    __publicField$1(this, "enabledIndexOf", (node) => {
      if (node == null)
        return -1;
      return this.enabledValues().findIndex((i) => i.node.isSameNode(node));
    });
    __publicField$1(this, "next", (index, loop = true) => {
      const next2 = getNextIndex(index, this.count(), loop);
      return this.item(next2);
    });
    __publicField$1(this, "nextEnabled", (index, loop = true) => {
      const item = this.item(index);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const nextEnabledIndex = getNextIndex(
        enabledIndex,
        this.enabledCount(),
        loop
      );
      return this.enabledItem(nextEnabledIndex);
    });
    __publicField$1(this, "prev", (index, loop = true) => {
      const prev = getPrevIndex(index, this.count() - 1, loop);
      return this.item(prev);
    });
    __publicField$1(this, "prevEnabled", (index, loop = true) => {
      const item = this.item(index);
      if (!item)
        return;
      const enabledIndex = this.enabledIndexOf(item.node);
      const prevEnabledIndex = getPrevIndex(
        enabledIndex,
        this.enabledCount() - 1,
        loop
      );
      return this.enabledItem(prevEnabledIndex);
    });
    __publicField$1(this, "registerNode", (node, options) => {
      if (!node || this.descendants.has(node))
        return;
      const keys = Array.from(this.descendants.keys()).concat(node);
      const sorted = sortNodes(keys);
      if (options == null ? void 0 : options.disabled) {
        options.disabled = !!options.disabled;
      }
      const descendant = { node, index: -1, ...options };
      this.descendants.set(node, descendant);
      this.assignIndex(sorted);
    });
  }
}
function createDescendantContext() {
  const [DescendantsContextProvider, useDescendantsContext] = createContext$1({
    name: "DescendantsProvider",
    errorMessage: "useDescendantsContext must be used within DescendantsProvider"
  });
  const useDescendant = (options) => {
    const descendants = useDescendantsContext();
    const [index, setIndex] = useState(-1);
    const ref = useRef(null);
    useSafeLayoutEffect(() => {
      return () => {
        if (!ref.current)
          return;
        descendants.unregister(ref.current);
      };
    }, []);
    useSafeLayoutEffect(() => {
      if (!ref.current)
        return;
      const dataIndex = Number(ref.current.dataset["index"]);
      if (index != dataIndex && !Number.isNaN(dataIndex)) {
        setIndex(dataIndex);
      }
    });
    const refCallback = options ? cast(descendants.register(options)) : cast(descendants.register);
    return {
      descendants,
      index,
      enabledIndex: descendants.enabledIndexOf(ref.current),
      register: mergeRefs(refCallback, ref)
    };
  };
  const useDescendants = () => {
    const descendants = useRef(new DescendantsManager());
    useSafeLayoutEffect(() => {
      return () => descendants.current.destroy();
    });
    return descendants.current;
  };
  return [
    // context provider
    DescendantsContextProvider,
    // call this when you need to read from context
    useDescendantsContext,
    // descendants state information, to be called and passed to `ContextProvider`
    useDescendants,
    // descendant index information
    useDescendant
  ];
}
const [AccordionStylesProvider, useAccordionStyles] = createContext$1({
  name: "AccordionStylesContext",
  hookName: "useAccordionStyles",
  providerName: "<Accordion />"
});
const [AccordionItemProvider, useAccordionItemContext] = createContext$1({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItem />"
});
const [
  AccordionDescendantsProvider,
  useAccordionDescendantsContext,
  useAccordionDescendants,
  useAccordionDescendant
] = createDescendantContext();
function useAccordion(props) {
  const {
    onChange,
    defaultIndex,
    index: indexProp,
    allowMultiple,
    allowToggle,
    ...htmlProps
  } = props;
  allowMultipleWarning(props);
  allowMultipleAndAllowToggleWarning(props);
  const descendants = useAccordionDescendants();
  const [focusedIndex, setFocusedIndex] = useState(-1);
  useEffect(() => {
    return () => {
      setFocusedIndex(-1);
    };
  }, []);
  const [index, setIndex] = useControllableState({
    value: indexProp,
    defaultValue() {
      if (allowMultiple)
        return defaultIndex ?? [];
      return defaultIndex ?? -1;
    },
    onChange
  });
  const getAccordionItemProps = (idx) => {
    let isOpen = false;
    if (idx !== null) {
      isOpen = Array.isArray(index) ? index.includes(idx) : index === idx;
    }
    const onChange2 = (isOpen2) => {
      if (idx === null)
        return;
      if (allowMultiple && Array.isArray(index)) {
        const nextState = isOpen2 ? index.concat(idx) : index.filter((i) => i !== idx);
        setIndex(nextState);
      } else if (isOpen2) {
        setIndex(idx);
      } else if (allowToggle) {
        setIndex(-1);
      }
    };
    return { isOpen, onChange: onChange2 };
  };
  return {
    index,
    setIndex,
    htmlProps,
    getAccordionItemProps,
    focusedIndex,
    setFocusedIndex,
    descendants
  };
}
const [AccordionProvider, useAccordionContext] = createContext$1({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "Accordion"
});
function useAccordionItem(props) {
  const { isDisabled, isFocusable, id: id2, ...htmlProps } = props;
  const { getAccordionItemProps, setFocusedIndex } = useAccordionContext();
  const buttonRef = useRef(null);
  const reactId = useId$1();
  const uid = id2 ?? reactId;
  const buttonId = `accordion-button-${uid}`;
  const panelId = `accordion-panel-${uid}`;
  focusableNotDisabledWarning(props);
  const { register, index, descendants } = useAccordionDescendant({
    disabled: isDisabled && !isFocusable
  });
  const { isOpen, onChange } = getAccordionItemProps(
    index === -1 ? null : index
  );
  warnIfOpenAndDisabled({ isOpen, isDisabled });
  const onOpen = () => {
    onChange == null ? void 0 : onChange(true);
  };
  const onClose = () => {
    onChange == null ? void 0 : onChange(false);
  };
  const onClick = useCallback(() => {
    onChange == null ? void 0 : onChange(!isOpen);
    setFocusedIndex(index);
  }, [index, setFocusedIndex, isOpen, onChange]);
  const onKeyDown = useCallback(
    (event) => {
      const keyMap = {
        ArrowDown: () => {
          const next2 = descendants.nextEnabled(index);
          next2 == null ? void 0 : next2.node.focus();
        },
        ArrowUp: () => {
          const prev = descendants.prevEnabled(index);
          prev == null ? void 0 : prev.node.focus();
        },
        Home: () => {
          const first = descendants.firstEnabled();
          first == null ? void 0 : first.node.focus();
        },
        End: () => {
          const last = descendants.lastEnabled();
          last == null ? void 0 : last.node.focus();
        }
      };
      const action = keyMap[event.key];
      if (action) {
        event.preventDefault();
        action(event);
      }
    },
    [descendants, index]
  );
  const onFocus = useCallback(() => {
    setFocusedIndex(index);
  }, [setFocusedIndex, index]);
  const getButtonProps = useCallback(
    function getButtonProps2(props2 = {}, ref = null) {
      return {
        ...props2,
        type: "button",
        ref: mergeRefs(register, buttonRef, ref),
        id: buttonId,
        disabled: !!isDisabled,
        "aria-expanded": !!isOpen,
        "aria-controls": panelId,
        onClick: callAllHandlers(props2.onClick, onClick),
        onFocus: callAllHandlers(props2.onFocus, onFocus),
        onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown)
      };
    },
    [
      buttonId,
      isDisabled,
      isOpen,
      onClick,
      onFocus,
      onKeyDown,
      panelId,
      register
    ]
  );
  const getPanelProps = useCallback(
    function getPanelProps2(props2 = {}, ref = null) {
      return {
        ...props2,
        ref,
        role: "region",
        id: panelId,
        "aria-labelledby": buttonId,
        hidden: !isOpen
      };
    },
    [buttonId, isOpen, panelId]
  );
  return {
    isOpen,
    isDisabled,
    isFocusable,
    onOpen,
    onClose,
    getButtonProps,
    getPanelProps,
    htmlProps
  };
}
function allowMultipleWarning(props) {
  const index = props.index || props.defaultIndex;
  const condition = index != null && !Array.isArray(index) && props.allowMultiple;
  warn({
    condition: !!condition,
    message: `If 'allowMultiple' is passed, then 'index' or 'defaultIndex' must be an array. You passed: ${typeof index},`
  });
}
function allowMultipleAndAllowToggleWarning(props) {
  warn({
    condition: !!(props.allowMultiple && props.allowToggle),
    message: `If 'allowMultiple' is passed, 'allowToggle' will be ignored. Either remove 'allowToggle' or 'allowMultiple' depending on whether you want multiple accordions visible or not`
  });
}
function focusableNotDisabledWarning(props) {
  warn({
    condition: !!(props.isFocusable && !props.isDisabled),
    message: `Using only 'isFocusable', this prop is reserved for situations where you pass 'isDisabled' but you still want the element to receive focus (A11y). Either remove it or pass 'isDisabled' as well.
    `
  });
}
function warnIfOpenAndDisabled(props) {
  warn({
    condition: props.isOpen && !!props.isDisabled,
    message: "Cannot open a disabled accordion item"
  });
}
const Accordion = forwardRef(function Accordion2({ children, reduceMotion, ...props }, ref) {
  const styles2 = useMultiStyleConfig("Accordion", props);
  const ownProps = omitThemingProps(props);
  const { htmlProps, descendants, ...context } = useAccordion(ownProps);
  const ctx = useMemo(
    () => ({ ...context, reduceMotion: !!reduceMotion }),
    [context, reduceMotion]
  );
  return /* @__PURE__ */ jsx$1(AccordionDescendantsProvider, { value: descendants, children: /* @__PURE__ */ jsx$1(AccordionProvider, { value: ctx, children: /* @__PURE__ */ jsx$1(AccordionStylesProvider, { value: styles2, children: /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      ref,
      ...htmlProps,
      className: cx("chakra-accordion", props.className),
      __css: styles2.root,
      children
    }
  ) }) }) });
});
Accordion.displayName = "Accordion";
const AccordionButton = forwardRef(
  function AccordionButton2(props, ref) {
    const { getButtonProps } = useAccordionItemContext();
    const buttonProps = getButtonProps(props, ref);
    const styles2 = useAccordionStyles();
    const buttonStyles = {
      display: "flex",
      alignItems: "center",
      width: "100%",
      outline: 0,
      ...styles2.button
    };
    return /* @__PURE__ */ jsx$1(
      chakra.button,
      {
        ...buttonProps,
        className: cx("chakra-accordion__button", props.className),
        __css: buttonStyles
      }
    );
  }
);
AccordionButton.displayName = "AccordionButton";
function AccordionIcon(props) {
  const { isOpen, isDisabled } = useAccordionItemContext();
  const { reduceMotion } = useAccordionContext();
  const _className = cx("chakra-accordion__icon", props.className);
  const styles2 = useAccordionStyles();
  const iconStyles = {
    opacity: isDisabled ? 0.4 : 1,
    transform: isOpen ? "rotate(-180deg)" : void 0,
    transition: reduceMotion ? void 0 : "transform 0.2s",
    transformOrigin: "center",
    ...styles2.icon
  };
  return /* @__PURE__ */ jsx$1(
    Icon,
    {
      viewBox: "0 0 24 24",
      "aria-hidden": true,
      className: _className,
      __css: iconStyles,
      ...props,
      children: /* @__PURE__ */ jsx$1(
        "path",
        {
          fill: "currentColor",
          d: "M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"
        }
      )
    }
  );
}
AccordionIcon.displayName = "AccordionIcon";
const AccordionItem = forwardRef(
  function AccordionItem2(props, ref) {
    const { children, className } = props;
    const { htmlProps, ...context } = useAccordionItem(props);
    const styles2 = useAccordionStyles();
    const containerStyles = defineStyle({
      ...styles2.container,
      overflowAnchor: "none"
    });
    const ctx = useMemo(() => context, [context]);
    return /* @__PURE__ */ jsx$1(AccordionItemProvider, { value: ctx, children: /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        ...htmlProps,
        className: cx("chakra-accordion__item", className),
        __css: containerStyles,
        children: typeof children === "function" ? children({
          isExpanded: !!context.isOpen,
          isDisabled: !!context.isDisabled
        }) : children
      }
    ) });
  }
);
AccordionItem.displayName = "AccordionItem";
const TRANSITION_EASINGS = {
  ease: [0.25, 0.1, 0.25, 1],
  easeIn: [0.4, 0, 1, 1],
  easeOut: [0, 0, 0.2, 1],
  easeInOut: [0.4, 0, 0.2, 1]
};
const TRANSITION_VARIANTS = {
  scale: {
    enter: { scale: 1 },
    exit: { scale: 0.95 }
  },
  fade: {
    enter: { opacity: 1 },
    exit: { opacity: 0 }
  },
  pushLeft: {
    enter: { x: "100%" },
    exit: { x: "-30%" }
  },
  pushRight: {
    enter: { x: "-100%" },
    exit: { x: "30%" }
  },
  pushUp: {
    enter: { y: "100%" },
    exit: { y: "-30%" }
  },
  pushDown: {
    enter: { y: "-100%" },
    exit: { y: "30%" }
  },
  slideLeft: {
    position: { left: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "-100%", y: 0 }
  },
  slideRight: {
    position: { right: 0, top: 0, bottom: 0, width: "100%" },
    enter: { x: 0, y: 0 },
    exit: { x: "100%", y: 0 }
  },
  slideUp: {
    position: { top: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "-100%" }
  },
  slideDown: {
    position: { bottom: 0, left: 0, right: 0, maxWidth: "100vw" },
    enter: { x: 0, y: 0 },
    exit: { x: 0, y: "100%" }
  }
};
function getSlideTransition(options) {
  const side = (options == null ? void 0 : options.direction) ?? "right";
  switch (side) {
    case "right":
      return TRANSITION_VARIANTS.slideRight;
    case "left":
      return TRANSITION_VARIANTS.slideLeft;
    case "bottom":
      return TRANSITION_VARIANTS.slideDown;
    case "top":
      return TRANSITION_VARIANTS.slideUp;
    default:
      return TRANSITION_VARIANTS.slideRight;
  }
}
const TRANSITION_DEFAULTS = {
  enter: {
    duration: 0.2,
    ease: TRANSITION_EASINGS.easeOut
  },
  exit: {
    duration: 0.1,
    ease: TRANSITION_EASINGS.easeIn
  }
};
const withDelay = {
  enter: (transition2, delay2) => ({
    ...transition2,
    delay: typeof delay2 === "number" ? delay2 : delay2 == null ? void 0 : delay2["enter"]
  }),
  exit: (transition2, delay2) => ({
    ...transition2,
    delay: typeof delay2 === "number" ? delay2 : delay2 == null ? void 0 : delay2["exit"]
  })
};
const isNumeric = (value) => value != null && parseInt(value.toString(), 10) > 0;
const defaultTransitions = {
  exit: {
    height: { duration: 0.2, ease: TRANSITION_EASINGS.ease },
    opacity: { duration: 0.3, ease: TRANSITION_EASINGS.ease }
  },
  enter: {
    height: { duration: 0.3, ease: TRANSITION_EASINGS.ease },
    opacity: { duration: 0.4, ease: TRANSITION_EASINGS.ease }
  }
};
const variants$d = {
  exit: ({
    animateOpacity,
    startingHeight,
    transition: transition2,
    transitionEnd,
    delay: delay2
  }) => ({
    ...animateOpacity && { opacity: isNumeric(startingHeight) ? 1 : 0 },
    height: startingHeight,
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit,
    transition: (transition2 == null ? void 0 : transition2.exit) ?? withDelay.exit(defaultTransitions.exit, delay2)
  }),
  enter: ({
    animateOpacity,
    endingHeight,
    transition: transition2,
    transitionEnd,
    delay: delay2
  }) => ({
    ...animateOpacity && { opacity: 1 },
    height: endingHeight,
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter,
    transition: (transition2 == null ? void 0 : transition2.enter) ?? withDelay.enter(defaultTransitions.enter, delay2)
  })
};
const Collapse = forwardRef$1(
  (props, ref) => {
    const {
      in: isOpen,
      unmountOnExit,
      animateOpacity = true,
      startingHeight = 0,
      endingHeight = "auto",
      style,
      className,
      transition: transition2,
      transitionEnd,
      animatePresenceProps,
      ...rest
    } = props;
    const [mounted, setMounted] = useState(false);
    useEffect(() => {
      const timeout = setTimeout(() => {
        setMounted(true);
      });
      return () => clearTimeout(timeout);
    }, []);
    warn({
      condition: Number(startingHeight) > 0 && !!unmountOnExit,
      message: `startingHeight and unmountOnExit are mutually exclusive. You can't use them together`
    });
    const hasStartingHeight = parseFloat(startingHeight.toString()) > 0;
    const custom = {
      startingHeight,
      endingHeight,
      animateOpacity,
      transition: !mounted ? { enter: { duration: 0 } } : transition2,
      transitionEnd: {
        enter: transitionEnd == null ? void 0 : transitionEnd.enter,
        exit: unmountOnExit ? transitionEnd == null ? void 0 : transitionEnd.exit : {
          ...transitionEnd == null ? void 0 : transitionEnd.exit,
          display: hasStartingHeight ? "block" : "none"
        }
      }
    };
    const show = unmountOnExit ? isOpen : true;
    const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
    return /* @__PURE__ */ jsx$1(
      AnimatePresence,
      {
        ...animatePresenceProps,
        initial: false,
        custom,
        children: show && /* @__PURE__ */ jsx$1(
          motion.div,
          {
            ref,
            ...rest,
            className: cx("chakra-collapse", className),
            style: {
              overflow: "hidden",
              display: "block",
              ...style
            },
            custom,
            variants: variants$d,
            initial: unmountOnExit ? "exit" : false,
            animate: animate2,
            exit: "exit"
          }
        )
      }
    );
  }
);
Collapse.displayName = "Collapse";
const AccordionPanel = forwardRef(
  function AccordionPanel2(props, ref) {
    const { className, motionProps, ...rest } = props;
    const { reduceMotion } = useAccordionContext();
    const { getPanelProps, isOpen } = useAccordionItemContext();
    const panelProps = getPanelProps(rest, ref);
    const _className = cx("chakra-accordion__panel", className);
    const styles2 = useAccordionStyles();
    if (!reduceMotion) {
      delete panelProps.hidden;
    }
    const child = /* @__PURE__ */ jsx$1(chakra.div, { ...panelProps, __css: styles2.panel, className: _className });
    if (!reduceMotion) {
      return /* @__PURE__ */ jsx$1(Collapse, { in: isOpen, ...motionProps, children: child });
    }
    return child;
  }
);
AccordionPanel.displayName = "AccordionPanel";
const [AvatarStylesProvider, useAvatarStyles] = createContext$1({
  name: `AvatarStylesContext`,
  hookName: `useAvatarStyles`,
  providerName: "<Avatar/>"
});
function initials(name2) {
  const names = name2.trim().split(" ");
  const firstName = names[0] ?? "";
  const lastName = names.length > 1 ? names[names.length - 1] : "";
  return firstName && lastName ? `${firstName.charAt(0)}${lastName.charAt(0)}` : firstName.charAt(0);
}
function AvatarName(props) {
  const { name: name2, getInitials, ...rest } = props;
  const styles2 = useAvatarStyles();
  return /* @__PURE__ */ jsx$1(chakra.div, { role: "img", "aria-label": name2, ...rest, __css: styles2.label, children: name2 ? getInitials == null ? void 0 : getInitials(name2) : null });
}
AvatarName.displayName = "AvatarName";
const GenericAvatarIcon = (props) => /* @__PURE__ */ jsxs(
  chakra.svg,
  {
    viewBox: "0 0 128 128",
    color: "#fff",
    width: "100%",
    height: "100%",
    className: "chakra-avatar__svg",
    ...props,
    children: [
      /* @__PURE__ */ jsx$1(
        "path",
        {
          fill: "currentColor",
          d: "M103,102.1388 C93.094,111.92 79.3504,118 64.1638,118 C48.8056,118 34.9294,111.768 25,101.7892 L25,95.2 C25,86.8096 31.981,80 40.6,80 L87.4,80 C96.019,80 103,86.8096 103,95.2 L103,102.1388 Z"
        }
      ),
      /* @__PURE__ */ jsx$1(
        "path",
        {
          fill: "currentColor",
          d: "M63.9961647,24 C51.2938136,24 41,34.2938136 41,46.9961647 C41,59.7061864 51.2938136,70 63.9961647,70 C76.6985159,70 87,59.7061864 87,46.9961647 C87,34.2938136 76.6985159,24 63.9961647,24"
        }
      )
    ]
  }
);
function useImage(props) {
  const {
    loading,
    src,
    srcSet,
    onLoad,
    onError,
    crossOrigin,
    sizes: sizes2,
    ignoreFallback
  } = props;
  const [status, setStatus] = useState("pending");
  useEffect(() => {
    setStatus(src ? "loading" : "pending");
  }, [src]);
  const imageRef = useRef();
  const load = useCallback(() => {
    if (!src)
      return;
    flush();
    const img = new Image();
    img.src = src;
    if (crossOrigin)
      img.crossOrigin = crossOrigin;
    if (srcSet)
      img.srcset = srcSet;
    if (sizes2)
      img.sizes = sizes2;
    if (loading)
      img.loading = loading;
    img.onload = (event) => {
      flush();
      setStatus("loaded");
      onLoad == null ? void 0 : onLoad(event);
    };
    img.onerror = (error) => {
      flush();
      setStatus("failed");
      onError == null ? void 0 : onError(error);
    };
    imageRef.current = img;
  }, [src, crossOrigin, srcSet, sizes2, onLoad, onError, loading]);
  const flush = () => {
    if (imageRef.current) {
      imageRef.current.onload = null;
      imageRef.current.onerror = null;
      imageRef.current = null;
    }
  };
  useSafeLayoutEffect$2(() => {
    if (ignoreFallback)
      return void 0;
    if (status === "loading") {
      load();
    }
    return () => {
      flush();
    };
  }, [status, load, ignoreFallback]);
  return ignoreFallback ? "loaded" : status;
}
const shouldShowFallbackImage = (status, fallbackStrategy) => status !== "loaded" && fallbackStrategy === "beforeLoadOrError" || status === "failed" && fallbackStrategy === "onError";
function AvatarImage(props) {
  const {
    src,
    srcSet,
    onError,
    onLoad,
    getInitials,
    name: name2,
    borderRadius,
    loading,
    iconLabel,
    icon = /* @__PURE__ */ jsx$1(GenericAvatarIcon, {}),
    ignoreFallback,
    referrerPolicy,
    crossOrigin
  } = props;
  const status = useImage({ src, onError, crossOrigin, ignoreFallback });
  const hasLoaded = status === "loaded";
  const showFallback = !src || !hasLoaded;
  if (showFallback) {
    return name2 ? /* @__PURE__ */ jsx$1(
      AvatarName,
      {
        className: "chakra-avatar__initials",
        getInitials,
        name: name2
      }
    ) : cloneElement(icon, {
      role: "img",
      "aria-label": iconLabel
    });
  }
  return /* @__PURE__ */ jsx$1(
    chakra.img,
    {
      src,
      srcSet,
      alt: name2 ?? iconLabel,
      onLoad,
      referrerPolicy,
      crossOrigin: crossOrigin ?? void 0,
      className: "chakra-avatar__img",
      loading,
      __css: {
        width: "100%",
        height: "100%",
        objectFit: "cover",
        borderRadius
      }
    }
  );
}
AvatarImage.displayName = "AvatarImage";
const baseStyle$e = defineStyle({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  textAlign: "center",
  textTransform: "uppercase",
  fontWeight: "medium",
  position: "relative",
  flexShrink: 0
});
const Avatar = forwardRef((props, ref) => {
  const styles2 = useMultiStyleConfig("Avatar", props);
  const [isLoaded, setIsLoaded] = useState(false);
  const {
    src,
    srcSet,
    name: name2,
    showBorder,
    borderRadius = "full",
    onError,
    onLoad: onLoadProp,
    getInitials = initials,
    icon = /* @__PURE__ */ jsx$1(GenericAvatarIcon, {}),
    iconLabel = " avatar",
    loading,
    children,
    borderColor,
    ignoreFallback,
    crossOrigin,
    referrerPolicy,
    ...rest
  } = omitThemingProps(props);
  const avatarStyles = {
    borderRadius,
    borderWidth: showBorder ? "2px" : void 0,
    ...baseStyle$e,
    ...styles2.container
  };
  if (borderColor) {
    avatarStyles.borderColor = borderColor;
  }
  return /* @__PURE__ */ jsx$1(
    chakra.span,
    {
      ref,
      ...rest,
      className: cx("chakra-avatar", props.className),
      "data-loaded": dataAttr(isLoaded),
      __css: avatarStyles,
      children: /* @__PURE__ */ jsxs(AvatarStylesProvider, { value: styles2, children: [
        /* @__PURE__ */ jsx$1(
          AvatarImage,
          {
            src,
            srcSet,
            loading,
            onLoad: callAllHandlers(onLoadProp, () => {
              setIsLoaded(true);
            }),
            onError,
            getInitials,
            name: name2,
            borderRadius,
            icon,
            iconLabel,
            ignoreFallback,
            crossOrigin,
            referrerPolicy
          }
        ),
        children
      ] })
    }
  );
});
Avatar.displayName = "Avatar";
const placementMap$1 = {
  "top-start": {
    top: "0",
    insetStart: "0",
    transform: "translate(-25%, -25%)"
  },
  "top-end": {
    top: "0",
    insetEnd: "0",
    transform: "translate(25%, -25%)"
  },
  "bottom-start": {
    bottom: "0",
    insetStart: "0",
    transform: "translate(-25%, 25%)"
  },
  "bottom-end": {
    bottom: "0",
    insetEnd: "0",
    transform: "translate(25%, 25%)"
  }
};
const AvatarBadge = forwardRef(
  function AvatarBadge2(props, ref) {
    const { placement = "bottom-end", className, ...rest } = props;
    const styles2 = useAvatarStyles();
    const placementStyles = placementMap$1[placement];
    const badgeStyles = {
      position: "absolute",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      ...placementStyles,
      ...styles2.badge
    };
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        ...rest,
        className: cx("chakra-avatar__badge", className),
        __css: badgeStyles
      }
    );
  }
);
AvatarBadge.displayName = "AvatarBadge";
const Badge = forwardRef(function Badge2(props, ref) {
  const styles2 = useStyleConfig("Badge", props);
  const { className, ...rest } = omitThemingProps(props);
  return /* @__PURE__ */ jsx$1(
    chakra.span,
    {
      ref,
      className: cx("chakra-badge", props.className),
      ...rest,
      __css: {
        display: "inline-block",
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        ...styles2
      }
    }
  );
});
Badge.displayName = "Badge";
const Box = chakra("div");
Box.displayName = "Box";
const Square = forwardRef(
  function Square2(props, ref) {
    const { size, centerContent = true, ...rest } = props;
    const styles2 = centerContent ? { display: "flex", alignItems: "center", justifyContent: "center" } : {};
    return /* @__PURE__ */ jsx$1(
      Box,
      {
        ref,
        boxSize: size,
        __css: {
          ...styles2,
          flexShrink: 0,
          flexGrow: 0
        },
        ...rest
      }
    );
  }
);
Square.displayName = "Square";
const Circle = forwardRef(
  function Circle2(props, ref) {
    const { size, ...rest } = props;
    return /* @__PURE__ */ jsx$1(Square, { size, ref, borderRadius: "9999px", ...rest });
  }
);
Circle.displayName = "Circle";
const [ButtonGroupProvider, useButtonGroup] = createContext$1({
  strict: false,
  name: "ButtonGroupContext"
});
function ButtonIcon(props) {
  const { children, className, ...rest } = props;
  const _children = isValidElement$1(children) ? cloneElement(children, {
    "aria-hidden": true,
    focusable: false
  }) : children;
  const _className = cx("chakra-button__icon", className);
  return /* @__PURE__ */ jsx$1(
    chakra.span,
    {
      display: "inline-flex",
      alignSelf: "center",
      flexShrink: 0,
      ...rest,
      className: _className,
      children: _children
    }
  );
}
ButtonIcon.displayName = "ButtonIcon";
function ButtonSpinner(props) {
  const {
    label,
    placement,
    spacing = "0.5rem",
    children = /* @__PURE__ */ jsx$1(Spinner, { color: "currentColor", width: "1em", height: "1em" }),
    className,
    __css,
    ...rest
  } = props;
  const _className = cx("chakra-button__spinner", className);
  const marginProp = placement === "start" ? "marginEnd" : "marginStart";
  const spinnerStyles = useMemo(
    () => defineStyle({
      display: "flex",
      alignItems: "center",
      position: label ? "relative" : "absolute",
      [marginProp]: label ? spacing : 0,
      fontSize: "1em",
      lineHeight: "normal",
      ...__css
    }),
    [__css, label, marginProp, spacing]
  );
  return /* @__PURE__ */ jsx$1(chakra.div, { className: _className, ...rest, __css: spinnerStyles, children });
}
ButtonSpinner.displayName = "ButtonSpinner";
function useButtonType(value) {
  const [isButton, setIsButton] = useState(!value);
  const refCallback = useCallback((node) => {
    if (!node)
      return;
    setIsButton(node.tagName === "BUTTON");
  }, []);
  const type2 = isButton ? "button" : void 0;
  return { ref: refCallback, type: type2 };
}
const Button = forwardRef((props, ref) => {
  const group = useButtonGroup();
  const styles2 = useStyleConfig("Button", { ...group, ...props });
  const {
    isDisabled = group == null ? void 0 : group.isDisabled,
    isLoading,
    isActive,
    children,
    leftIcon,
    rightIcon,
    loadingText,
    iconSpacing = "0.5rem",
    type: type2,
    spinner,
    spinnerPlacement = "start",
    className,
    as,
    shouldWrapChildren,
    ...rest
  } = omitThemingProps(props);
  const buttonStyles = useMemo(() => {
    const _focus = { ...styles2 == null ? void 0 : styles2["_focus"], zIndex: 1 };
    return {
      display: "inline-flex",
      appearance: "none",
      alignItems: "center",
      justifyContent: "center",
      userSelect: "none",
      position: "relative",
      whiteSpace: "nowrap",
      verticalAlign: "middle",
      outline: "none",
      ...styles2,
      ...!!group && { _focus }
    };
  }, [styles2, group]);
  const { ref: _ref, type: defaultType } = useButtonType(as);
  const contentProps = {
    rightIcon,
    leftIcon,
    iconSpacing,
    children,
    shouldWrapChildren
  };
  return /* @__PURE__ */ jsxs(
    chakra.button,
    {
      disabled: isDisabled || isLoading,
      ref: useMergeRefs(ref, _ref),
      as,
      type: type2 ?? defaultType,
      "data-active": dataAttr(isActive),
      "data-loading": dataAttr(isLoading),
      __css: buttonStyles,
      className: cx("chakra-button", className),
      ...rest,
      children: [
        isLoading && spinnerPlacement === "start" && /* @__PURE__ */ jsx$1(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--start",
            label: loadingText,
            placement: "start",
            spacing: iconSpacing,
            children: spinner
          }
        ),
        isLoading ? loadingText || /* @__PURE__ */ jsx$1(chakra.span, { opacity: 0, children: /* @__PURE__ */ jsx$1(ButtonContent, { ...contentProps }) }) : /* @__PURE__ */ jsx$1(ButtonContent, { ...contentProps }),
        isLoading && spinnerPlacement === "end" && /* @__PURE__ */ jsx$1(
          ButtonSpinner,
          {
            className: "chakra-button__spinner--end",
            label: loadingText,
            placement: "end",
            spacing: iconSpacing,
            children: spinner
          }
        )
      ]
    }
  );
});
Button.displayName = "Button";
function ButtonContent(props) {
  const { leftIcon, rightIcon, children, iconSpacing, shouldWrapChildren } = props;
  if (!shouldWrapChildren) {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      leftIcon && /* @__PURE__ */ jsx$1(ButtonIcon, { marginEnd: iconSpacing, children: leftIcon }),
      children,
      rightIcon && /* @__PURE__ */ jsx$1(ButtonIcon, { marginStart: iconSpacing, children: rightIcon })
    ] });
  }
  return /* @__PURE__ */ jsxs("span", { style: { display: "contents" }, children: [
    leftIcon && /* @__PURE__ */ jsx$1(ButtonIcon, { marginEnd: iconSpacing, children: leftIcon }),
    children,
    rightIcon && /* @__PURE__ */ jsx$1(ButtonIcon, { marginStart: iconSpacing, children: rightIcon })
  ] });
}
const attachedStyles = {
  horizontal: {
    "> *:first-of-type:not(:last-of-type)": { borderEndRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderStartRadius: 0 }
  },
  vertical: {
    "> *:first-of-type:not(:last-of-type)": { borderBottomRadius: 0 },
    "> *:not(:first-of-type):not(:last-of-type)": { borderRadius: 0 },
    "> *:not(:first-of-type):last-of-type": { borderTopRadius: 0 }
  }
};
const gapStyles = {
  horizontal: (spacing) => ({
    "& > *:not(style) ~ *:not(style)": { marginStart: spacing }
  }),
  vertical: (spacing) => ({
    "& > *:not(style) ~ *:not(style)": { marginTop: spacing }
  })
};
const ButtonGroup = forwardRef(
  function ButtonGroup2(props, ref) {
    const {
      size,
      colorScheme,
      variant,
      className,
      spacing = "0.5rem",
      isAttached,
      isDisabled,
      orientation = "horizontal",
      ...rest
    } = props;
    const _className = cx("chakra-button__group", className);
    const context = useMemo(
      () => ({ size, colorScheme, variant, isDisabled }),
      [size, colorScheme, variant, isDisabled]
    );
    let groupStyles = {
      display: "inline-flex",
      ...isAttached ? attachedStyles[orientation] : gapStyles[orientation](spacing)
    };
    const isVertical = orientation === "vertical";
    return /* @__PURE__ */ jsx$1(ButtonGroupProvider, { value: context, children: /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        role: "group",
        __css: groupStyles,
        className: _className,
        "data-attached": isAttached ? "" : void 0,
        "data-orientation": orientation,
        flexDir: isVertical ? "column" : void 0,
        ...rest
      }
    ) });
  }
);
ButtonGroup.displayName = "ButtonGroup";
const IconButton = forwardRef(
  (props, ref) => {
    const { icon, children, isRound, "aria-label": ariaLabel, ...rest } = props;
    const element = icon || children;
    const _children = isValidElement$1(element) ? cloneElement(element, {
      "aria-hidden": true,
      focusable: false
    }) : null;
    return /* @__PURE__ */ jsx$1(
      Button,
      {
        px: "0",
        py: "0",
        borderRadius: isRound ? "full" : void 0,
        ref,
        "aria-label": ariaLabel,
        ...rest,
        children: _children
      }
    );
  }
);
IconButton.displayName = "IconButton";
const [CardStylesProvider, useCardStyles] = createStylesContext("Card");
const Card = forwardRef(function Card2(props, ref) {
  const {
    className,
    children,
    direction = "column",
    justify,
    align,
    ...rest
  } = omitThemingProps(props);
  const styles2 = useMultiStyleConfig("Card", props);
  return /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      ref,
      className: cx("chakra-card", className),
      __css: {
        display: "flex",
        flexDirection: direction,
        justifyContent: justify,
        alignItems: align,
        position: "relative",
        minWidth: 0,
        wordWrap: "break-word",
        ...styles2.container
      },
      ...rest,
      children: /* @__PURE__ */ jsx$1(CardStylesProvider, { value: styles2, children })
    }
  );
});
const CardHeader = forwardRef(
  function CardHeader2(props, ref) {
    const { className, ...rest } = props;
    const styles2 = useCardStyles();
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        className: cx("chakra-card__header", className),
        __css: styles2.header,
        ...rest
      }
    );
  }
);
const Center = chakra("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }
});
Center.displayName = "Center";
const centerStyles = {
  horizontal: {
    insetStart: "50%",
    transform: "translateX(-50%)"
  },
  vertical: {
    top: "50%",
    transform: "translateY(-50%)"
  },
  both: {
    insetStart: "50%",
    top: "50%",
    transform: "translate(-50%, -50%)"
  }
};
forwardRef(
  function AbsoluteCenter2(props, ref) {
    const { axis = "both", ...rest } = props;
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        __css: centerStyles[axis],
        ...rest,
        position: "absolute"
      }
    );
  }
);
const [CheckboxGroupProvider, useCheckboxGroupContext] = createContext$2({
  name: "CheckboxGroupContext",
  strict: false
});
function CheckIcon(props) {
  return /* @__PURE__ */ jsx$1(
    chakra.svg,
    {
      width: "1.2em",
      viewBox: "0 0 12 10",
      style: {
        fill: "none",
        strokeWidth: 2,
        stroke: "currentColor",
        strokeDasharray: 16
      },
      ...props,
      children: /* @__PURE__ */ jsx$1("polyline", { points: "1.5 6 4.5 9 10.5 1" })
    }
  );
}
function IndeterminateIcon(props) {
  return /* @__PURE__ */ jsx$1(
    chakra.svg,
    {
      width: "1.2em",
      viewBox: "0 0 24 24",
      style: { stroke: "currentColor", strokeWidth: 4 },
      ...props,
      children: /* @__PURE__ */ jsx$1("line", { x1: "21", x2: "3", y1: "12", y2: "12" })
    }
  );
}
function CheckboxIcon(props) {
  const { isIndeterminate, isChecked, ...rest } = props;
  const BaseIcon = isIndeterminate ? IndeterminateIcon : CheckIcon;
  return isChecked || isIndeterminate ? /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      style: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: "100%"
      },
      children: /* @__PURE__ */ jsx$1(BaseIcon, { ...rest })
    }
  ) : null;
}
const [FormControlStylesProvider, useFormControlStyles] = createContext$1({
  name: `FormControlStylesContext`,
  errorMessage: `useFormControlStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormControl />" `
});
const [FormControlProvider, useFormControlContext] = createContext$1({
  strict: false,
  name: "FormControlContext"
});
function useFormControlProvider(props) {
  const {
    id: idProp,
    isRequired,
    isInvalid,
    isDisabled,
    isReadOnly,
    ...htmlProps
  } = props;
  const uuid = useId$1();
  const id2 = idProp || `field-${uuid}`;
  const labelId = `${id2}-label`;
  const feedbackId = `${id2}-feedback`;
  const helpTextId = `${id2}-helptext`;
  const [hasFeedbackText, setHasFeedbackText] = useState(false);
  const [hasHelpText, setHasHelpText] = useState(false);
  const [isFocused, setFocus] = useState(false);
  const getHelpTextProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      id: helpTextId,
      ...props2,
      /**
       * Notify the field context when the help text is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: mergeRefs(forwardedRef, (node) => {
        if (!node)
          return;
        setHasHelpText(true);
      })
    }),
    [helpTextId]
  );
  const getLabelProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly),
      id: props2.id !== void 0 ? props2.id : labelId,
      htmlFor: props2.htmlFor !== void 0 ? props2.htmlFor : id2
    }),
    [id2, isDisabled, isFocused, isInvalid, isReadOnly, labelId]
  );
  const getErrorMessageProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      id: feedbackId,
      ...props2,
      /**
       * Notify the field context when the error message is rendered on screen,
       * so we can apply the correct `aria-describedby` to the field (e.g. input, textarea).
       */
      ref: mergeRefs(forwardedRef, (node) => {
        if (!node)
          return;
        setHasFeedbackText(true);
      }),
      "aria-live": "polite"
    }),
    [feedbackId]
  );
  const getRootProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ...htmlProps,
      ref: forwardedRef,
      role: "group",
      "data-focus": dataAttr(isFocused),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly)
    }),
    [htmlProps, isDisabled, isFocused, isInvalid, isReadOnly]
  );
  const getRequiredIndicatorProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      role: "presentation",
      "aria-hidden": true,
      children: props2.children || "*"
    }),
    []
  );
  return {
    isRequired: !!isRequired,
    isInvalid: !!isInvalid,
    isReadOnly: !!isReadOnly,
    isDisabled: !!isDisabled,
    isFocused: !!isFocused,
    onFocus: () => setFocus(true),
    onBlur: () => setFocus(false),
    hasFeedbackText,
    setHasFeedbackText,
    hasHelpText,
    setHasHelpText,
    id: id2,
    labelId,
    feedbackId,
    helpTextId,
    htmlProps,
    getHelpTextProps,
    getErrorMessageProps,
    getRootProps,
    getLabelProps,
    getRequiredIndicatorProps
  };
}
const FormControl = forwardRef(
  function FormControl2(props, ref) {
    const styles2 = useMultiStyleConfig("Form", props);
    const ownProps = omitThemingProps(props);
    const {
      getRootProps,
      htmlProps: _2,
      ...context
    } = useFormControlProvider(ownProps);
    const className = cx("chakra-form-control", props.className);
    return /* @__PURE__ */ jsx$1(FormControlProvider, { value: context, children: /* @__PURE__ */ jsx$1(FormControlStylesProvider, { value: styles2, children: /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ...getRootProps({}, ref),
        className,
        __css: styles2["container"]
      }
    ) }) });
  }
);
FormControl.displayName = "FormControl";
const FormHelperText = forwardRef(
  function FormHelperText2(props, ref) {
    const field = useFormControlContext();
    const styles2 = useFormControlStyles();
    const className = cx("chakra-form__helper-text", props.className);
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ...field == null ? void 0 : field.getHelpTextProps(props, ref),
        __css: styles2.helperText,
        className
      }
    );
  }
);
FormHelperText.displayName = "FormHelperText";
function useFormControl(props) {
  const { isDisabled, isInvalid, isReadOnly, isRequired, ...rest } = useFormControlProps(props);
  return {
    ...rest,
    disabled: isDisabled,
    readOnly: isReadOnly,
    required: isRequired,
    "aria-invalid": ariaAttr(isInvalid),
    "aria-required": ariaAttr(isRequired),
    "aria-readonly": ariaAttr(isReadOnly)
  };
}
function useFormControlProps(props) {
  const field = useFormControlContext();
  const {
    id: id2,
    disabled,
    readOnly,
    required,
    isRequired,
    isInvalid,
    isReadOnly,
    isDisabled,
    onFocus,
    onBlur,
    ...rest
  } = props;
  const labelIds = props["aria-describedby"] ? [props["aria-describedby"]] : [];
  if ((field == null ? void 0 : field.hasFeedbackText) && (field == null ? void 0 : field.isInvalid)) {
    labelIds.push(field.feedbackId);
  }
  if (field == null ? void 0 : field.hasHelpText) {
    labelIds.push(field.helpTextId);
  }
  return {
    ...rest,
    "aria-describedby": labelIds.join(" ") || void 0,
    id: id2 ?? (field == null ? void 0 : field.id),
    isDisabled: disabled ?? isDisabled ?? (field == null ? void 0 : field.isDisabled),
    isReadOnly: readOnly ?? isReadOnly ?? (field == null ? void 0 : field.isReadOnly),
    isRequired: required ?? isRequired ?? (field == null ? void 0 : field.isRequired),
    isInvalid: isInvalid ?? (field == null ? void 0 : field.isInvalid),
    onFocus: callAllHandlers(field == null ? void 0 : field.onFocus, onFocus),
    onBlur: callAllHandlers(field == null ? void 0 : field.onBlur, onBlur)
  };
}
const visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0, 0, 0, 0)",
  height: "1px",
  width: "1px",
  margin: "-1px",
  padding: "0",
  overflow: "hidden",
  whiteSpace: "nowrap",
  position: "absolute"
};
function useCheckbox(props = {}) {
  const formControlProps = useFormControlProps(props);
  const {
    isDisabled,
    isReadOnly,
    isRequired,
    isInvalid,
    id: id2,
    onBlur,
    onFocus,
    "aria-describedby": ariaDescribedBy
  } = formControlProps;
  const {
    defaultChecked,
    isChecked: checkedProp,
    isFocusable,
    onChange,
    isIndeterminate,
    name: name2,
    value,
    tabIndex = void 0,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-invalid": ariaInvalid,
    ...rest
  } = props;
  const htmlProps = omit(rest, [
    "isDisabled",
    "isReadOnly",
    "isRequired",
    "isInvalid",
    "id",
    "onBlur",
    "onFocus",
    "aria-describedby"
  ]);
  const onChangeProp = useCallbackRef(onChange);
  const onBlurProp = useCallbackRef(onBlur);
  const onFocusProp = useCallbackRef(onFocus);
  const [isFocusVisible, setIsFocusVisible] = useState(false);
  const [isFocused, setFocused] = useState(false);
  const [isHovered, setHovered] = useState(false);
  const [isActive, setActive] = useState(false);
  useEffect(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  const inputRef = useRef(null);
  const [rootIsLabelElement, setRootIsLabelElement] = useState(true);
  const [checkedState, setCheckedState] = useState(!!defaultChecked);
  const isControlled = checkedProp !== void 0;
  const isChecked = isControlled ? checkedProp : checkedState;
  const handleChange = useCallback(
    (event) => {
      if (isReadOnly || isDisabled) {
        event.preventDefault();
        return;
      }
      if (!isControlled) {
        if (isChecked) {
          setCheckedState(event.currentTarget.checked);
        } else {
          setCheckedState(isIndeterminate ? true : event.currentTarget.checked);
        }
      }
      onChangeProp == null ? void 0 : onChangeProp(event);
    },
    [
      isReadOnly,
      isDisabled,
      isChecked,
      isControlled,
      isIndeterminate,
      onChangeProp
    ]
  );
  useSafeLayoutEffect$2(() => {
    if (inputRef.current) {
      inputRef.current.indeterminate = Boolean(isIndeterminate);
    }
  }, [isIndeterminate]);
  useUpdateEffect(() => {
    if (isDisabled) {
      setFocused(false);
    }
  }, [isDisabled, setFocused]);
  useSafeLayoutEffect$2(() => {
    const el = inputRef.current;
    if (!(el == null ? void 0 : el.form))
      return;
    const formResetListener = () => {
      setCheckedState(!!defaultChecked);
    };
    el.form.addEventListener("reset", formResetListener);
    return () => {
      var _a;
      return (_a = el.form) == null ? void 0 : _a.removeEventListener("reset", formResetListener);
    };
  }, []);
  const trulyDisabled = isDisabled && !isFocusable;
  const onKeyDown = useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(true);
      }
    },
    [setActive]
  );
  const onKeyUp = useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(false);
      }
    },
    [setActive]
  );
  useSafeLayoutEffect$2(() => {
    if (!inputRef.current)
      return;
    const notInSync = inputRef.current.checked !== isChecked;
    if (notInSync) {
      setCheckedState(inputRef.current.checked);
    }
  }, [inputRef.current]);
  const getCheckboxProps = useCallback(
    (props2 = {}, forwardedRef = null) => {
      const onPressDown = (event) => {
        if (isFocused) {
          event.preventDefault();
        }
        setActive(true);
      };
      return {
        ...props2,
        ref: forwardedRef,
        "data-active": dataAttr(isActive),
        "data-hover": dataAttr(isHovered),
        "data-checked": dataAttr(isChecked),
        "data-focus": dataAttr(isFocused),
        "data-focus-visible": dataAttr(isFocused && isFocusVisible),
        "data-indeterminate": dataAttr(isIndeterminate),
        "data-disabled": dataAttr(isDisabled),
        "data-invalid": dataAttr(isInvalid),
        "data-readonly": dataAttr(isReadOnly),
        "aria-hidden": true,
        onMouseDown: callAllHandlers(props2.onMouseDown, onPressDown),
        onMouseUp: callAllHandlers(props2.onMouseUp, () => setActive(false)),
        onMouseEnter: callAllHandlers(
          props2.onMouseEnter,
          () => setHovered(true)
        ),
        onMouseLeave: callAllHandlers(
          props2.onMouseLeave,
          () => setHovered(false)
        )
      };
    },
    [
      isActive,
      isChecked,
      isDisabled,
      isFocused,
      isFocusVisible,
      isHovered,
      isIndeterminate,
      isInvalid,
      isReadOnly
    ]
  );
  const getIndicatorProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-checked": dataAttr(isChecked),
      "data-focus": dataAttr(isFocused),
      "data-focus-visible": dataAttr(isFocused && isFocusVisible),
      "data-indeterminate": dataAttr(isIndeterminate),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-readonly": dataAttr(isReadOnly)
    }),
    [
      isActive,
      isChecked,
      isDisabled,
      isFocused,
      isFocusVisible,
      isHovered,
      isIndeterminate,
      isInvalid,
      isReadOnly
    ]
  );
  const getRootProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...htmlProps,
      ...props2,
      ref: mergeRefs(forwardedRef, (node) => {
        if (!node)
          return;
        setRootIsLabelElement(node.tagName === "LABEL");
      }),
      onClick: callAllHandlers(props2.onClick, () => {
        var _a;
        if (!rootIsLabelElement) {
          (_a = inputRef.current) == null ? void 0 : _a.click();
          requestAnimationFrame(() => {
            var _a2;
            (_a2 = inputRef.current) == null ? void 0 : _a2.focus({ preventScroll: true });
          });
        }
      }),
      "data-disabled": dataAttr(isDisabled),
      "data-checked": dataAttr(isChecked),
      "data-invalid": dataAttr(isInvalid)
    }),
    [htmlProps, isDisabled, isChecked, isInvalid, rootIsLabelElement]
  );
  const getInputProps = useCallback(
    (props2 = {}, forwardedRef = null) => {
      return {
        ...props2,
        ref: mergeRefs(inputRef, forwardedRef),
        type: "checkbox",
        name: name2,
        value,
        id: id2,
        tabIndex,
        onChange: callAllHandlers(props2.onChange, handleChange),
        onBlur: callAllHandlers(
          props2.onBlur,
          onBlurProp,
          () => setFocused(false)
        ),
        onFocus: callAllHandlers(
          props2.onFocus,
          onFocusProp,
          () => setFocused(true)
        ),
        onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),
        onKeyUp: callAllHandlers(props2.onKeyUp, onKeyUp),
        required: isRequired,
        checked: isChecked,
        disabled: trulyDisabled,
        readOnly: isReadOnly,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-invalid": ariaInvalid ? Boolean(ariaInvalid) : isInvalid,
        "aria-describedby": ariaDescribedBy,
        "aria-disabled": isDisabled,
        style: visuallyHiddenStyle
      };
    },
    [
      name2,
      value,
      id2,
      handleChange,
      onBlurProp,
      onFocusProp,
      onKeyDown,
      onKeyUp,
      isRequired,
      isChecked,
      trulyDisabled,
      isReadOnly,
      ariaLabel,
      ariaLabelledBy,
      ariaInvalid,
      isInvalid,
      ariaDescribedBy,
      isDisabled,
      tabIndex
    ]
  );
  const getLabelProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: forwardedRef,
      onMouseDown: callAllHandlers(props2.onMouseDown, stopEvent$1),
      "data-disabled": dataAttr(isDisabled),
      "data-checked": dataAttr(isChecked),
      "data-invalid": dataAttr(isInvalid)
    }),
    [isChecked, isDisabled, isInvalid]
  );
  const state2 = {
    isInvalid,
    isFocused,
    isChecked,
    isActive,
    isHovered,
    isIndeterminate,
    isDisabled,
    isReadOnly,
    isRequired
  };
  return {
    state: state2,
    getRootProps,
    getCheckboxProps,
    getIndicatorProps,
    getInputProps,
    getLabelProps,
    htmlProps
  };
}
function stopEvent$1(event) {
  event.preventDefault();
  event.stopPropagation();
}
function useInitialAnimationState(isChecked) {
  const [previousIsChecked, setPreviousIsChecked] = useState(isChecked);
  const [shouldAnimate, setShouldAnimate] = useState(false);
  if (isChecked !== previousIsChecked) {
    setShouldAnimate(true);
    setPreviousIsChecked(isChecked);
  }
  return shouldAnimate;
}
const controlStyles = {
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  verticalAlign: "top",
  userSelect: "none",
  flexShrink: 0
};
const rootStyles = {
  cursor: "pointer",
  display: "inline-flex",
  alignItems: "center",
  verticalAlign: "top",
  position: "relative"
};
const checkAnim = keyframes$1({
  from: {
    opacity: 0,
    strokeDashoffset: 16,
    transform: "scale(0.95)"
  },
  to: {
    opacity: 1,
    strokeDashoffset: 0,
    transform: "scale(1)"
  }
});
const indeterminateOpacityAnim = keyframes$1({
  from: {
    opacity: 0
  },
  to: {
    opacity: 1
  }
});
const indeterminateScaleAnim = keyframes$1({
  from: {
    transform: "scaleX(0.65)"
  },
  to: {
    transform: "scaleX(1)"
  }
});
const Checkbox = forwardRef(
  function Checkbox2(props, ref) {
    const group = useCheckboxGroupContext();
    const mergedProps = { ...group, ...props };
    const styles2 = useMultiStyleConfig("Checkbox", mergedProps);
    const ownProps = omitThemingProps(props);
    const {
      spacing = "0.5rem",
      className,
      children,
      iconColor,
      iconSize,
      icon = /* @__PURE__ */ jsx$1(CheckboxIcon, {}),
      isChecked: isCheckedProp,
      isDisabled = group == null ? void 0 : group.isDisabled,
      onChange: onChangeProp,
      inputProps,
      ...rest
    } = ownProps;
    let isChecked = isCheckedProp;
    if ((group == null ? void 0 : group.value) && ownProps.value) {
      isChecked = group.value.includes(ownProps.value);
    }
    let onChange = onChangeProp;
    if ((group == null ? void 0 : group.onChange) && ownProps.value) {
      onChange = callAll(group.onChange, onChangeProp);
    }
    const {
      state: state2,
      getInputProps,
      getCheckboxProps,
      getLabelProps,
      getRootProps
    } = useCheckbox({
      ...rest,
      isDisabled,
      isChecked,
      onChange
    });
    const shouldAnimate = useInitialAnimationState(state2.isChecked);
    const iconStyles = useMemo(
      () => ({
        animation: !shouldAnimate ? void 0 : state2.isIndeterminate ? `${indeterminateOpacityAnim} 20ms linear, ${indeterminateScaleAnim} 200ms linear` : `${checkAnim} 200ms linear`,
        ...styles2.icon,
        ...compact$1({
          fontSize: iconSize,
          color: iconColor
        })
      }),
      [iconColor, iconSize, shouldAnimate, state2.isIndeterminate, styles2.icon]
    );
    const clonedIcon = cloneElement(icon, {
      __css: iconStyles,
      isIndeterminate: state2.isIndeterminate,
      isChecked: state2.isChecked
    });
    return /* @__PURE__ */ jsxs(
      chakra.label,
      {
        __css: { ...rootStyles, ...styles2.container },
        className: cx("chakra-checkbox", className),
        ...getRootProps(),
        children: [
          /* @__PURE__ */ jsx$1(
            "input",
            {
              className: "chakra-checkbox__input",
              ...getInputProps(inputProps, ref)
            }
          ),
          /* @__PURE__ */ jsx$1(
            chakra.span,
            {
              __css: { ...controlStyles, ...styles2.control },
              className: "chakra-checkbox__control",
              ...getCheckboxProps(),
              children: clonedIcon
            }
          ),
          children && /* @__PURE__ */ jsx$1(
            chakra.span,
            {
              className: "chakra-checkbox__label",
              ...getLabelProps(),
              __css: {
                marginStart: spacing,
                ...styles2.label
              },
              children
            }
          )
        ]
      }
    );
  }
);
Checkbox.displayName = "Checkbox";
function isInputEvent$1(value) {
  return value && isObject(value) && isObject(value.target);
}
function useCheckboxGroup(props = {}) {
  const {
    defaultValue,
    value: valueProp,
    onChange,
    isDisabled,
    isNative
  } = props;
  const onChangeProp = useCallbackRef(onChange);
  const [value, setValue] = useControllableState({
    value: valueProp,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const handleChange = useCallback(
    (eventOrValue) => {
      if (!value)
        return;
      const isChecked = isInputEvent$1(eventOrValue) ? eventOrValue.target.checked : !value.includes(eventOrValue);
      const selectedValue = isInputEvent$1(eventOrValue) ? eventOrValue.target.value : eventOrValue;
      const nextValue = isChecked ? [...value, selectedValue] : value.filter((v2) => String(v2) !== String(selectedValue));
      setValue(nextValue);
    },
    [setValue, value]
  );
  const getCheckboxProps = useCallback(
    (props2 = {}) => {
      const checkedKey = isNative ? "checked" : "isChecked";
      return {
        ...props2,
        [checkedKey]: value.some((val) => String(props2.value) === String(val)),
        onChange: handleChange
      };
    },
    [handleChange, isNative, value]
  );
  return {
    value,
    isDisabled,
    onChange: handleChange,
    setValue,
    getCheckboxProps
  };
}
function CheckboxGroup(props) {
  const { colorScheme, size, variant, children, isDisabled } = props;
  const { value, onChange } = useCheckboxGroup(props);
  const group = useMemo(
    () => ({
      size,
      onChange,
      colorScheme,
      value,
      variant,
      isDisabled
    }),
    [size, onChange, colorScheme, value, variant, isDisabled]
  );
  return /* @__PURE__ */ jsx$1(CheckboxGroupProvider, { value: group, children });
}
CheckboxGroup.displayName = "CheckboxGroup";
const VALID_VALUES = /* @__PURE__ */ new Set(["dark", "light", "system"]);
function normalize(initialColorMode) {
  let value = initialColorMode;
  if (!VALID_VALUES.has(value))
    value = "light";
  return value;
}
function getScriptSrc(props = {}) {
  const {
    initialColorMode = "light",
    type: type2 = "localStorage",
    storageKey: key = "chakra-ui-color-mode"
  } = props;
  const init = normalize(initialColorMode);
  const isCookie = type2 === "cookie";
  const cookieScript = `(function(){try{var a=function(o){var l="(prefers-color-scheme: dark)",v=window.matchMedia(l).matches?"dark":"light",e=o==="system"?v:o,d=document.documentElement,m=document.body,i="chakra-ui-light",n="chakra-ui-dark",s=e==="dark";return m.classList.add(s?n:i),m.classList.remove(s?i:n),d.style.colorScheme=e,d.dataset.theme=e,e},u=a,h="${init}",r="${key}",t=document.cookie.match(new RegExp("(^| )".concat(r,"=([^;]+)"))),c=t?t[2]:null;c?a(c):document.cookie="".concat(r,"=").concat(a(h),"; max-age=31536000; path=/")}catch(a){}})();
  `;
  const localStorageScript = `(function(){try{var a=function(c){var v="(prefers-color-scheme: dark)",h=window.matchMedia(v).matches?"dark":"light",r=c==="system"?h:c,o=document.documentElement,s=document.body,l="chakra-ui-light",d="chakra-ui-dark",i=r==="dark";return s.classList.add(i?d:l),s.classList.remove(i?l:d),o.style.colorScheme=r,o.dataset.theme=r,r},n=a,m="${init}",e="${key}",t=localStorage.getItem(e);t?a(t):localStorage.setItem(e,a(m))}catch(a){}})();
  `;
  const fn = isCookie ? cookieScript : localStorageScript;
  return `!${fn}`.trim();
}
function ColorModeScript(props = {}) {
  const { nonce } = props;
  return /* @__PURE__ */ jsx$1(
    "script",
    {
      id: "chakra-script",
      nonce,
      dangerouslySetInnerHTML: { __html: getScriptSrc(props) }
    }
  );
}
const Container = forwardRef(
  function Container2(props, ref) {
    const { className, centerContent, ...rest } = omitThemingProps(props);
    const styles2 = useStyleConfig("Container", props);
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        className: cx("chakra-container", className),
        ...rest,
        __css: {
          ...styles2,
          ...centerContent && {
            display: "flex",
            flexDirection: "column",
            alignItems: "center"
          }
        }
      }
    );
  }
);
Container.displayName = "Container";
const Divider = forwardRef(
  function Divider2(props, ref) {
    const {
      borderLeftWidth,
      borderBottomWidth,
      borderTopWidth,
      borderRightWidth,
      borderWidth,
      borderStyle,
      borderColor,
      ...styles2
    } = useStyleConfig("Divider", props);
    const {
      className,
      orientation = "horizontal",
      __css,
      ...rest
    } = omitThemingProps(props);
    const dividerStyles = {
      vertical: {
        borderLeftWidth: borderLeftWidth || borderRightWidth || borderWidth || "1px",
        height: "100%"
      },
      horizontal: {
        borderBottomWidth: borderBottomWidth || borderTopWidth || borderWidth || "1px",
        width: "100%"
      }
    };
    return /* @__PURE__ */ jsx$1(
      chakra.hr,
      {
        ref,
        "aria-orientation": orientation,
        ...rest,
        __css: {
          ...styles2,
          border: "0",
          borderColor,
          borderStyle,
          ...dividerStyles[orientation],
          ...__css
        },
        className: cx("chakra-divider", className)
      }
    );
  }
);
Divider.displayName = "Divider";
function isFunction(value) {
  return typeof value === "function";
}
function pipe(...fns) {
  return (v2) => fns.reduce((a, b) => b(a), v2);
}
const createExtendTheme = (theme2) => {
  return function extendTheme2(...extensions) {
    let overrides2 = [...extensions];
    let activeTheme = extensions[extensions.length - 1];
    if (isChakraTheme(activeTheme) && // this ensures backward compatibility
    // previously only `extendTheme(override, activeTheme?)` was allowed
    overrides2.length > 1) {
      overrides2 = overrides2.slice(0, overrides2.length - 1);
    } else {
      activeTheme = theme2;
    }
    return pipe(
      ...overrides2.map(
        (extension) => (prevTheme) => isFunction(extension) ? extension(prevTheme) : mergeThemeOverride(prevTheme, extension)
      )
    )(activeTheme);
  };
};
const extendTheme = createExtendTheme(theme$1);
function mergeThemeOverride(...overrides2) {
  return mergeWith({}, ...overrides2, mergeThemeCustomizer);
}
function mergeThemeCustomizer(source, override, key, object) {
  if ((isFunction(source) || isFunction(override)) && Object.prototype.hasOwnProperty.call(object, key)) {
    return (...args) => {
      const sourceValue = isFunction(source) ? source(...args) : source;
      const overrideValue = isFunction(override) ? override(...args) : override;
      return mergeWith({}, sourceValue, overrideValue, mergeThemeCustomizer);
    };
  }
  if (isArray$1(source) && isArray$1(override)) {
    return [...source, ...override];
  }
  if (isArray$1(source) && isObject(override)) {
    return override;
  }
  return void 0;
}
const Flex = forwardRef(function Flex2(props, ref) {
  const { direction, align, justify, wrap: wrap2, basis, grow, shrink, ...rest } = props;
  const styles2 = {
    display: "flex",
    flexDirection: direction,
    alignItems: align,
    justifyContent: justify,
    flexWrap: wrap2,
    flexBasis: basis,
    flexGrow: grow,
    flexShrink: shrink
  };
  return /* @__PURE__ */ jsx$1(chakra.div, { ref, __css: styles2, ...rest });
});
Flex.displayName = "Flex";
const FocusTrap = ReactFocusLock.default ?? ReactFocusLock;
const FocusLock = (props) => {
  const {
    initialFocusRef,
    finalFocusRef,
    contentRef,
    restoreFocus,
    children,
    isDisabled,
    autoFocus,
    persistentFocus,
    lockFocusAcrossFrames
  } = props;
  const onActivation = useCallback(() => {
    if (initialFocusRef == null ? void 0 : initialFocusRef.current) {
      initialFocusRef.current.focus();
    } else if (contentRef == null ? void 0 : contentRef.current) {
      const focusables = getAllFocusable(contentRef.current);
      if (focusables.length === 0) {
        requestAnimationFrame(() => {
          var _a;
          (_a = contentRef.current) == null ? void 0 : _a.focus();
        });
      }
    }
  }, [initialFocusRef, contentRef]);
  const onDeactivation = useCallback(() => {
    var _a;
    (_a = finalFocusRef == null ? void 0 : finalFocusRef.current) == null ? void 0 : _a.focus();
  }, [finalFocusRef]);
  const returnFocus = restoreFocus && !finalFocusRef;
  return /* @__PURE__ */ jsx$1(
    FocusTrap,
    {
      crossFrame: lockFocusAcrossFrames,
      persistentFocus,
      autoFocus,
      disabled: isDisabled,
      onActivation,
      onDeactivation,
      returnFocus,
      children
    }
  );
};
FocusLock.displayName = "FocusLock";
const [FormErrorStylesProvider, useFormErrorStyles] = createContext$1({
  name: `FormErrorStylesContext`,
  errorMessage: `useFormErrorStyles returned is 'undefined'. Seems you forgot to wrap the components in "<FormError />" `
});
const FormErrorMessage = forwardRef(
  (props, ref) => {
    const styles2 = useMultiStyleConfig("FormError", props);
    const ownProps = omitThemingProps(props);
    const field = useFormControlContext();
    if (!(field == null ? void 0 : field.isInvalid))
      return null;
    return /* @__PURE__ */ jsx$1(FormErrorStylesProvider, { value: styles2, children: /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ...field == null ? void 0 : field.getErrorMessageProps(ownProps, ref),
        className: cx("chakra-form__error-message", props.className),
        __css: {
          display: "flex",
          alignItems: "center",
          ...styles2.text
        }
      }
    ) });
  }
);
FormErrorMessage.displayName = "FormErrorMessage";
const FormErrorIcon = forwardRef((props, ref) => {
  const styles2 = useFormErrorStyles();
  const field = useFormControlContext();
  if (!(field == null ? void 0 : field.isInvalid))
    return null;
  const _className = cx("chakra-form__error-icon", props.className);
  return /* @__PURE__ */ jsx$1(
    Icon,
    {
      ref,
      "aria-hidden": true,
      ...props,
      __css: styles2.icon,
      className: _className,
      children: /* @__PURE__ */ jsx$1(
        "path",
        {
          fill: "currentColor",
          d: "M11.983,0a12.206,12.206,0,0,0-8.51,3.653A11.8,11.8,0,0,0,0,12.207,11.779,11.779,0,0,0,11.8,24h.214A12.111,12.111,0,0,0,24,11.791h0A11.766,11.766,0,0,0,11.983,0ZM10.5,16.542a1.476,1.476,0,0,1,1.449-1.53h.027a1.527,1.527,0,0,1,1.523,1.47,1.475,1.475,0,0,1-1.449,1.53h-.027A1.529,1.529,0,0,1,10.5,16.542ZM11,12.5v-6a1,1,0,0,1,2,0v6a1,1,0,1,1-2,0Z"
        }
      )
    }
  );
});
FormErrorIcon.displayName = "FormErrorIcon";
const FormLabel = forwardRef(
  function FormLabel2(passedProps, ref) {
    const styles2 = useStyleConfig("FormLabel", passedProps);
    const props = omitThemingProps(passedProps);
    const {
      className,
      children,
      requiredIndicator = /* @__PURE__ */ jsx$1(RequiredIndicator, {}),
      optionalIndicator = null,
      ...rest
    } = props;
    const field = useFormControlContext();
    const ownProps = (field == null ? void 0 : field.getLabelProps(rest, ref)) ?? { ref, ...rest };
    return /* @__PURE__ */ jsxs(
      chakra.label,
      {
        ...ownProps,
        className: cx("chakra-form__label", props.className),
        __css: {
          display: "block",
          textAlign: "start",
          ...styles2
        },
        children: [
          children,
          (field == null ? void 0 : field.isRequired) ? requiredIndicator : optionalIndicator
        ]
      }
    );
  }
);
FormLabel.displayName = "FormLabel";
const RequiredIndicator = forwardRef(
  function RequiredIndicator2(props, ref) {
    const field = useFormControlContext();
    const styles2 = useFormControlStyles();
    if (!(field == null ? void 0 : field.isRequired))
      return null;
    const className = cx("chakra-form__required-indicator", props.className);
    return /* @__PURE__ */ jsx$1(
      chakra.span,
      {
        ...field == null ? void 0 : field.getRequiredIndicatorProps(props, ref),
        __css: styles2.requiredIndicator,
        className
      }
    );
  }
);
RequiredIndicator.displayName = "RequiredIndicator";
const Grid = forwardRef(function Grid2(props, ref) {
  const {
    templateAreas,
    gap,
    rowGap,
    columnGap,
    column,
    row,
    autoFlow,
    autoRows,
    templateRows,
    autoColumns,
    templateColumns,
    ...rest
  } = props;
  const styles2 = {
    display: "grid",
    gridTemplateAreas: templateAreas,
    gridGap: gap,
    gridRowGap: rowGap,
    gridColumnGap: columnGap,
    gridAutoColumns: autoColumns,
    gridColumn: column,
    gridRow: row,
    gridAutoFlow: autoFlow,
    gridAutoRows: autoRows,
    gridTemplateRows: templateRows,
    gridTemplateColumns: templateColumns
  };
  return /* @__PURE__ */ jsx$1(chakra.div, { ref, __css: styles2, ...rest });
});
Grid.displayName = "Grid";
function spanFn(span) {
  return mapResponsive(
    span,
    (value) => value === "auto" ? "auto" : `span ${value}/span ${value}`
  );
}
const GridItem = forwardRef(
  function GridItem2(props, ref) {
    const {
      area,
      colSpan,
      colStart,
      colEnd,
      rowEnd,
      rowSpan,
      rowStart,
      ...rest
    } = props;
    const styles2 = compact$1({
      gridArea: area,
      gridColumn: spanFn(colSpan),
      gridRow: spanFn(rowSpan),
      gridColumnStart: colStart,
      gridColumnEnd: colEnd,
      gridRowStart: rowStart,
      gridRowEnd: rowEnd
    });
    return /* @__PURE__ */ jsx$1(chakra.div, { ref, __css: styles2, ...rest });
  }
);
GridItem.displayName = "GridItem";
const SimpleGrid = forwardRef(
  function SimpleGrid2(props, ref) {
    const { columns, spacingX, spacingY, spacing, minChildWidth, ...rest } = props;
    const theme2 = useTheme();
    const templateColumns = minChildWidth ? widthToColumns(minChildWidth, theme2) : countToColumns(columns);
    return /* @__PURE__ */ jsx$1(
      Grid,
      {
        ref,
        gap: spacing,
        columnGap: spacingX,
        rowGap: spacingY,
        templateColumns,
        ...rest
      }
    );
  }
);
SimpleGrid.displayName = "SimpleGrid";
function toPx(n) {
  return typeof n === "number" ? `${n}px` : n;
}
function widthToColumns(width, theme2) {
  return mapResponsive(width, (value) => {
    const _value = getToken("sizes", value, toPx(value))(theme2);
    return value === null ? null : `repeat(auto-fit, minmax(${_value}, 1fr))`;
  });
}
function countToColumns(count) {
  return mapResponsive(
    count,
    (value) => value === null ? null : `repeat(${value}, minmax(0, 1fr))`
  );
}
const Mark = forwardRef(function Mark2(props, ref) {
  const styles2 = useStyleConfig("Mark", props);
  const ownProps = omitThemingProps(props);
  return /* @__PURE__ */ jsx$1(
    Box,
    {
      ref,
      ...ownProps,
      as: "mark",
      __css: { bg: "transparent", whiteSpace: "nowrap", ...styles2 }
    }
  );
});
const escapeRegexp = (term) => term.replace(/[|\\{}()[\]^$+*?.-]/g, (char) => `\\${char}`);
function buildRegex(query) {
  const _query = query.filter((text) => text.length !== 0).map((text) => escapeRegexp(text.trim()));
  if (!_query.length) {
    return null;
  }
  return new RegExp(`(${_query.join("|")})`, "ig");
}
function highlightWords({ text, query }) {
  const regex = buildRegex(Array.isArray(query) ? query : [query]);
  if (!regex) {
    return [{ text, match: false }];
  }
  const result = text.split(regex).filter(Boolean);
  return result.map((str) => ({ text: str, match: regex.test(str) }));
}
function useHighlight(props) {
  const { text, query } = props;
  return useMemo(() => highlightWords({ text, query }), [text, query]);
}
function Highlight(props) {
  const { children, query, styles: styles2 } = props;
  if (typeof children !== "string") {
    throw new Error("The children prop of Highlight must be a string");
  }
  const chunks = useHighlight({ query, text: children });
  return /* @__PURE__ */ jsx$1(Fragment, { children: chunks.map((chunk, index) => {
    return chunk.match ? /* @__PURE__ */ jsx$1(Mark, { sx: styles2, children: chunk.text }, index) : /* @__PURE__ */ jsx$1(Fragment$1, { children: chunk.text }, index);
  }) });
}
function createIcon(options) {
  const {
    viewBox = "0 0 24 24",
    d: pathDefinition,
    displayName,
    defaultProps = {}
  } = options;
  const path = Children.toArray(options.path);
  const Comp = forwardRef((props, ref) => /* @__PURE__ */ jsx$1(Icon, { ref, viewBox, ...defaultProps, ...props, children: path.length ? path : /* @__PURE__ */ jsx$1("path", { fill: "currentColor", d: pathDefinition }) }));
  Comp.displayName = displayName;
  return Comp;
}
const NativeImage = forwardRef(function NativeImage2(props, ref) {
  const { htmlWidth, htmlHeight, alt, ...rest } = props;
  return /* @__PURE__ */ jsx$1("img", { width: htmlWidth, height: htmlHeight, ref, alt, ...rest });
});
NativeImage.displayName = "NativeImage";
const Image$1 = forwardRef(function Image2(props, ref) {
  const {
    fallbackSrc,
    fallback,
    src,
    srcSet,
    align,
    fit,
    loading,
    ignoreFallback,
    crossOrigin,
    fallbackStrategy = "beforeLoadOrError",
    referrerPolicy,
    ...rest
  } = props;
  const providedFallback = fallbackSrc !== void 0 || fallback !== void 0;
  const shouldIgnoreFallbackImage = loading != null || // use can opt out of fallback image
  ignoreFallback || // if the user doesn't provide any kind of fallback we should ignore it
  !providedFallback;
  const status = useImage({
    ...props,
    crossOrigin,
    ignoreFallback: shouldIgnoreFallbackImage
  });
  const showFallbackImage = shouldShowFallbackImage(status, fallbackStrategy);
  const shared = {
    ref,
    objectFit: fit,
    objectPosition: align,
    ...shouldIgnoreFallbackImage ? rest : omit(rest, ["onError", "onLoad"])
  };
  if (showFallbackImage) {
    if (fallback)
      return fallback;
    return /* @__PURE__ */ jsx$1(
      chakra.img,
      {
        as: NativeImage,
        className: "chakra-image__placeholder",
        src: fallbackSrc,
        ...shared
      }
    );
  }
  return /* @__PURE__ */ jsx$1(
    chakra.img,
    {
      as: NativeImage,
      src,
      srcSet,
      crossOrigin,
      loading,
      referrerPolicy,
      className: "chakra-image",
      ...shared
    }
  );
});
Image$1.displayName = "Image";
const Input = forwardRef(
  function Input2(props, ref) {
    const { htmlSize, ...rest } = props;
    const styles2 = useMultiStyleConfig("Input", rest);
    const ownProps = omitThemingProps(rest);
    const input = useFormControl(ownProps);
    const _className = cx("chakra-input", props.className);
    return /* @__PURE__ */ jsx$1(
      chakra.input,
      {
        size: htmlSize,
        ...input,
        __css: styles2.field,
        ref,
        className: _className
      }
    );
  }
);
Input.displayName = "Input";
Input.id = "Input";
const [InputGroupStylesProvider, useInputGroupStyles] = createContext$1({
  name: `InputGroupStylesContext`,
  errorMessage: `useInputGroupStyles returned is 'undefined'. Seems you forgot to wrap the components in "<InputGroup />" `
});
const InputGroup = forwardRef(
  function InputGroup2(props, ref) {
    const styles2 = useMultiStyleConfig("Input", props);
    const { children, className, ...rest } = omitThemingProps(props);
    const _className = cx("chakra-input__group", className);
    const groupStyles = {};
    const validChildren = getValidChildren(children);
    const input = styles2.field;
    validChildren.forEach((child) => {
      if (!styles2)
        return;
      if (input && child.type.id === "InputLeftElement") {
        groupStyles.paddingStart = input.height ?? input.h;
      }
      if (input && child.type.id === "InputRightElement") {
        groupStyles.paddingEnd = input.height ?? input.h;
      }
      if (child.type.id === "InputRightAddon") {
        groupStyles.borderEndRadius = 0;
      }
      if (child.type.id === "InputLeftAddon") {
        groupStyles.borderStartRadius = 0;
      }
    });
    const clones = validChildren.map((child) => {
      var _a, _b;
      const theming = compact$1({
        size: ((_a = child.props) == null ? void 0 : _a.size) || props.size,
        variant: ((_b = child.props) == null ? void 0 : _b.variant) || props.variant
      });
      return child.type.id !== "Input" ? cloneElement(child, theming) : cloneElement(child, Object.assign(theming, groupStyles, child.props));
    });
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        className: _className,
        ref,
        __css: {
          width: "100%",
          display: "flex",
          position: "relative",
          // Parts of inputs override z-index to ensure that they stack correctly on each other
          // Create a new stacking context so that these overrides don't leak out and conflict with other z-indexes
          isolation: "isolate",
          ...styles2.group
        },
        "data-group": true,
        ...rest,
        children: /* @__PURE__ */ jsx$1(InputGroupStylesProvider, { value: styles2, children: clones })
      }
    );
  }
);
InputGroup.displayName = "InputGroup";
const StyledInputElement = chakra("div", {
  baseStyle: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    position: "absolute",
    top: "0",
    zIndex: 2
  }
});
const InputElement = forwardRef(
  function InputElement2(props, ref) {
    const { placement = "left", ...rest } = props;
    const styles2 = useInputGroupStyles();
    const input = styles2.field;
    const attr = placement === "left" ? "insetStart" : "insetEnd";
    const elementStyles = {
      [attr]: "0",
      width: (input == null ? void 0 : input.height) ?? (input == null ? void 0 : input.h),
      height: (input == null ? void 0 : input.height) ?? (input == null ? void 0 : input.h),
      fontSize: input == null ? void 0 : input.fontSize,
      ...styles2.element
    };
    return /* @__PURE__ */ jsx$1(StyledInputElement, { ref, __css: elementStyles, ...rest });
  }
);
InputElement.id = "InputElement";
InputElement.displayName = "InputElement";
const InputLeftElement = forwardRef(
  function InputLeftElement2(props, ref) {
    const { className, ...rest } = props;
    const _className = cx("chakra-input__left-element", className);
    return /* @__PURE__ */ jsx$1(
      InputElement,
      {
        ref,
        placement: "left",
        className: _className,
        ...rest
      }
    );
  }
);
InputLeftElement.id = "InputLeftElement";
InputLeftElement.displayName = "InputLeftElement";
const InputRightElement = forwardRef(
  function InputRightElement2(props, ref) {
    const { className, ...rest } = props;
    const _className = cx("chakra-input__right-element", className);
    return /* @__PURE__ */ jsx$1(
      InputElement,
      {
        ref,
        placement: "right",
        className: _className,
        ...rest
      }
    );
  }
);
InputRightElement.id = "InputRightElement";
InputRightElement.displayName = "InputRightElement";
const Link = forwardRef(function Link2(props, ref) {
  const styles2 = useStyleConfig("Link", props);
  const { className, isExternal, ...rest } = omitThemingProps(props);
  return /* @__PURE__ */ jsx$1(
    chakra.a,
    {
      target: isExternal ? "_blank" : void 0,
      rel: isExternal ? "noopener" : void 0,
      ref,
      className: cx("chakra-link", className),
      ...rest,
      __css: styles2
    }
  );
});
Link.displayName = "Link";
const [ListStylesProvider, useListStyles] = createContext$1({
  name: `ListStylesContext`,
  errorMessage: `useListStyles returned is 'undefined'. Seems you forgot to wrap the components in "<List />" `
});
const List = forwardRef(function List2(props, ref) {
  const styles2 = useMultiStyleConfig("List", props);
  const {
    children,
    styleType = "none",
    stylePosition,
    spacing,
    ...rest
  } = omitThemingProps(props);
  const validChildren = getValidChildren(children);
  const selector = "& > *:not(style) ~ *:not(style)";
  const spacingStyle = spacing ? { [selector]: { mt: spacing } } : {};
  return /* @__PURE__ */ jsx$1(ListStylesProvider, { value: styles2, children: /* @__PURE__ */ jsx$1(
    chakra.ul,
    {
      ref,
      listStyleType: styleType,
      listStylePosition: stylePosition,
      role: "list",
      __css: { ...styles2.container, ...spacingStyle },
      ...rest,
      children: validChildren
    }
  ) });
});
List.displayName = "List";
const OrderedList = forwardRef((props, ref) => {
  const { as, ...rest } = props;
  return /* @__PURE__ */ jsx$1(List, { ref, as: "ol", styleType: "decimal", marginStart: "1em", ...rest });
});
OrderedList.displayName = "OrderedList";
const UnorderedList = forwardRef(
  function UnorderedList2(props, ref) {
    const { as, ...rest } = props;
    return /* @__PURE__ */ jsx$1(List, { ref, as: "ul", styleType: "initial", marginStart: "1em", ...rest });
  }
);
UnorderedList.displayName = "UnorderedList";
const ListItem = forwardRef(
  function ListItem2(props, ref) {
    const styles2 = useListStyles();
    return /* @__PURE__ */ jsx$1(chakra.li, { ref, ...props, __css: styles2.item });
  }
);
ListItem.displayName = "ListItem";
const ListIcon = forwardRef(
  function ListIcon2(props, ref) {
    const styles2 = useListStyles();
    return /* @__PURE__ */ jsx$1(Icon, { ref, role: "presentation", ...props, __css: styles2.icon });
  }
);
ListIcon.displayName = "ListIcon";
function useMediaQuery(query, options = {}) {
  const { ssr = true, fallback } = options;
  const { getWindow } = useEnvironment();
  const queries = Array.isArray(query) ? query : [query];
  let fallbackValues = Array.isArray(fallback) ? fallback : [fallback];
  fallbackValues = fallbackValues.filter((v2) => v2 != null);
  const [value, setValue] = useState(() => {
    return queries.map((query2, index) => ({
      media: query2,
      matches: ssr ? !!fallbackValues[index] : getWindow().matchMedia(query2).matches
    }));
  });
  useEffect(() => {
    const win = getWindow();
    setValue(
      queries.map((query2) => ({
        media: query2,
        matches: win.matchMedia(query2).matches
      }))
    );
    const mql = queries.map((query2) => win.matchMedia(query2));
    const handler = (evt) => {
      setValue((prev) => {
        return prev.slice().map((item) => {
          if (item.media === evt.media)
            return { ...item, matches: evt.matches };
          return item;
        });
      });
    };
    mql.forEach((mql2) => {
      if (typeof mql2.addListener === "function") {
        mql2.addListener(handler);
      } else {
        mql2.addEventListener("change", handler);
      }
    });
    return () => {
      mql.forEach((mql2) => {
        if (typeof mql2.removeListener === "function") {
          mql2.removeListener(handler);
        } else {
          mql2.removeEventListener("change", handler);
        }
      });
    };
  }, [getWindow]);
  return value.map((item) => item.matches);
}
function useBreakpoint(arg) {
  var _a;
  const opts = isObject(arg) ? arg : { fallback: arg ?? "base" };
  const theme2 = useTheme();
  const breakpoints2 = theme2.__breakpoints.details.map(
    ({ minMaxQuery, breakpoint }) => ({
      breakpoint,
      query: minMaxQuery.replace("@media screen and ", "")
    })
  );
  const fallback = breakpoints2.map((bp) => bp.breakpoint === opts.fallback);
  const values = useMediaQuery(
    breakpoints2.map((bp) => bp.query),
    { fallback, ssr: opts.ssr }
  );
  const index = values.findIndex((value) => value == true);
  return ((_a = breakpoints2[index]) == null ? void 0 : _a.breakpoint) ?? opts.fallback;
}
function getClosestValue(values, breakpoint, breakpoints$1 = breakpoints) {
  let index = Object.keys(values).indexOf(breakpoint);
  if (index !== -1) {
    return values[breakpoint];
  }
  let stopIndex = breakpoints$1.indexOf(breakpoint);
  while (stopIndex >= 0) {
    const key = breakpoints$1[stopIndex];
    if (values.hasOwnProperty(key)) {
      index = stopIndex;
      break;
    }
    stopIndex -= 1;
  }
  if (index !== -1) {
    const key = breakpoints$1[index];
    return values[key];
  }
  return void 0;
}
function useBreakpointValue(values, arg) {
  var _a;
  const opts = isObject(arg) ? arg : { fallback: arg ?? "base" };
  const breakpoint = useBreakpoint(opts);
  const theme2 = useTheme();
  if (!breakpoint)
    return;
  const breakpoints2 = Array.from(((_a = theme2.__breakpoints) == null ? void 0 : _a.keys) || []);
  const obj = Array.isArray(values) ? Object.fromEntries(
    Object.entries(arrayToObjectNotation(values, breakpoints2)).map(
      ([key, value]) => [key, value]
    )
  ) : values;
  return getClosestValue(obj, breakpoint, breakpoints2);
}
function getNextItemFromSearch(items, searchString, itemToString, currentItem) {
  if (searchString == null) {
    return currentItem;
  }
  if (!currentItem) {
    const foundItem = items.find(
      (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
    );
    return foundItem;
  }
  const matchingItems = items.filter(
    (item) => itemToString(item).toLowerCase().startsWith(searchString.toLowerCase())
  );
  if (matchingItems.length > 0) {
    let nextIndex;
    if (matchingItems.includes(currentItem)) {
      const currentIndex = matchingItems.indexOf(currentItem);
      nextIndex = currentIndex + 1;
      if (nextIndex === matchingItems.length) {
        nextIndex = 0;
      }
      return matchingItems[nextIndex];
    }
    nextIndex = items.indexOf(matchingItems[0]);
    return items[nextIndex];
  }
  return currentItem;
}
function isPrintableCharacter(event) {
  const { key } = event;
  return key.length === 1 || key.length > 1 && /[^a-zA-Z0-9]/.test(key);
}
function useShortcut(props = {}) {
  const { timeout = 300, preventDefault = () => true } = props;
  const [keys, setKeys] = useState([]);
  const timeoutRef = useRef();
  const flush = () => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  };
  const clearKeysAfterDelay = () => {
    flush();
    timeoutRef.current = setTimeout(() => {
      setKeys([]);
      timeoutRef.current = null;
    }, timeout);
  };
  useEffect(() => flush, []);
  function onKeyDown(fn) {
    return (event) => {
      if (event.key === "Backspace") {
        const keysCopy = [...keys];
        keysCopy.pop();
        setKeys(keysCopy);
        return;
      }
      if (isPrintableCharacter(event)) {
        const keysCopy = keys.concat(event.key);
        if (preventDefault(event)) {
          event.preventDefault();
          event.stopPropagation();
        }
        setKeys(keysCopy);
        fn(keysCopy.join(""));
        clearKeysAfterDelay();
      }
    };
  }
  return onKeyDown;
}
const toVar = (value, fallback) => ({
  var: value,
  varRef: fallback ? `var(${value}, ${fallback})` : `var(${value})`
});
const cssVars = {
  arrowShadowColor: toVar("--popper-arrow-shadow-color"),
  arrowSize: toVar("--popper-arrow-size", "8px"),
  arrowSizeHalf: toVar("--popper-arrow-size-half"),
  arrowBg: toVar("--popper-arrow-bg"),
  transformOrigin: toVar("--popper-transform-origin"),
  arrowOffset: toVar("--popper-arrow-offset")
};
function getBoxShadow(placement) {
  if (placement.includes("top"))
    return `1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("bottom"))
    return `-1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("right"))
    return `-1px 1px 0px 0 var(--popper-arrow-shadow-color)`;
  if (placement.includes("left"))
    return `1px -1px 0px 0 var(--popper-arrow-shadow-color)`;
}
const transforms = {
  top: "bottom center",
  "top-start": "bottom left",
  "top-end": "bottom right",
  bottom: "top center",
  "bottom-start": "top left",
  "bottom-end": "top right",
  left: "right center",
  "left-start": "right top",
  "left-end": "right bottom",
  right: "left center",
  "right-start": "left top",
  "right-end": "left bottom"
};
const toTransformOrigin = (placement) => transforms[placement];
const defaultEventListeners = {
  scroll: true,
  resize: true
};
function getEventListenerOptions(value) {
  let eventListeners;
  if (typeof value === "object") {
    eventListeners = {
      enabled: true,
      options: { ...defaultEventListeners, ...value }
    };
  } else {
    eventListeners = {
      enabled: value,
      options: defaultEventListeners
    };
  }
  return eventListeners;
}
const matchWidth = {
  name: "matchWidth",
  enabled: true,
  phase: "beforeWrite",
  requires: ["computeStyles"],
  fn: ({ state: state2 }) => {
    state2.styles.popper.width = `${state2.rects.reference.width}px`;
  },
  effect: ({ state: state2 }) => () => {
    const reference = state2.elements.reference;
    state2.elements.popper.style.width = `${reference.offsetWidth}px`;
  }
};
const transformOrigin = {
  name: "transformOrigin",
  enabled: true,
  phase: "write",
  fn: ({ state: state2 }) => {
    setTransformOrigin(state2);
  },
  effect: ({ state: state2 }) => () => {
    setTransformOrigin(state2);
  }
};
const setTransformOrigin = (state2) => {
  state2.elements.popper.style.setProperty(
    cssVars.transformOrigin.var,
    toTransformOrigin(state2.placement)
  );
};
const positionArrow = {
  name: "positionArrow",
  enabled: true,
  phase: "afterWrite",
  fn: ({ state: state2 }) => {
    setArrowStyles(state2);
  }
};
const setArrowStyles = (state2) => {
  var _a;
  if (!state2.placement)
    return;
  const overrides2 = getArrowStyle$1(state2.placement);
  if (((_a = state2.elements) == null ? void 0 : _a.arrow) && overrides2) {
    Object.assign(state2.elements.arrow.style, {
      [overrides2.property]: overrides2.value,
      width: cssVars.arrowSize.varRef,
      height: cssVars.arrowSize.varRef,
      zIndex: -1
    });
    const vars = {
      [cssVars.arrowSizeHalf.var]: `calc(${cssVars.arrowSize.varRef} / 2 - 1px)`,
      [cssVars.arrowOffset.var]: `calc(${cssVars.arrowSizeHalf.varRef} * -1)`
    };
    for (const property in vars) {
      state2.elements.arrow.style.setProperty(property, vars[property]);
    }
  }
};
const getArrowStyle$1 = (placement) => {
  if (placement.startsWith("top")) {
    return { property: "bottom", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("bottom")) {
    return { property: "top", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("left")) {
    return { property: "right", value: cssVars.arrowOffset.varRef };
  }
  if (placement.startsWith("right")) {
    return { property: "left", value: cssVars.arrowOffset.varRef };
  }
};
const innerArrow = {
  name: "innerArrow",
  enabled: true,
  phase: "main",
  requires: ["arrow"],
  fn: ({ state: state2 }) => {
    setInnerArrowStyles(state2);
  },
  effect: ({ state: state2 }) => () => {
    setInnerArrowStyles(state2);
  }
};
const setInnerArrowStyles = (state2) => {
  if (!state2.elements.arrow)
    return;
  const inner = state2.elements.arrow.querySelector(
    "[data-popper-arrow-inner]"
  );
  if (!inner)
    return;
  const boxShadow = getBoxShadow(state2.placement);
  if (boxShadow) {
    inner.style.setProperty("--popper-arrow-default-shadow", boxShadow);
  }
  Object.assign(inner.style, {
    transform: "rotate(45deg)",
    background: cssVars.arrowBg.varRef,
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    position: "absolute",
    zIndex: "inherit",
    boxShadow: `var(--popper-arrow-shadow, var(--popper-arrow-default-shadow))`
  });
};
const logicals = {
  "start-start": { ltr: "left-start", rtl: "right-start" },
  "start-end": { ltr: "left-end", rtl: "right-end" },
  "end-start": { ltr: "right-start", rtl: "left-start" },
  "end-end": { ltr: "right-end", rtl: "left-end" },
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
};
const opposites = {
  "auto-start": "auto-end",
  "auto-end": "auto-start",
  "top-start": "top-end",
  "top-end": "top-start",
  "bottom-start": "bottom-end",
  "bottom-end": "bottom-start"
};
function getPopperPlacement(placement, dir = "ltr") {
  var _a;
  const value = ((_a = logicals[placement]) == null ? void 0 : _a[dir]) || placement;
  if (dir === "ltr")
    return value;
  return opposites[placement] ?? value;
}
function usePopper(props = {}) {
  const {
    enabled = true,
    modifiers,
    placement: placementProp = "bottom",
    strategy = "absolute",
    arrowPadding = 8,
    eventListeners = true,
    offset,
    gutter = 8,
    flip = true,
    boundary = "clippingParents",
    preventOverflow = true,
    matchWidth: matchWidth$1,
    direction = "ltr"
  } = props;
  const reference = useRef(null);
  const popper = useRef(null);
  const instance = useRef(null);
  const placement = getPopperPlacement(placementProp, direction);
  const cleanup = useRef(() => {
  });
  const setupPopper = useCallback(() => {
    var _a;
    if (!enabled || !reference.current || !popper.current)
      return;
    (_a = cleanup.current) == null ? void 0 : _a.call(cleanup);
    instance.current = createPopper(reference.current, popper.current, {
      placement,
      modifiers: [
        innerArrow,
        positionArrow,
        transformOrigin,
        {
          ...matchWidth,
          enabled: !!matchWidth$1
        },
        {
          name: "eventListeners",
          ...getEventListenerOptions(eventListeners)
        },
        {
          name: "arrow",
          options: { padding: arrowPadding }
        },
        {
          name: "offset",
          options: {
            offset: offset ?? [0, gutter]
          }
        },
        {
          name: "flip",
          enabled: !!flip,
          options: { padding: 8 }
        },
        {
          name: "preventOverflow",
          enabled: !!preventOverflow,
          options: { boundary }
        },
        // allow users override internal modifiers
        ...modifiers ?? []
      ],
      strategy
    });
    instance.current.forceUpdate();
    cleanup.current = instance.current.destroy;
  }, [
    placement,
    enabled,
    modifiers,
    matchWidth$1,
    eventListeners,
    arrowPadding,
    offset,
    gutter,
    flip,
    preventOverflow,
    boundary,
    strategy
  ]);
  useEffect(() => {
    return () => {
      var _a;
      if (!reference.current && !popper.current) {
        (_a = instance.current) == null ? void 0 : _a.destroy();
        instance.current = null;
      }
    };
  }, []);
  const referenceRef = useCallback(
    (node) => {
      reference.current = node;
      setupPopper();
    },
    [setupPopper]
  );
  const getReferenceProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(referenceRef, ref)
    }),
    [referenceRef]
  );
  const popperRef = useCallback(
    (node) => {
      popper.current = node;
      setupPopper();
    },
    [setupPopper]
  );
  const getPopperProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(popperRef, ref),
      style: {
        ...props2.style,
        position: strategy,
        minWidth: matchWidth$1 ? void 0 : "max-content",
        inset: "0 auto auto 0"
      }
    }),
    [strategy, popperRef, matchWidth$1]
  );
  const getArrowProps = useCallback((props2 = {}, ref = null) => {
    const { size, shadowColor, bg, style, ...rest } = props2;
    return {
      ...rest,
      ref,
      "data-popper-arrow": "",
      style: getArrowStyle(props2)
    };
  }, []);
  const getArrowInnerProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref,
      "data-popper-arrow-inner": ""
    }),
    []
  );
  return {
    update() {
      var _a;
      (_a = instance.current) == null ? void 0 : _a.update();
    },
    forceUpdate() {
      var _a;
      (_a = instance.current) == null ? void 0 : _a.forceUpdate();
    },
    transformOrigin: cssVars.transformOrigin.varRef,
    referenceRef,
    popperRef,
    getPopperProps,
    getArrowProps,
    getArrowInnerProps,
    getReferenceProps
  };
}
function getArrowStyle(props) {
  const { size, shadowColor, bg, style } = props;
  const computedStyle = { ...style, position: "absolute" };
  if (size) {
    computedStyle["--popper-arrow-size"] = size;
  }
  if (shadowColor) {
    computedStyle["--popper-arrow-shadow-color"] = shadowColor;
  }
  if (bg) {
    computedStyle["--popper-arrow-bg"] = bg;
  }
  return computedStyle;
}
function useEventListeners() {
  const listeners = useRef(/* @__PURE__ */ new Map());
  const currentListeners = listeners.current;
  const add2 = useCallback((el, type2, listener, options) => {
    listeners.current.set(listener, { type: type2, el, options });
    el.addEventListener(type2, listener, options);
  }, []);
  const remove = useCallback(
    (el, type2, listener, options) => {
      el.removeEventListener(type2, listener, options);
      listeners.current.delete(listener);
    },
    []
  );
  useEffect(
    () => () => {
      currentListeners.forEach((value, key) => {
        remove(value.el, value.type, key, value.options);
      });
    },
    [remove, currentListeners]
  );
  return { add: add2, remove };
}
function isValidElement(event) {
  var _a, _b;
  const target = ((_b = (_a = event.composedPath) == null ? void 0 : _a.call(event)) == null ? void 0 : _b[0]) ?? event.target;
  const { tagName, isContentEditable } = target;
  return tagName !== "INPUT" && tagName !== "TEXTAREA" && isContentEditable !== true;
}
function useClickable(props = {}) {
  const {
    ref: htmlRef,
    isDisabled,
    isFocusable,
    clickOnEnter = true,
    clickOnSpace = true,
    onMouseDown,
    onMouseUp,
    onClick,
    onKeyDown,
    onKeyUp,
    tabIndex: tabIndexProp,
    onMouseOver,
    onMouseLeave,
    ...htmlProps
  } = props;
  const [isButton, setIsButton] = useState(true);
  const [isPressed, setIsPressed] = useState(false);
  const listeners = useEventListeners();
  const refCallback = (node) => {
    if (!node)
      return;
    if (node.tagName !== "BUTTON") {
      setIsButton(false);
    }
  };
  const tabIndex = isButton ? tabIndexProp : tabIndexProp || 0;
  const trulyDisabled = isDisabled && !isFocusable;
  const handleClick = useCallback(
    (event) => {
      if (isDisabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      const self2 = event.currentTarget;
      self2.focus();
      onClick == null ? void 0 : onClick(event);
    },
    [isDisabled, onClick]
  );
  const onDocumentKeyUp = useCallback(
    (e) => {
      if (isPressed && isValidElement(e)) {
        e.preventDefault();
        e.stopPropagation();
        setIsPressed(false);
        listeners.remove(document, "keyup", onDocumentKeyUp, false);
      }
    },
    [isPressed, listeners]
  );
  const handleKeyDown = useCallback(
    (event) => {
      onKeyDown == null ? void 0 : onKeyDown(event);
      if (isDisabled || event.defaultPrevented || event.metaKey) {
        return;
      }
      if (!isValidElement(event.nativeEvent) || isButton)
        return;
      const shouldClickOnEnter = clickOnEnter && event.key === "Enter";
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(true);
      }
      if (shouldClickOnEnter) {
        event.preventDefault();
        const self2 = event.currentTarget;
        self2.click();
      }
      listeners.add(document, "keyup", onDocumentKeyUp, false);
    },
    [
      isDisabled,
      isButton,
      onKeyDown,
      clickOnEnter,
      clickOnSpace,
      listeners,
      onDocumentKeyUp
    ]
  );
  const handleKeyUp = useCallback(
    (event) => {
      onKeyUp == null ? void 0 : onKeyUp(event);
      if (isDisabled || event.defaultPrevented || event.metaKey)
        return;
      if (!isValidElement(event.nativeEvent) || isButton)
        return;
      const shouldClickOnSpace = clickOnSpace && event.key === " ";
      if (shouldClickOnSpace) {
        event.preventDefault();
        setIsPressed(false);
        const self2 = event.currentTarget;
        self2.click();
      }
    },
    [clickOnSpace, isButton, isDisabled, onKeyUp]
  );
  const onDocumentMouseUp = useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      setIsPressed(false);
      listeners.remove(document, "mouseup", onDocumentMouseUp, false);
    },
    [listeners]
  );
  const handleMouseDown = useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      if (isDisabled) {
        event.stopPropagation();
        event.preventDefault();
        return;
      }
      if (!isButton) {
        setIsPressed(true);
      }
      const target = event.currentTarget;
      target.focus({ preventScroll: true });
      listeners.add(document, "mouseup", onDocumentMouseUp, false);
      onMouseDown == null ? void 0 : onMouseDown(event);
    },
    [isDisabled, isButton, onMouseDown, listeners, onDocumentMouseUp]
  );
  const handleMouseUp = useCallback(
    (event) => {
      if (event.button !== 0)
        return;
      if (!isButton) {
        setIsPressed(false);
      }
      onMouseUp == null ? void 0 : onMouseUp(event);
    },
    [onMouseUp, isButton]
  );
  const handleMouseOver = useCallback(
    (event) => {
      if (isDisabled) {
        event.preventDefault();
        return;
      }
      onMouseOver == null ? void 0 : onMouseOver(event);
    },
    [isDisabled, onMouseOver]
  );
  const handleMouseLeave = useCallback(
    (event) => {
      if (isPressed) {
        event.preventDefault();
        setIsPressed(false);
      }
      onMouseLeave == null ? void 0 : onMouseLeave(event);
    },
    [isPressed, onMouseLeave]
  );
  const ref = mergeRefs(htmlRef, refCallback);
  if (isButton) {
    return {
      ...htmlProps,
      ref,
      type: "button",
      "aria-disabled": trulyDisabled ? void 0 : isDisabled,
      disabled: trulyDisabled,
      onClick: handleClick,
      onMouseDown,
      onMouseUp,
      onKeyUp,
      onKeyDown,
      onMouseOver,
      onMouseLeave
    };
  }
  return {
    ...htmlProps,
    ref,
    role: "button",
    "data-active": dataAttr(isPressed),
    "aria-disabled": isDisabled ? "true" : void 0,
    tabIndex: trulyDisabled ? void 0 : tabIndex,
    onClick: handleClick,
    onMouseDown: handleMouseDown,
    onMouseUp: handleMouseUp,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDown,
    onMouseOver: handleMouseOver,
    onMouseLeave: handleMouseLeave
  };
}
const [
  MenuDescendantsProvider,
  useMenuDescendantsContext,
  useMenuDescendants,
  useMenuDescendant
] = createDescendantContext();
const [MenuProvider, useMenuContext] = createContext$1({
  strict: false,
  name: "MenuContext"
});
function getOwnerDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) ?? document;
}
function isActiveElement(element) {
  const doc = getOwnerDocument(element);
  return doc.activeElement === element;
}
function useMenu(props = {}) {
  const {
    id: id2,
    closeOnSelect = true,
    closeOnBlur = true,
    initialFocusRef,
    autoSelect = true,
    isLazy,
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenProp,
    placement = "bottom-start",
    lazyBehavior = "unmount",
    direction,
    computePositionOnMount = false,
    ...popperProps
  } = props;
  const menuRef = useRef(null);
  const buttonRef = useRef(null);
  const scrollIntoViewRef = useRef(true);
  const descendants = useMenuDescendants();
  const focusMenu = useCallback(() => {
    requestAnimationFrame(() => {
      var _a;
      (_a = menuRef.current) == null ? void 0 : _a.focus({ preventScroll: false });
    });
  }, []);
  const focusFirstItem = useCallback(() => {
    const id22 = setTimeout(() => {
      var _a, _b;
      if (initialFocusRef) {
        (_a = initialFocusRef.current) == null ? void 0 : _a.focus();
      } else if (!descendants.count()) {
        (_b = menuRef.current) == null ? void 0 : _b.focus({ preventScroll: false });
      } else {
        const first = descendants.firstEnabled();
        if (first)
          setFocusedIndex(first.index);
      }
    });
    timeoutIds.current.add(id22);
  }, [descendants, initialFocusRef]);
  const focusLastItem = useCallback(() => {
    const id22 = setTimeout(() => {
      var _a;
      if (!descendants.count()) {
        (_a = menuRef.current) == null ? void 0 : _a.focus({ preventScroll: false });
      } else {
        const last = descendants.lastEnabled();
        if (last)
          setFocusedIndex(last.index);
      }
    });
    timeoutIds.current.add(id22);
  }, [descendants]);
  const onOpenInternal = useCallback(() => {
    onOpenProp == null ? void 0 : onOpenProp();
    if (autoSelect) {
      focusFirstItem();
    } else {
      focusMenu();
    }
  }, [autoSelect, focusFirstItem, focusMenu, onOpenProp]);
  const { isOpen, onOpen, onClose, onToggle } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onClose: onCloseProp,
    onOpen: onOpenInternal
  });
  useOutsideClick({
    enabled: isOpen && closeOnBlur,
    ref: menuRef,
    handler: (event) => {
      var _a, _b, _c;
      const target = ((_b = (_a = event.composedPath) == null ? void 0 : _a.call(event)) == null ? void 0 : _b[0]) ?? event.target;
      if (!((_c = buttonRef.current) == null ? void 0 : _c.contains(target))) {
        onClose();
      }
    }
  });
  const popper = usePopper({
    ...popperProps,
    enabled: isOpen || computePositionOnMount,
    placement,
    direction
  });
  const [focusedIndex, setFocusedIndex] = useState(-1);
  useFocusOnHide(menuRef, {
    focusRef: buttonRef,
    visible: isOpen,
    shouldFocus: true
  });
  const animationState = useAnimationState({ isOpen, ref: menuRef });
  const [buttonId, menuId] = useIds$1(id2, `menu-button`, `menu-list`);
  const openAndFocusMenu = useCallback(() => {
    onOpen();
    focusMenu();
  }, [onOpen, focusMenu]);
  const timeoutIds = useRef(/* @__PURE__ */ new Set([]));
  useEffect(() => {
    const ids = timeoutIds.current;
    return () => {
      ids.forEach((id22) => clearTimeout(id22));
      ids.clear();
    };
  }, []);
  useUpdateEffect(() => {
    var _a;
    if (isOpen)
      return;
    setFocusedIndex(-1);
    (_a = menuRef.current) == null ? void 0 : _a.scrollTo(0, 0);
  }, [isOpen]);
  useUpdateEffect(() => {
    if (!isOpen)
      return;
    if (focusedIndex === -1) {
      focusMenu();
    }
  }, [focusedIndex, isOpen]);
  useEffect(() => {
    var _a;
    if (!isOpen)
      return;
    const item = descendants.item(focusedIndex);
    (_a = item == null ? void 0 : item.node) == null ? void 0 : _a.focus({ preventScroll: !scrollIntoViewRef.current });
  }, [descendants, focusedIndex, isOpen]);
  const openAndFocusFirstItem = useCallback(() => {
    onOpen();
    focusFirstItem();
  }, [focusFirstItem, onOpen]);
  const openAndFocusLastItem = useCallback(() => {
    scrollIntoViewRef.current = true;
    onOpen();
    focusLastItem();
  }, [onOpen, focusLastItem]);
  const refocus = useCallback(() => {
    var _a, _b;
    const doc = getOwnerDocument(menuRef.current);
    const hasFocusWithin = (_a = menuRef.current) == null ? void 0 : _a.contains(doc.activeElement);
    const shouldRefocus = isOpen && !hasFocusWithin;
    if (!shouldRefocus)
      return;
    const node = (_b = descendants.item(focusedIndex)) == null ? void 0 : _b.node;
    node == null ? void 0 : node.focus({ preventScroll: !scrollIntoViewRef.current });
  }, [isOpen, focusedIndex, descendants]);
  return {
    openAndFocusMenu,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    onTransitionEnd: refocus,
    unstable__animationState: animationState,
    descendants,
    popper,
    buttonId,
    menuId,
    forceUpdate: popper.forceUpdate,
    orientation: "vertical",
    isOpen,
    onToggle,
    onOpen,
    onClose,
    menuRef,
    buttonRef,
    focusedIndex,
    closeOnSelect,
    closeOnBlur,
    autoSelect,
    setFocusedIndex,
    isLazy,
    lazyBehavior,
    initialFocusRef,
    scrollIntoViewRef
  };
}
function useMenuButton(props = {}, externalRef = null) {
  const menu = useMenuContext();
  const {
    onToggle,
    popper,
    openAndFocusFirstItem,
    openAndFocusLastItem,
    scrollIntoViewRef
  } = menu;
  const onKeyDown = useCallback(
    (event) => {
      const eventKey = event.key;
      const keyMap = {
        Enter: openAndFocusFirstItem,
        ArrowDown: openAndFocusFirstItem,
        ArrowUp: openAndFocusLastItem
      };
      const action = keyMap[eventKey];
      if (action) {
        scrollIntoViewRef.current = true;
        event.preventDefault();
        event.stopPropagation();
        action(event);
      }
    },
    [openAndFocusFirstItem, openAndFocusLastItem, scrollIntoViewRef]
  );
  return {
    ...props,
    ref: mergeRefs(menu.buttonRef, externalRef, popper.referenceRef),
    id: menu.buttonId,
    "data-active": dataAttr(menu.isOpen),
    "aria-expanded": menu.isOpen,
    "aria-haspopup": "menu",
    "aria-controls": menu.menuId,
    onClick: callAllHandlers(props.onClick, onToggle),
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  };
}
function isTargetMenuItem(target) {
  var _a;
  return isHTMLElement(target) && !!((_a = target == null ? void 0 : target.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem"));
}
function useMenuList(props = {}, ref = null) {
  const menu = useMenuContext();
  if (!menu) {
    throw new Error(
      `useMenuContext: context is undefined. Seems you forgot to wrap component within <Menu>`
    );
  }
  const {
    focusedIndex,
    setFocusedIndex,
    menuRef,
    isOpen,
    onClose,
    menuId,
    isLazy,
    lazyBehavior,
    scrollIntoViewRef,
    unstable__animationState: animated
  } = menu;
  const descendants = useMenuDescendantsContext();
  const createTypeaheadHandler = useShortcut({
    preventDefault: (event) => event.key !== " " && isTargetMenuItem(event.target)
  });
  const onKeyDown = useCallback(
    (event) => {
      if (!event.currentTarget.contains(event.target))
        return;
      const eventKey = event.key;
      const keyMap = {
        Tab: (event2) => event2.preventDefault(),
        Escape: (event2) => {
          event2.stopPropagation();
          onClose();
        },
        ArrowDown: () => {
          scrollIntoViewRef.current = true;
          const next2 = descendants.nextEnabled(focusedIndex) ?? descendants.firstEnabled();
          if (next2)
            setFocusedIndex(next2.index);
        },
        ArrowUp: () => {
          scrollIntoViewRef.current = true;
          const prev = descendants.prevEnabled(focusedIndex) ?? descendants.firstEnabled();
          if (prev)
            setFocusedIndex(prev.index);
        }
      };
      const fn = keyMap[eventKey];
      if (fn) {
        event.preventDefault();
        fn(event);
        return;
      }
      const onTypeahead = createTypeaheadHandler((character) => {
        const nextItem = getNextItemFromSearch(
          descendants.values(),
          character,
          (item) => {
            var _a;
            return ((_a = item == null ? void 0 : item.node) == null ? void 0 : _a.textContent) ?? "";
          },
          descendants.item(focusedIndex)
        );
        if (nextItem) {
          const index = descendants.indexOf(nextItem.node);
          setFocusedIndex(index);
        }
      });
      if (isTargetMenuItem(event.target)) {
        onTypeahead(event);
      }
    },
    [
      descendants,
      focusedIndex,
      createTypeaheadHandler,
      onClose,
      setFocusedIndex,
      scrollIntoViewRef
    ]
  );
  const hasBeenOpened = useRef(false);
  if (isOpen) {
    hasBeenOpened.current = true;
  }
  const shouldRenderChildren = lazyDisclosure({
    wasSelected: hasBeenOpened.current,
    enabled: isLazy,
    mode: lazyBehavior,
    isSelected: animated.present
  });
  return {
    ...props,
    ref: mergeRefs(menuRef, ref),
    children: shouldRenderChildren ? props.children : null,
    tabIndex: -1,
    role: "menu",
    id: menuId,
    style: {
      ...props.style,
      transformOrigin: "var(--popper-transform-origin)"
    },
    "aria-orientation": "vertical",
    onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown)
  };
}
function useMenuPositioner(props = {}) {
  const { popper, isOpen } = useMenuContext();
  return popper.getPopperProps({
    ...props,
    style: {
      visibility: isOpen ? "visible" : "hidden",
      ...props.style
    }
  });
}
function useMenuItem(props = {}, externalRef = null) {
  const {
    onMouseEnter: onMouseEnterProp,
    onMouseMove: onMouseMoveProp,
    onMouseLeave: onMouseLeaveProp,
    onClick: onClickProp,
    onFocus: onFocusProp,
    isDisabled,
    isFocusable,
    closeOnSelect,
    type: typeProp,
    ...htmlProps
  } = props;
  const menu = useMenuContext();
  const {
    setFocusedIndex,
    focusedIndex,
    closeOnSelect: menuCloseOnSelect,
    onClose,
    menuId,
    scrollIntoViewRef
  } = menu;
  const ref = useRef(null);
  const id2 = `${menuId}-menuitem-${useId$1()}`;
  const { index, register } = useMenuDescendant({
    disabled: isDisabled && !isFocusable
  });
  const onMouseEnter = useCallback(
    (event) => {
      onMouseEnterProp == null ? void 0 : onMouseEnterProp(event);
      if (isDisabled)
        return;
      scrollIntoViewRef.current = false;
      setFocusedIndex(index);
    },
    [setFocusedIndex, index, isDisabled, onMouseEnterProp, scrollIntoViewRef]
  );
  const onMouseMove = useCallback(
    (event) => {
      onMouseMoveProp == null ? void 0 : onMouseMoveProp(event);
      if (ref.current && !isActiveElement(ref.current)) {
        onMouseEnter(event);
      }
    },
    [onMouseEnter, onMouseMoveProp]
  );
  const onMouseLeave = useCallback(
    (event) => {
      onMouseLeaveProp == null ? void 0 : onMouseLeaveProp(event);
      if (isDisabled)
        return;
      setFocusedIndex(-1);
    },
    [setFocusedIndex, isDisabled, onMouseLeaveProp]
  );
  const onClick = useCallback(
    (event) => {
      onClickProp == null ? void 0 : onClickProp(event);
      if (!isTargetMenuItem(event.currentTarget))
        return;
      if (closeOnSelect ?? menuCloseOnSelect) {
        onClose();
      }
    },
    [onClose, onClickProp, menuCloseOnSelect, closeOnSelect]
  );
  const onFocus = useCallback(
    (event) => {
      onFocusProp == null ? void 0 : onFocusProp(event);
      setFocusedIndex(index);
    },
    [setFocusedIndex, onFocusProp, index]
  );
  const isFocused = index === focusedIndex;
  const clickableProps = useClickable({
    onClick,
    onFocus,
    onMouseEnter,
    onMouseMove,
    onMouseLeave,
    ref: mergeRefs(register, ref, externalRef),
    isDisabled,
    isFocusable
  });
  return {
    ...htmlProps,
    ...clickableProps,
    type: typeProp ?? clickableProps.type,
    id: id2,
    role: "menuitem",
    tabIndex: isFocused ? 0 : -1
  };
}
function useMenuOptionGroup(props = {}) {
  const {
    children,
    type: type2 = "radio",
    value: valueProp,
    defaultValue,
    onChange: onChangeProp,
    ...htmlProps
  } = props;
  const isRadio = type2 === "radio";
  const fallback = isRadio ? "" : [];
  const [value, setValue] = useControllableState({
    defaultValue: defaultValue ?? fallback,
    value: valueProp,
    onChange: onChangeProp
  });
  const onChange = useCallback(
    (selectedValue) => {
      if (type2 === "radio" && typeof value === "string") {
        setValue(selectedValue);
      }
      if (type2 === "checkbox" && Array.isArray(value)) {
        const nextValue = value.includes(selectedValue) ? value.filter((item) => item !== selectedValue) : value.concat(selectedValue);
        setValue(nextValue);
      }
    },
    [value, setValue, type2]
  );
  const validChildren = getValidChildren(children);
  const clones = validChildren.map((child) => {
    if (child.type.id !== "MenuItemOption")
      return child;
    const onClick = (event) => {
      var _a, _b;
      onChange(child.props.value);
      (_b = (_a = child.props).onClick) == null ? void 0 : _b.call(_a, event);
    };
    const isChecked = type2 === "radio" ? child.props.value === value : value.includes(child.props.value);
    return cloneElement(child, {
      type: type2,
      onClick,
      isChecked
    });
  });
  return {
    ...htmlProps,
    children: clones
  };
}
function isHTMLElement(el) {
  if (!isElement(el))
    return false;
  const win = el.ownerDocument.defaultView ?? window;
  return el instanceof win.HTMLElement;
}
function isElement(el) {
  return el != null && typeof el == "object" && "nodeType" in el && el.nodeType === Node.ELEMENT_NODE;
}
const [MenuStylesProvider, useMenuStyles] = createContext$1({
  name: `MenuStylesContext`,
  errorMessage: `useMenuStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Menu />" `
});
const Menu = (props) => {
  const { children } = props;
  const styles2 = useMultiStyleConfig("Menu", props);
  const ownProps = omitThemingProps(props);
  const { direction } = useTheme();
  const { descendants, ...ctx } = useMenu({ ...ownProps, direction });
  const context = useMemo(() => ctx, [ctx]);
  const { isOpen, onClose, forceUpdate } = context;
  return /* @__PURE__ */ jsx$1(MenuDescendantsProvider, { value: descendants, children: /* @__PURE__ */ jsx$1(MenuProvider, { value: context, children: /* @__PURE__ */ jsx$1(MenuStylesProvider, { value: styles2, children: runIfFn(children, { isOpen, onClose, forceUpdate }) }) }) });
};
Menu.displayName = "Menu";
const StyledMenuButton = forwardRef((props, ref) => {
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsx$1(
    chakra.button,
    {
      ref,
      ...props,
      __css: {
        display: "inline-flex",
        appearance: "none",
        alignItems: "center",
        outline: 0,
        ...styles2.button
      }
    }
  );
});
const MenuButton = forwardRef(
  (props, ref) => {
    const { children, as: As, ...rest } = props;
    const buttonProps = useMenuButton(rest, ref);
    const Element2 = As || StyledMenuButton;
    return /* @__PURE__ */ jsx$1(
      Element2,
      {
        ...buttonProps,
        className: cx("chakra-menu__menu-button", props.className),
        children: /* @__PURE__ */ jsx$1(
          chakra.span,
          {
            __css: { pointerEvents: "none", flex: "1 1 auto", minW: 0 },
            children: props.children
          }
        )
      }
    );
  }
);
MenuButton.displayName = "MenuButton";
const MenuCommand = forwardRef(
  (props, ref) => {
    const styles2 = useMenuStyles();
    return /* @__PURE__ */ jsx$1(
      chakra.span,
      {
        ref,
        ...props,
        __css: styles2.command,
        className: "chakra-menu__command"
      }
    );
  }
);
MenuCommand.displayName = "MenuCommand";
const MenuDivider = (props) => {
  const { className, ...rest } = props;
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsx$1(
    chakra.hr,
    {
      "aria-orientation": "horizontal",
      className: cx("chakra-menu__divider", className),
      ...rest,
      __css: styles2.divider
    }
  );
};
MenuDivider.displayName = "MenuDivider";
const MenuGroup = forwardRef((props, ref) => {
  const { title, children, className, ...rest } = props;
  const _className = cx("chakra-menu__group__title", className);
  const styles2 = useMenuStyles();
  return /* @__PURE__ */ jsxs("div", { ref, className: "chakra-menu__group", role: "group", children: [
    title && /* @__PURE__ */ jsx$1(chakra.p, { className: _className, ...rest, __css: styles2.groupTitle, children: title }),
    children
  ] });
});
MenuGroup.displayName = "MenuGroup";
const MenuIcon = (props) => {
  const { className, children, ...rest } = props;
  const styles2 = useMenuStyles();
  const child = Children.only(children);
  const clone = isValidElement$1(child) ? cloneElement(child, {
    focusable: "false",
    "aria-hidden": true,
    className: cx("chakra-menu__icon", child.props.className)
  }) : null;
  const _className = cx("chakra-menu__icon-wrapper", className);
  return /* @__PURE__ */ jsx$1(chakra.span, { className: _className, ...rest, __css: styles2.icon, children: clone });
};
MenuIcon.displayName = "MenuIcon";
const StyledMenuItem = forwardRef(
  (props, ref) => {
    const { type: type2, ...rest } = props;
    const styles2 = useMenuStyles();
    const btnType = rest.as || type2 ? type2 ?? void 0 : "button";
    const buttonStyles = useMemo(
      () => ({
        textDecoration: "none",
        color: "inherit",
        userSelect: "none",
        display: "flex",
        width: "100%",
        alignItems: "center",
        textAlign: "start",
        flex: "0 0 auto",
        outline: 0,
        ...styles2.item
      }),
      [styles2.item]
    );
    return /* @__PURE__ */ jsx$1(chakra.button, { ref, type: btnType, ...rest, __css: buttonStyles });
  }
);
const MenuItem = forwardRef((props, ref) => {
  const {
    icon,
    iconSpacing = "0.75rem",
    command,
    commandSpacing = "0.75rem",
    children,
    ...rest
  } = props;
  const menuitemProps = useMenuItem(rest, ref);
  const shouldWrap = icon || command;
  const _children = shouldWrap ? /* @__PURE__ */ jsx$1("span", { style: { pointerEvents: "none", flex: 1 }, children }) : children;
  return /* @__PURE__ */ jsxs(
    StyledMenuItem,
    {
      ...menuitemProps,
      className: cx("chakra-menu__menuitem", menuitemProps.className),
      children: [
        icon && /* @__PURE__ */ jsx$1(MenuIcon, { fontSize: "0.8em", marginEnd: iconSpacing, children: icon }),
        _children,
        command && /* @__PURE__ */ jsx$1(MenuCommand, { marginStart: commandSpacing, children: command })
      ]
    }
  );
});
MenuItem.displayName = "MenuItem";
const motionVariants = {
  enter: {
    visibility: "visible",
    opacity: 1,
    scale: 1,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    transitionEnd: {
      visibility: "hidden"
    },
    opacity: 0,
    scale: 0.8,
    transition: {
      duration: 0.1,
      easings: "easeOut"
    }
  }
};
const MenuTransition = chakra(motion.div);
const MenuList = forwardRef(
  function MenuList2(props, ref) {
    var _a;
    const { rootProps, motionProps, ...rest } = props;
    const {
      isOpen,
      onTransitionEnd,
      unstable__animationState: animated
    } = useMenuContext();
    const listProps = useMenuList(rest, ref);
    const positionerProps = useMenuPositioner(rootProps);
    const styles2 = useMenuStyles();
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ...positionerProps,
        __css: { zIndex: props.zIndex ?? ((_a = styles2.list) == null ? void 0 : _a.zIndex) },
        children: /* @__PURE__ */ jsx$1(
          MenuTransition,
          {
            variants: motionVariants,
            initial: false,
            animate: isOpen ? "enter" : "exit",
            __css: { outline: 0, ...styles2.list },
            ...motionProps,
            ...listProps,
            className: cx("chakra-menu__menu-list", listProps.className),
            onUpdate: onTransitionEnd,
            onAnimationComplete: callAll(
              animated.onComplete,
              listProps.onAnimationComplete
            )
          }
        )
      }
    );
  }
);
MenuList.displayName = "MenuList";
const MenuOptionGroup = (props) => {
  const { className, title, ...rest } = props;
  const ownProps = useMenuOptionGroup(rest);
  return /* @__PURE__ */ jsx$1(
    MenuGroup,
    {
      title,
      className: cx("chakra-menu__option-group", className),
      ...ownProps
    }
  );
};
MenuOptionGroup.displayName = "MenuOptionGroup";
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class ModalManager {
  constructor() {
    __publicField2(this, "modals");
    this.modals = /* @__PURE__ */ new Set();
  }
  add(modal) {
    this.modals.add(modal);
    return this.modals.size;
  }
  remove(modal) {
    this.modals.delete(modal);
  }
  isTopModal(modal) {
    if (!modal)
      return false;
    const topModal = Array.from(this.modals)[this.modals.size - 1];
    return modal === topModal;
  }
}
const modalManager = new ModalManager();
function useModalManager(ref, isOpen) {
  const [index, setIndex] = useState(0);
  useEffect(() => {
    const node = ref.current;
    if (!node)
      return;
    if (isOpen) {
      const index2 = modalManager.add(node);
      setIndex(index2);
    }
    return () => {
      modalManager.remove(node);
      setIndex(0);
    };
  }, [isOpen, ref]);
  return index;
}
function useModal(props) {
  const {
    isOpen,
    onClose,
    id: id2,
    closeOnOverlayClick = true,
    closeOnEsc = true,
    useInert = true,
    onOverlayClick: onOverlayClickProp,
    onEsc
  } = props;
  const dialogRef = useRef(null);
  const overlayRef = useRef(null);
  const [dialogId, headerId, bodyId] = useIds(
    id2,
    `chakra-modal`,
    `chakra-modal--header`,
    `chakra-modal--body`
  );
  useAriaHidden(dialogRef, isOpen && useInert);
  const index = useModalManager(dialogRef, isOpen);
  const mouseDownTarget = useRef(null);
  const onMouseDown = useCallback((event) => {
    mouseDownTarget.current = event.target;
  }, []);
  const onKeyDown = useCallback(
    (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        if (closeOnEsc) {
          onClose == null ? void 0 : onClose();
        }
        onEsc == null ? void 0 : onEsc();
      }
    },
    [closeOnEsc, onClose, onEsc]
  );
  const [headerMounted, setHeaderMounted] = useState(false);
  const [bodyMounted, setBodyMounted] = useState(false);
  const getDialogProps = useCallback(
    (props2 = {}, ref = null) => ({
      role: "dialog",
      ...props2,
      ref: mergeRefs(ref, dialogRef),
      id: dialogId,
      tabIndex: -1,
      "aria-modal": true,
      "aria-labelledby": headerMounted ? headerId : void 0,
      "aria-describedby": bodyMounted ? bodyId : void 0,
      onClick: callAllHandlers(
        props2.onClick,
        (event) => event.stopPropagation()
      )
    }),
    [bodyId, bodyMounted, dialogId, headerId, headerMounted]
  );
  const onOverlayClick = useCallback(
    (event) => {
      event.stopPropagation();
      if (mouseDownTarget.current !== event.target)
        return;
      if (!modalManager.isTopModal(dialogRef.current))
        return;
      if (closeOnOverlayClick) {
        onClose == null ? void 0 : onClose();
      }
      onOverlayClickProp == null ? void 0 : onOverlayClickProp();
    },
    [onClose, closeOnOverlayClick, onOverlayClickProp]
  );
  const getDialogContainerProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref: mergeRefs(ref, overlayRef),
      onClick: callAllHandlers(props2.onClick, onOverlayClick),
      onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),
      onMouseDown: callAllHandlers(props2.onMouseDown, onMouseDown)
    }),
    [onKeyDown, onMouseDown, onOverlayClick]
  );
  return {
    isOpen,
    onClose,
    headerId,
    bodyId,
    setBodyMounted,
    setHeaderMounted,
    dialogRef,
    overlayRef,
    getDialogProps,
    getDialogContainerProps,
    index
  };
}
function useAriaHidden(ref, shouldHide) {
  const currentElement = ref.current;
  useEffect(() => {
    if (!ref.current || !shouldHide)
      return void 0;
    return hideOthers(ref.current);
  }, [shouldHide, ref, currentElement]);
}
function useIds(idProp, ...prefixes) {
  const reactId = useId$1();
  const id2 = idProp || reactId;
  return useMemo(() => {
    return prefixes.map((prefix2) => `${prefix2}-${id2}`);
  }, [id2, prefixes]);
}
const [ModalStylesProvider, useModalStyles] = createContext$1({
  name: `ModalStylesContext`,
  errorMessage: `useModalStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Modal />" `
});
const [ModalContextProvider, useModalContext] = createContext$1({
  strict: true,
  name: "ModalContext",
  errorMessage: "useModalContext: `context` is undefined. Seems you forgot to wrap modal components in `<Modal />`"
});
const Modal = (props) => {
  const modalProps = {
    scrollBehavior: "outside",
    autoFocus: true,
    trapFocus: true,
    returnFocusOnClose: true,
    blockScrollOnMount: true,
    allowPinchZoom: false,
    preserveScrollBarGap: true,
    motionPreset: "scale",
    ...props,
    lockFocusAcrossFrames: props.lockFocusAcrossFrames || true
  };
  const {
    portalProps,
    children,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames,
    animatePresenceProps,
    onCloseComplete
  } = modalProps;
  const styles2 = useMultiStyleConfig("Modal", modalProps);
  const modal = useModal(modalProps);
  const context = {
    ...modal,
    autoFocus,
    trapFocus,
    initialFocusRef,
    finalFocusRef,
    returnFocusOnClose,
    blockScrollOnMount,
    allowPinchZoom,
    preserveScrollBarGap,
    motionPreset,
    lockFocusAcrossFrames
  };
  return /* @__PURE__ */ jsx$1(ModalContextProvider, { value: context, children: /* @__PURE__ */ jsx$1(ModalStylesProvider, { value: styles2, children: /* @__PURE__ */ jsx$1(
    AnimatePresence,
    {
      ...animatePresenceProps,
      onExitComplete: onCloseComplete,
      children: context.isOpen && /* @__PURE__ */ jsx$1(Portal, { ...portalProps, children })
    }
  ) }) });
};
Modal.displayName = "Modal";
function ModalFocusScope(props) {
  const {
    autoFocus,
    trapFocus,
    dialogRef,
    initialFocusRef,
    blockScrollOnMount,
    allowPinchZoom,
    finalFocusRef,
    returnFocusOnClose,
    preserveScrollBarGap,
    lockFocusAcrossFrames,
    isOpen
  } = useModalContext();
  const [isPresent2, safeToRemove] = usePresence();
  useEffect(() => {
    if (!isPresent2 && safeToRemove) {
      setTimeout(safeToRemove);
    }
  }, [isPresent2, safeToRemove]);
  const index = useModalManager(dialogRef, isOpen);
  return /* @__PURE__ */ jsx$1(
    FocusLock,
    {
      autoFocus,
      isDisabled: !trapFocus,
      initialFocusRef,
      finalFocusRef,
      restoreFocus: returnFocusOnClose,
      contentRef: dialogRef,
      lockFocusAcrossFrames,
      children: /* @__PURE__ */ jsx$1(
        RemoveScroll,
        {
          removeScrollBar: !preserveScrollBarGap,
          allowPinchZoom,
          enabled: index === 1 && blockScrollOnMount,
          forwardProps: true,
          children: props.children
        }
      )
    }
  );
}
const variants$c = {
  initial: ({ offsetX, offsetY, transition: transition2, transitionEnd, delay: delay2 }) => ({
    opacity: 0,
    x: offsetX,
    y: offsetY,
    transition: (transition2 == null ? void 0 : transition2.exit) ?? withDelay.exit(TRANSITION_DEFAULTS.exit, delay2),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
  }),
  enter: ({ transition: transition2, transitionEnd, delay: delay2 }) => ({
    opacity: 1,
    x: 0,
    y: 0,
    transition: (transition2 == null ? void 0 : transition2.enter) ?? withDelay.enter(TRANSITION_DEFAULTS.enter, delay2),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
  }),
  exit: ({ offsetY, offsetX, transition: transition2, transitionEnd, reverse, delay: delay2 }) => {
    const offset = { x: offsetX, y: offsetY };
    return {
      opacity: 0,
      transition: (transition2 == null ? void 0 : transition2.exit) ?? withDelay.exit(TRANSITION_DEFAULTS.exit, delay2),
      ...reverse ? { ...offset, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { ...offset, ...transitionEnd == null ? void 0 : transitionEnd.exit } }
    };
  }
};
const slideFadeConfig = {
  initial: "initial",
  animate: "enter",
  exit: "exit",
  variants: variants$c
};
const SlideFade = forwardRef$1(
  function SlideFade2(props, ref) {
    const {
      unmountOnExit,
      in: isOpen,
      reverse = true,
      className,
      offsetX = 0,
      offsetY = 8,
      transition: transition2,
      transitionEnd,
      delay: delay2,
      animatePresenceProps,
      ...rest
    } = props;
    const show = unmountOnExit ? isOpen && unmountOnExit : true;
    const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
    const custom = {
      offsetX,
      offsetY,
      reverse,
      transition: transition2,
      transitionEnd,
      delay: delay2
    };
    return /* @__PURE__ */ jsx$1(AnimatePresence, { ...animatePresenceProps, custom, children: show && /* @__PURE__ */ jsx$1(
      motion.div,
      {
        ref,
        className: cx("chakra-offset-slide", className),
        custom,
        ...slideFadeConfig,
        animate: animate2,
        ...rest
      }
    ) });
  }
);
SlideFade.displayName = "SlideFade";
const variants$b = {
  exit: ({ reverse, initialScale, transition: transition2, transitionEnd, delay: delay2 }) => ({
    opacity: 0,
    ...reverse ? { scale: initialScale, transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit } : { transitionEnd: { scale: initialScale, ...transitionEnd == null ? void 0 : transitionEnd.exit } },
    transition: (transition2 == null ? void 0 : transition2.exit) ?? withDelay.exit(TRANSITION_DEFAULTS.exit, delay2)
  }),
  enter: ({ transitionEnd, transition: transition2, delay: delay2 }) => ({
    opacity: 1,
    scale: 1,
    transition: (transition2 == null ? void 0 : transition2.enter) ?? withDelay.enter(TRANSITION_DEFAULTS.enter, delay2),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
  })
};
const scaleFadeConfig = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants$b
};
const ScaleFade = forwardRef$1(
  function ScaleFade2(props, ref) {
    const {
      unmountOnExit,
      in: isOpen,
      reverse = true,
      initialScale = 0.95,
      className,
      transition: transition2,
      transitionEnd,
      delay: delay2,
      animatePresenceProps,
      ...rest
    } = props;
    const show = unmountOnExit ? isOpen && unmountOnExit : true;
    const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
    const custom = { initialScale, reverse, transition: transition2, transitionEnd, delay: delay2 };
    return /* @__PURE__ */ jsx$1(AnimatePresence, { ...animatePresenceProps, custom, children: show && /* @__PURE__ */ jsx$1(
      motion.div,
      {
        ref,
        className: cx("chakra-offset-slide", className),
        ...scaleFadeConfig,
        animate: animate2,
        custom,
        ...rest
      }
    ) });
  }
);
ScaleFade.displayName = "ScaleFade";
const transitions = {
  slideInBottom: {
    ...slideFadeConfig,
    custom: { offsetY: 16, reverse: true }
  },
  slideInRight: {
    ...slideFadeConfig,
    custom: { offsetX: 16, reverse: true }
  },
  slideInTop: {
    ...slideFadeConfig,
    custom: { offsetY: -16, reverse: true }
  },
  slideInLeft: {
    ...slideFadeConfig,
    custom: { offsetX: -16, reverse: true }
  },
  scale: {
    ...scaleFadeConfig,
    custom: { initialScale: 0.95, reverse: true }
  },
  none: {}
};
const MotionSection = chakra(motion.section);
const getMotionProps = (preset) => {
  return transitions[preset || "none"];
};
const ModalTransition = forwardRef$1(
  (props, ref) => {
    const { preset, motionProps = getMotionProps(preset), ...rest } = props;
    return /* @__PURE__ */ jsx$1(MotionSection, { ref, ...motionProps, ...rest });
  }
);
ModalTransition.displayName = "ModalTransition";
const ModalContent = forwardRef(
  (props, ref) => {
    const {
      className,
      children,
      containerProps: rootProps,
      motionProps,
      ...rest
    } = props;
    const { getDialogProps, getDialogContainerProps } = useModalContext();
    const dialogProps = getDialogProps(rest, ref);
    const containerProps = getDialogContainerProps(rootProps);
    const _className = cx("chakra-modal__content", className);
    const styles2 = useModalStyles();
    const dialogStyles = defineStyle({
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      ...styles2.dialog
    });
    const dialogContainerStyles = defineStyle({
      display: "flex",
      width: "100vw",
      height: "$100vh",
      position: "fixed",
      left: 0,
      top: 0,
      ...styles2.dialogContainer
    });
    const { motionPreset } = useModalContext();
    return /* @__PURE__ */ jsx$1(ModalFocusScope, { children: /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ...containerProps,
        className: "chakra-modal__content-container",
        tabIndex: -1,
        __css: dialogContainerStyles,
        children: /* @__PURE__ */ jsx$1(
          ModalTransition,
          {
            preset: motionPreset,
            motionProps,
            className: _className,
            ...dialogProps,
            __css: dialogStyles,
            children
          }
        )
      }
    ) });
  }
);
ModalContent.displayName = "ModalContent";
const ModalBody = forwardRef((props, ref) => {
  const { className, ...rest } = props;
  const { bodyId, setBodyMounted } = useModalContext();
  useEffect(() => {
    setBodyMounted(true);
    return () => setBodyMounted(false);
  }, [setBodyMounted]);
  const _className = cx("chakra-modal__body", className);
  const styles2 = useModalStyles();
  return /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      ref,
      className: _className,
      id: bodyId,
      ...rest,
      __css: styles2.body
    }
  );
});
ModalBody.displayName = "ModalBody";
const ModalCloseButton = forwardRef(
  (props, ref) => {
    const { onClick, className, ...rest } = props;
    const { onClose } = useModalContext();
    const _className = cx("chakra-modal__close-btn", className);
    const styles2 = useModalStyles();
    return /* @__PURE__ */ jsx$1(
      CloseButton,
      {
        ref,
        __css: styles2.closeButton,
        className: _className,
        onClick: callAllHandlers(onClick, (event) => {
          event.stopPropagation();
          onClose();
        }),
        ...rest
      }
    );
  }
);
ModalCloseButton.displayName = "ModalCloseButton";
const ModalFooter = forwardRef(
  (props, ref) => {
    const { className, ...rest } = props;
    const _className = cx("chakra-modal__footer", className);
    const styles2 = useModalStyles();
    const footerStyles = defineStyle({
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-end",
      ...styles2.footer
    });
    return /* @__PURE__ */ jsx$1(
      chakra.footer,
      {
        ref,
        ...rest,
        __css: footerStyles,
        className: _className
      }
    );
  }
);
ModalFooter.displayName = "ModalFooter";
const ModalHeader = forwardRef(
  (props, ref) => {
    const { className, ...rest } = props;
    const { headerId, setHeaderMounted } = useModalContext();
    useEffect(() => {
      setHeaderMounted(true);
      return () => setHeaderMounted(false);
    }, [setHeaderMounted]);
    const _className = cx("chakra-modal__header", className);
    const styles2 = useModalStyles();
    const headerStyles = defineStyle({
      flex: 0,
      ...styles2.header
    });
    return /* @__PURE__ */ jsx$1(
      chakra.header,
      {
        ref,
        className: _className,
        id: headerId,
        ...rest,
        __css: headerStyles
      }
    );
  }
);
ModalHeader.displayName = "ModalHeader";
const variants$a = {
  enter: ({ transition: transition2, transitionEnd, delay: delay2 } = {}) => ({
    opacity: 1,
    transition: (transition2 == null ? void 0 : transition2.enter) ?? withDelay.enter(TRANSITION_DEFAULTS.enter, delay2),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
  }),
  exit: ({ transition: transition2, transitionEnd, delay: delay2 } = {}) => ({
    opacity: 0,
    transition: (transition2 == null ? void 0 : transition2.exit) ?? withDelay.exit(TRANSITION_DEFAULTS.exit, delay2),
    transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
  })
};
const fadeConfig = {
  initial: "exit",
  animate: "enter",
  exit: "exit",
  variants: variants$a
};
const Fade = forwardRef$1(
  function Fade2(props, ref) {
    const {
      unmountOnExit,
      in: isOpen,
      className,
      transition: transition2,
      transitionEnd,
      delay: delay2,
      animatePresenceProps,
      ...rest
    } = props;
    const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
    const show = unmountOnExit ? isOpen && unmountOnExit : true;
    const custom = { transition: transition2, transitionEnd, delay: delay2 };
    return /* @__PURE__ */ jsx$1(AnimatePresence, { ...animatePresenceProps, custom, children: show && /* @__PURE__ */ jsx$1(
      motion.div,
      {
        ref,
        className: cx("chakra-fade", className),
        custom,
        ...fadeConfig,
        animate: animate2,
        ...rest
      }
    ) });
  }
);
Fade.displayName = "Fade";
const MotionDiv$2 = chakra(motion.div);
const ModalOverlay = forwardRef(
  (props, ref) => {
    const { className, transition: transition2, motionProps: _motionProps, ...rest } = props;
    const _className = cx("chakra-modal__overlay", className);
    const styles2 = useModalStyles();
    const overlayStyle = {
      pos: "fixed",
      left: "0",
      top: "0",
      w: "100vw",
      h: "100vh",
      ...styles2.overlay
    };
    const { motionPreset } = useModalContext();
    const defaultMotionProps = motionPreset === "none" ? {} : fadeConfig;
    const motionProps = _motionProps || defaultMotionProps;
    return /* @__PURE__ */ jsx$1(
      MotionDiv$2,
      {
        ...motionProps,
        __css: overlayStyle,
        ref,
        className: _className,
        ...rest
      }
    );
  }
);
ModalOverlay.displayName = "ModalOverlay";
function AlertDialog(props) {
  const { leastDestructiveRef, ...rest } = props;
  return /* @__PURE__ */ jsx$1(Modal, { ...rest, initialFocusRef: leastDestructiveRef });
}
const AlertDialogContent = forwardRef(
  (props, ref) => /* @__PURE__ */ jsx$1(ModalContent, { ref, role: "alertdialog", ...props })
);
const [DrawerContextProvider, useDrawerContext] = createContext$1();
const placementMap = {
  start: { ltr: "left", rtl: "right" },
  end: { ltr: "right", rtl: "left" }
};
function getDrawerPlacement(placement, dir) {
  var _a;
  if (!placement)
    return;
  return ((_a = placementMap[placement]) == null ? void 0 : _a[dir]) ?? placement;
}
function Drawer(props) {
  var _a;
  const {
    isOpen,
    onClose,
    placement: placementProp = "right",
    children,
    ...rest
  } = props;
  const theme2 = useTheme();
  const drawerStyleConfig = (_a = theme2.components) == null ? void 0 : _a.Drawer;
  const placement = getDrawerPlacement(placementProp, theme2.direction);
  return /* @__PURE__ */ jsx$1(DrawerContextProvider, { value: { placement }, children: /* @__PURE__ */ jsx$1(
    Modal,
    {
      isOpen,
      onClose,
      styleConfig: drawerStyleConfig,
      ...rest,
      children
    }
  ) });
}
const defaultTransition = {
  exit: {
    duration: 0.15,
    ease: TRANSITION_EASINGS.easeInOut
  },
  enter: {
    type: "spring",
    damping: 25,
    stiffness: 180
  }
};
const variants$9 = {
  exit: ({ direction, transition: transition2, transitionEnd, delay: delay2 }) => {
    const { exit: exitStyles } = getSlideTransition({ direction });
    return {
      ...exitStyles,
      transition: (transition2 == null ? void 0 : transition2.exit) ?? withDelay.exit(defaultTransition.exit, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.exit
    };
  },
  enter: ({ direction, transitionEnd, transition: transition2, delay: delay2 }) => {
    const { enter: enterStyles } = getSlideTransition({ direction });
    return {
      ...enterStyles,
      transition: (transition2 == null ? void 0 : transition2.enter) ?? withDelay.enter(defaultTransition.enter, delay2),
      transitionEnd: transitionEnd == null ? void 0 : transitionEnd.enter
    };
  }
};
const Slide = forwardRef$1(
  function Slide2(props, ref) {
    const {
      direction = "right",
      style,
      unmountOnExit,
      in: isOpen,
      className,
      transition: transition2,
      transitionEnd,
      delay: delay2,
      motionProps,
      animatePresenceProps,
      ...rest
    } = props;
    const transitionStyles = getSlideTransition({ direction });
    const computedStyle = Object.assign(
      { position: "fixed" },
      transitionStyles.position,
      style
    );
    const show = unmountOnExit ? isOpen && unmountOnExit : true;
    const animate2 = isOpen || unmountOnExit ? "enter" : "exit";
    const custom = { transitionEnd, transition: transition2, direction, delay: delay2 };
    return /* @__PURE__ */ jsx$1(AnimatePresence, { ...animatePresenceProps, custom, children: show && /* @__PURE__ */ jsx$1(
      motion.div,
      {
        ...rest,
        ref,
        initial: "exit",
        className: cx("chakra-slide", className),
        animate: animate2,
        exit: "exit",
        custom,
        variants: variants$9,
        style: computedStyle,
        ...motionProps
      }
    ) });
  }
);
Slide.displayName = "Slide";
const MotionDiv$1 = chakra(Slide);
const DrawerContent = forwardRef(
  (props, ref) => {
    const {
      className,
      children,
      motionProps,
      containerProps: rootProps,
      ...rest
    } = props;
    const { getDialogProps, getDialogContainerProps, isOpen } = useModalContext();
    const dialogProps = getDialogProps(rest, ref);
    const containerProps = getDialogContainerProps(rootProps);
    const _className = cx("chakra-modal__content", className);
    const styles2 = useModalStyles();
    const dialogStyles = {
      display: "flex",
      flexDirection: "column",
      position: "relative",
      width: "100%",
      outline: 0,
      ...styles2.dialog
    };
    const dialogContainerStyles = {
      display: "flex",
      width: "100vw",
      height: "$100vh",
      position: "fixed",
      left: 0,
      top: 0,
      ...styles2.dialogContainer
    };
    const { placement } = useDrawerContext();
    return /* @__PURE__ */ jsx$1(ModalFocusScope, { children: /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ...containerProps,
        className: "chakra-modal__content-container",
        __css: dialogContainerStyles,
        children: /* @__PURE__ */ jsx$1(
          MotionDiv$1,
          {
            motionProps,
            direction: placement,
            in: isOpen,
            className: _className,
            ...dialogProps,
            __css: dialogStyles,
            children
          }
        )
      }
    ) });
  }
);
DrawerContent.displayName = "DrawerContent";
function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
keyframes$1({
  "0%": {
    strokeDasharray: "1, 400",
    strokeDashoffset: "0"
  },
  "50%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-100"
  },
  "100%": {
    strokeDasharray: "400, 400",
    strokeDashoffset: "-260"
  }
});
keyframes$1({
  "0%": {
    transform: "rotate(0deg)"
  },
  "100%": {
    transform: "rotate(360deg)"
  }
});
const progress = keyframes$1({
  "0%": { left: "-40%" },
  "100%": { left: "100%" }
});
const stripe = keyframes$1({
  from: { backgroundPosition: "1rem 0" },
  to: { backgroundPosition: "0 0" }
});
function getProgressProps(options) {
  const {
    value = 0,
    min,
    max,
    valueText,
    getValueText,
    isIndeterminate,
    role = "progressbar"
  } = options;
  const percent2 = valueToPercent(value, min, max);
  const getAriaValueText = () => {
    if (value == null)
      return void 0;
    return typeof getValueText === "function" ? getValueText(value, percent2) : valueText;
  };
  return {
    bind: {
      "data-indeterminate": isIndeterminate ? "" : void 0,
      "aria-valuemax": max,
      "aria-valuemin": min,
      "aria-valuenow": isIndeterminate ? void 0 : value,
      "aria-valuetext": getAriaValueText(),
      role
    },
    percent: percent2,
    value
  };
}
const [ProgressStylesProvider, useProgressStyles] = createContext$1({
  name: `ProgressStylesContext`,
  errorMessage: `useProgressStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Progress />" `
});
const ProgressFilledTrack = forwardRef(
  (props, ref) => {
    const { min, max, value, isIndeterminate, role, ...rest } = props;
    const progress2 = getProgressProps({
      value,
      min,
      max,
      isIndeterminate,
      role
    });
    const styles2 = useProgressStyles();
    const trackStyles = {
      height: "100%",
      ...styles2.filledTrack
    };
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        style: { width: `${progress2.percent}%`, ...rest.style },
        ...progress2.bind,
        ...rest,
        __css: trackStyles
      }
    );
  }
);
const Progress = forwardRef((props, ref) => {
  var _a;
  const {
    value,
    min = 0,
    max = 100,
    hasStripe,
    isAnimated,
    children,
    borderRadius: propBorderRadius,
    isIndeterminate,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-valuetext": ariaValueText,
    title,
    role,
    ...rest
  } = omitThemingProps(props);
  const styles2 = useMultiStyleConfig("Progress", props);
  const borderRadius = propBorderRadius ?? ((_a = styles2.track) == null ? void 0 : _a.borderRadius);
  const stripeAnimation = { animation: `${stripe} 1s linear infinite` };
  const shouldAddStripe = !isIndeterminate && hasStripe;
  const shouldAnimateStripe = shouldAddStripe && isAnimated;
  const css2 = {
    ...shouldAnimateStripe && stripeAnimation,
    ...isIndeterminate && {
      position: "absolute",
      willChange: "left",
      minWidth: "50%",
      animation: `${progress} 1s ease infinite normal none running`
    }
  };
  const trackStyles = {
    overflow: "hidden",
    position: "relative",
    ...styles2.track
  };
  return /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      ref,
      borderRadius,
      __css: trackStyles,
      ...rest,
      children: /* @__PURE__ */ jsxs(ProgressStylesProvider, { value: styles2, children: [
        /* @__PURE__ */ jsx$1(
          ProgressFilledTrack,
          {
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-valuetext": ariaValueText,
            min,
            max,
            value,
            isIndeterminate,
            css: css2,
            borderRadius,
            title,
            role
          }
        ),
        children
      ] })
    }
  );
});
Progress.displayName = "Progress";
function isInputEvent(value) {
  return value && isObject(value) && isObject(value.target);
}
function useRadioGroup(props = {}) {
  const {
    onChange: onChangeProp,
    value: valueProp,
    defaultValue,
    name: nameProp,
    isDisabled,
    isFocusable,
    isNative,
    ...htmlProps
  } = props;
  const [valueState, setValue] = useState(defaultValue || "");
  const isControlled = typeof valueProp !== "undefined";
  const value = isControlled ? valueProp : valueState;
  const ref = useRef(null);
  const focus = useCallback(() => {
    const rootNode = ref.current;
    if (!rootNode)
      return;
    let query = `input:not(:disabled):checked`;
    const firstEnabledAndCheckedInput = rootNode.querySelector(
      query
    );
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    query = `input:not(:disabled)`;
    const firstEnabledInput = rootNode.querySelector(query);
    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
  }, []);
  const uuid = useId$1();
  const fallbackName = `radio-${uuid}`;
  const name2 = nameProp || fallbackName;
  const onChange = useCallback(
    (eventOrValue) => {
      const nextValue = isInputEvent(eventOrValue) ? eventOrValue.target.value : eventOrValue;
      if (!isControlled) {
        setValue(nextValue);
      }
      onChangeProp == null ? void 0 : onChangeProp(String(nextValue));
    },
    [onChangeProp, isControlled]
  );
  const getRootProps = useCallback(
    (props2 = {}, forwardedRef = null) => ({
      ...props2,
      ref: mergeRefs(forwardedRef, ref),
      role: "radiogroup"
    }),
    []
  );
  const getRadioProps = useCallback(
    (props2 = {}, ref2 = null) => {
      const checkedKey = isNative ? "checked" : "isChecked";
      return {
        ...props2,
        ref: ref2,
        name: name2,
        [checkedKey]: value != null ? props2.value === value : void 0,
        onChange(event) {
          onChange(event);
        },
        "data-radiogroup": true
      };
    },
    [isNative, name2, onChange, value]
  );
  return {
    getRootProps,
    getRadioProps,
    name: name2,
    ref,
    focus,
    setValue,
    value,
    onChange,
    isDisabled,
    isFocusable,
    htmlProps
  };
}
const [RadioGroupProvider, useRadioGroupContext] = createContext$1({
  name: "RadioGroupContext",
  strict: false
});
const RadioGroup = forwardRef((props, ref) => {
  const {
    colorScheme,
    size,
    variant,
    children,
    className,
    isDisabled,
    isFocusable,
    ...rest
  } = props;
  const { value, onChange, getRootProps, name: name2, htmlProps } = useRadioGroup(rest);
  const group = useMemo(
    () => ({
      name: name2,
      size,
      onChange,
      colorScheme,
      value,
      variant,
      isDisabled,
      isFocusable
    }),
    [
      name2,
      size,
      onChange,
      colorScheme,
      value,
      variant,
      isDisabled,
      isFocusable
    ]
  );
  return /* @__PURE__ */ jsx$1(RadioGroupProvider, { value: group, children: /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      ...getRootProps(htmlProps, ref),
      className: cx("chakra-radio-group", className),
      children
    }
  ) });
});
RadioGroup.displayName = "RadioGroup";
function useRadio(props = {}) {
  const {
    defaultChecked,
    isChecked: isCheckedProp,
    isFocusable,
    isDisabled: isDisabledProp,
    isReadOnly: isReadOnlyProp,
    isRequired: isRequiredProp,
    onChange,
    isInvalid: isInvalidProp,
    name: name2,
    value,
    id: idProp,
    "data-radiogroup": dataRadioGroup,
    "aria-describedby": ariaDescribedBy,
    ...htmlProps
  } = props;
  const uuid = `radio-${useId$1()}`;
  const formControl = useFormControlContext();
  const group = useRadioGroupContext();
  const isWithinRadioGroup = !!group || !!dataRadioGroup;
  const isWithinFormControl = !!formControl;
  let id2 = isWithinFormControl && !isWithinRadioGroup ? formControl.id : uuid;
  id2 = idProp ?? id2;
  const isDisabled = isDisabledProp ?? (formControl == null ? void 0 : formControl.isDisabled);
  const isReadOnly = isReadOnlyProp ?? (formControl == null ? void 0 : formControl.isReadOnly);
  const isRequired = isRequiredProp ?? (formControl == null ? void 0 : formControl.isRequired);
  const isInvalid = isInvalidProp ?? (formControl == null ? void 0 : formControl.isInvalid);
  const [isFocusVisible, setIsFocusVisible] = useState(false);
  const [isFocused, setFocused] = useState(false);
  const [isHovered, setHovering] = useState(false);
  const [isActive, setActive] = useState(false);
  const [isCheckedState, setChecked] = useState(Boolean(defaultChecked));
  const isControlled = typeof isCheckedProp !== "undefined";
  const isChecked = isControlled ? isCheckedProp : isCheckedState;
  useEffect(() => {
    return trackFocusVisible(setIsFocusVisible);
  }, []);
  const handleChange = useCallback(
    (event) => {
      if (isReadOnly || isDisabled) {
        event.preventDefault();
        return;
      }
      if (!isControlled) {
        setChecked(event.currentTarget.checked);
      }
      onChange == null ? void 0 : onChange(event);
    },
    [isControlled, isDisabled, isReadOnly, onChange]
  );
  const onKeyDown = useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(true);
      }
    },
    [setActive]
  );
  const onKeyUp = useCallback(
    (event) => {
      if (event.key === " ") {
        setActive(false);
      }
    },
    [setActive]
  );
  const getRadioProps = useCallback(
    (props2 = {}, ref = null) => ({
      ...props2,
      ref,
      "data-active": dataAttr(isActive),
      "data-hover": dataAttr(isHovered),
      "data-disabled": dataAttr(isDisabled),
      "data-invalid": dataAttr(isInvalid),
      "data-checked": dataAttr(isChecked),
      "data-focus": dataAttr(isFocused),
      "data-focus-visible": dataAttr(isFocused && isFocusVisible),
      "data-readonly": dataAttr(isReadOnly),
      "aria-hidden": true,
      onMouseDown: callAllHandlers(props2.onMouseDown, () => setActive(true)),
      onMouseUp: callAllHandlers(props2.onMouseUp, () => setActive(false)),
      onMouseEnter: callAllHandlers(
        props2.onMouseEnter,
        () => setHovering(true)
      ),
      onMouseLeave: callAllHandlers(
        props2.onMouseLeave,
        () => setHovering(false)
      )
    }),
    [
      isActive,
      isHovered,
      isDisabled,
      isInvalid,
      isChecked,
      isFocused,
      isReadOnly,
      isFocusVisible
    ]
  );
  const { onFocus, onBlur } = formControl ?? {};
  const getInputProps = useCallback(
    (props2 = {}, ref = null) => {
      const trulyDisabled = isDisabled && !isFocusable;
      return {
        ...props2,
        id: id2,
        ref,
        type: "radio",
        name: name2,
        value,
        onChange: callAllHandlers(props2.onChange, handleChange),
        onBlur: callAllHandlers(
          onBlur,
          props2.onBlur,
          () => setFocused(false)
        ),
        onFocus: callAllHandlers(
          onFocus,
          props2.onFocus,
          () => setFocused(true)
        ),
        onKeyDown: callAllHandlers(props2.onKeyDown, onKeyDown),
        onKeyUp: callAllHandlers(props2.onKeyUp, onKeyUp),
        checked: isChecked,
        disabled: trulyDisabled,
        readOnly: isReadOnly,
        required: isRequired,
        "aria-invalid": ariaAttr(isInvalid),
        "aria-disabled": ariaAttr(trulyDisabled),
        "aria-required": ariaAttr(isRequired),
        "data-readonly": dataAttr(isReadOnly),
        "aria-describedby": ariaDescribedBy,
        style: visuallyHiddenStyle
      };
    },
    [
      isDisabled,
      isFocusable,
      id2,
      name2,
      value,
      handleChange,
      onBlur,
      onFocus,
      onKeyDown,
      onKeyUp,
      isChecked,
      isReadOnly,
      isRequired,
      isInvalid,
      ariaDescribedBy
    ]
  );
  const getLabelProps = (props2 = {}, ref = null) => ({
    ...props2,
    ref,
    onMouseDown: callAllHandlers(props2.onMouseDown, stopEvent),
    "data-disabled": dataAttr(isDisabled),
    "data-checked": dataAttr(isChecked),
    "data-invalid": dataAttr(isInvalid)
  });
  const getRootProps = (props2, ref = null) => ({
    htmlFor: id2,
    ...props2,
    ref,
    "data-disabled": dataAttr(isDisabled),
    "data-checked": dataAttr(isChecked),
    "data-invalid": dataAttr(isInvalid)
  });
  const state2 = {
    isInvalid,
    isFocused,
    isChecked,
    isActive,
    isHovered,
    isDisabled,
    isReadOnly,
    isRequired
  };
  return {
    state: state2,
    getRadioProps,
    getInputProps,
    getLabelProps,
    getRootProps,
    htmlProps
  };
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
const Radio = forwardRef((props, ref) => {
  const group = useRadioGroupContext();
  const { onChange: onChangeProp, value: valueProp } = props;
  const styles2 = useMultiStyleConfig("Radio", { ...group, ...props });
  const ownProps = omitThemingProps(props);
  const {
    spacing = "0.5rem",
    children,
    isDisabled = group == null ? void 0 : group.isDisabled,
    isFocusable = group == null ? void 0 : group.isFocusable,
    inputProps: htmlInputProps,
    ...rest
  } = ownProps;
  let isChecked = props.isChecked;
  if ((group == null ? void 0 : group.value) != null && valueProp != null) {
    isChecked = group.value === valueProp;
  }
  let onChange = onChangeProp;
  if ((group == null ? void 0 : group.onChange) && valueProp != null) {
    onChange = callAll(group.onChange, onChangeProp);
  }
  const name2 = (props == null ? void 0 : props.name) ?? (group == null ? void 0 : group.name);
  const {
    getInputProps,
    getRadioProps,
    getLabelProps,
    getRootProps,
    htmlProps
  } = useRadio({
    ...rest,
    isChecked,
    isFocusable,
    isDisabled,
    onChange,
    name: name2
  });
  const [layoutProps, otherProps] = split(htmlProps, layoutPropNames);
  const checkboxProps = getRadioProps(otherProps);
  const inputProps = getInputProps(htmlInputProps, ref);
  const labelProps = getLabelProps();
  const rootProps = Object.assign({}, layoutProps, getRootProps());
  const rootStyles2 = {
    display: "inline-flex",
    alignItems: "center",
    verticalAlign: "top",
    cursor: "pointer",
    position: "relative",
    ...styles2.container
  };
  const checkboxStyles = {
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    ...styles2.control
  };
  const labelStyles = {
    userSelect: "none",
    marginStart: spacing,
    ...styles2.label
  };
  return /* @__PURE__ */ jsxs(chakra.label, { className: "chakra-radio", ...rootProps, __css: rootStyles2, children: [
    /* @__PURE__ */ jsx$1("input", { className: "chakra-radio__input", ...inputProps }),
    /* @__PURE__ */ jsx$1(
      chakra.span,
      {
        className: "chakra-radio__control",
        ...checkboxProps,
        __css: checkboxStyles
      }
    ),
    children && /* @__PURE__ */ jsx$1(
      chakra.span,
      {
        className: "chakra-radio__label",
        ...labelProps,
        __css: labelStyles,
        children
      }
    )
  ] });
});
Radio.displayName = "Radio";
function useIsFirstRender() {
  const isFirstRender = useRef(true);
  useEffect(() => {
    isFirstRender.current = false;
  }, []);
  return isFirstRender.current;
}
const StyledSkeleton = chakra("div", {
  baseStyle: {
    boxShadow: "none",
    backgroundClip: "padding-box",
    cursor: "default",
    color: "transparent",
    pointerEvents: "none",
    userSelect: "none",
    "&::before, &::after, *": {
      visibility: "hidden"
    }
  }
});
const $startColor = cssVar("skeleton-start-color");
const $endColor = cssVar("skeleton-end-color");
const fade = keyframes$1({
  from: { opacity: 0 },
  to: { opacity: 1 }
});
const bgFade = keyframes$1({
  from: {
    borderColor: $startColor.reference,
    background: $startColor.reference
  },
  to: {
    borderColor: $endColor.reference,
    background: $endColor.reference
  }
});
const Skeleton = forwardRef((props, ref) => {
  const skeletonProps = {
    ...props,
    fadeDuration: typeof props.fadeDuration === "number" ? props.fadeDuration : 0.4,
    speed: typeof props.speed === "number" ? props.speed : 0.8
  };
  const styles2 = useStyleConfig("Skeleton", skeletonProps);
  const isFirstRender = useIsFirstRender();
  const {
    startColor = "",
    endColor = "",
    isLoaded,
    fadeDuration,
    speed,
    className,
    fitContent,
    animation: animationProp,
    ...rest
  } = omitThemingProps(skeletonProps);
  const [startColorVar, endColorVar] = useToken("colors", [
    startColor,
    endColor
  ]);
  const wasPreviouslyLoaded = usePrevious(isLoaded);
  const _className = cx("chakra-skeleton", className);
  const cssVarStyles = {
    ...startColorVar && { [$startColor.variable]: startColorVar },
    ...endColorVar && { [$endColor.variable]: endColorVar }
  };
  if (isLoaded) {
    const animation = isFirstRender || wasPreviouslyLoaded ? "none" : `${fade} ${fadeDuration}s`;
    return /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ref,
        className: _className,
        __css: { animation },
        ...rest
      }
    );
  }
  return /* @__PURE__ */ jsx$1(
    StyledSkeleton,
    {
      ref,
      className: _className,
      ...rest,
      __css: {
        width: fitContent ? "fit-content" : void 0,
        ...styles2,
        ...cssVarStyles,
        _dark: { ...styles2["_dark"], ...cssVarStyles },
        animation: animationProp || `${speed}s linear infinite alternate ${bgFade}`
      }
    }
  );
});
Skeleton.displayName = "Skeleton";
const Spacer = chakra("div", {
  baseStyle: {
    flex: 1,
    justifySelf: "stretch",
    alignSelf: "stretch"
  }
});
Spacer.displayName = "Spacer";
const StackItem = (props) => /* @__PURE__ */ jsx$1(
  chakra.div,
  {
    className: "chakra-stack__item",
    ...props,
    __css: {
      display: "inline-block",
      flex: "0 0 auto",
      minWidth: 0,
      ...props["__css"]
    }
  }
);
StackItem.displayName = "StackItem";
function getDividerStyles(options) {
  const { spacing, direction } = options;
  const dividerStyles = {
    column: {
      my: spacing,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    "column-reverse": {
      my: spacing,
      mx: 0,
      borderLeftWidth: 0,
      borderBottomWidth: "1px"
    },
    row: {
      mx: spacing,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    },
    "row-reverse": {
      mx: spacing,
      my: 0,
      borderLeftWidth: "1px",
      borderBottomWidth: 0
    }
  };
  return {
    "&": mapResponsive(
      direction,
      (value) => dividerStyles[value]
    )
  };
}
const Stack = forwardRef((props, ref) => {
  const {
    isInline,
    direction: directionProp,
    align,
    justify,
    spacing = "0.5rem",
    wrap: wrap2,
    children,
    divider,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const direction = isInline ? "row" : directionProp ?? "column";
  const dividerStyle = useMemo(
    () => getDividerStyles({ spacing, direction }),
    [spacing, direction]
  );
  const hasDivider = !!divider;
  const shouldUseChildren = !shouldWrapChildren && !hasDivider;
  const clones = useMemo(() => {
    const validChildren = getValidChildren(children);
    return shouldUseChildren ? validChildren : validChildren.map((child, index) => {
      const key = typeof child.key !== "undefined" ? child.key : index;
      const isLast = index + 1 === validChildren.length;
      const wrappedChild = /* @__PURE__ */ jsx$1(StackItem, { children: child }, key);
      const _child = shouldWrapChildren ? wrappedChild : child;
      if (!hasDivider)
        return _child;
      const clonedDivider = cloneElement(
        divider,
        {
          __css: dividerStyle
        }
      );
      const _divider = isLast ? null : clonedDivider;
      return /* @__PURE__ */ jsxs(Fragment$1, { children: [
        _child,
        _divider
      ] }, key);
    });
  }, [
    divider,
    dividerStyle,
    hasDivider,
    shouldUseChildren,
    shouldWrapChildren,
    children
  ]);
  const _className = cx("chakra-stack", className);
  return /* @__PURE__ */ jsx$1(
    chakra.div,
    {
      ref,
      display: "flex",
      alignItems: align,
      justifyContent: justify,
      flexDirection: direction,
      flexWrap: wrap2,
      gap: hasDivider ? void 0 : spacing,
      className: _className,
      ...rest,
      children: clones
    }
  );
});
Stack.displayName = "Stack";
const Switch = forwardRef(
  function Switch2(props, ref) {
    const styles2 = useMultiStyleConfig("Switch", props);
    const {
      spacing = "0.5rem",
      children,
      ...ownProps
    } = omitThemingProps(props);
    const {
      getIndicatorProps,
      getInputProps,
      getCheckboxProps,
      getRootProps,
      getLabelProps
    } = useCheckbox(ownProps);
    const containerStyles = useMemo(
      () => ({
        display: "inline-block",
        position: "relative",
        verticalAlign: "middle",
        lineHeight: 0,
        ...styles2.container
      }),
      [styles2.container]
    );
    const trackStyles = useMemo(
      () => ({
        display: "inline-flex",
        flexShrink: 0,
        justifyContent: "flex-start",
        boxSizing: "content-box",
        cursor: "pointer",
        ...styles2.track
      }),
      [styles2.track]
    );
    const labelStyles = useMemo(
      () => ({
        userSelect: "none",
        marginStart: spacing,
        ...styles2.label
      }),
      [spacing, styles2.label]
    );
    return /* @__PURE__ */ jsxs(
      chakra.label,
      {
        ...getRootProps(),
        className: cx("chakra-switch", props.className),
        __css: containerStyles,
        children: [
          /* @__PURE__ */ jsx$1("input", { className: "chakra-switch__input", ...getInputProps({}, ref) }),
          /* @__PURE__ */ jsx$1(
            chakra.span,
            {
              ...getCheckboxProps(),
              className: "chakra-switch__track",
              __css: trackStyles,
              children: /* @__PURE__ */ jsx$1(
                chakra.span,
                {
                  __css: styles2.thumb,
                  className: "chakra-switch__thumb",
                  ...getIndicatorProps()
                }
              )
            }
          ),
          children && /* @__PURE__ */ jsx$1(
            chakra.span,
            {
              className: "chakra-switch__label",
              ...getLabelProps(),
              __css: labelStyles,
              children
            }
          )
        ]
      }
    );
  }
);
Switch.displayName = "Switch";
const [TagStylesProvider, useTagStyles] = createContext$1({
  name: `TagStylesContext`,
  errorMessage: `useTagStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Tag />" `
});
const Tag = forwardRef((props, ref) => {
  const styles2 = useMultiStyleConfig("Tag", props);
  const ownProps = omitThemingProps(props);
  const containerStyles = {
    display: "inline-flex",
    verticalAlign: "top",
    alignItems: "center",
    maxWidth: "100%",
    ...styles2.container
  };
  return /* @__PURE__ */ jsx$1(TagStylesProvider, { value: styles2, children: /* @__PURE__ */ jsx$1(chakra.span, { ref, ...ownProps, __css: containerStyles }) });
});
Tag.displayName = "Tag";
const TagLabel = forwardRef((props, ref) => {
  const styles2 = useTagStyles();
  return /* @__PURE__ */ jsx$1(chakra.span, { ref, noOfLines: 1, ...props, __css: styles2.label });
});
TagLabel.displayName = "TagLabel";
const TagLeftIcon = forwardRef((props, ref) => /* @__PURE__ */ jsx$1(Icon, { ref, verticalAlign: "top", marginEnd: "0.5rem", ...props }));
TagLeftIcon.displayName = "TagLeftIcon";
const TagRightIcon = forwardRef((props, ref) => /* @__PURE__ */ jsx$1(Icon, { ref, verticalAlign: "top", marginStart: "0.5rem", ...props }));
TagRightIcon.displayName = "TagRightIcon";
const TagCloseIcon = (props) => /* @__PURE__ */ jsx$1(Icon, { verticalAlign: "inherit", viewBox: "0 0 512 512", ...props, children: /* @__PURE__ */ jsx$1(
  "path",
  {
    fill: "currentColor",
    d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z"
  }
) });
TagCloseIcon.displayName = "TagCloseIcon";
const TagCloseButton = forwardRef(
  (props, ref) => {
    const { isDisabled, children, ...rest } = props;
    const styles2 = useTagStyles();
    const btnStyles = {
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      outline: "0",
      ...styles2.closeButton
    };
    return /* @__PURE__ */ jsx$1(
      chakra.button,
      {
        ref,
        "aria-label": "close",
        ...rest,
        type: "button",
        disabled: isDisabled,
        __css: btnStyles,
        children: children || /* @__PURE__ */ jsx$1(TagCloseIcon, {})
      }
    );
  }
);
TagCloseButton.displayName = "TagCloseButton";
const omitted = ["h", "minH", "height", "minHeight"];
const Textarea = forwardRef((props, ref) => {
  const styles2 = useStyleConfig("Textarea", props);
  const { className, rows, ...rest } = omitThemingProps(props);
  const textareaProps = useFormControl(rest);
  const textareaStyles = rows ? omit(styles2, omitted) : styles2;
  return /* @__PURE__ */ jsx$1(
    chakra.textarea,
    {
      ref,
      rows,
      ...textareaProps,
      className: cx("chakra-textarea", className),
      __css: textareaStyles
    }
  );
});
Textarea.displayName = "Textarea";
function getToastPlacement(position2, dir) {
  const computedPosition = position2 ?? "bottom";
  const logicals2 = {
    "top-start": { ltr: "top-left", rtl: "top-right" },
    "top-end": { ltr: "top-right", rtl: "top-left" },
    "bottom-start": { ltr: "bottom-left", rtl: "bottom-right" },
    "bottom-end": { ltr: "bottom-right", rtl: "bottom-left" }
  };
  const logical2 = logicals2[computedPosition];
  return (logical2 == null ? void 0 : logical2[dir]) ?? computedPosition;
}
function createToastFn(dir, defaultOptions2) {
  const normalizeToastOptions = (options) => ({
    ...defaultOptions2,
    ...options,
    position: getToastPlacement(
      (options == null ? void 0 : options.position) ?? (defaultOptions2 == null ? void 0 : defaultOptions2.position),
      dir
    )
  });
  const toast = (options) => {
    const normalizedToastOptions = normalizeToastOptions(options);
    const Message = createRenderToast(normalizedToastOptions);
    return toastStore.notify(Message, normalizedToastOptions);
  };
  toast.update = (id2, options) => {
    toastStore.update(id2, normalizeToastOptions(options));
  };
  toast.promise = (promise, options) => {
    const id2 = toast({
      ...options.loading,
      status: "loading",
      duration: null
    });
    promise.then(
      (data) => toast.update(id2, {
        status: "success",
        duration: 5e3,
        ...runIfFn(options.success, data)
      })
    ).catch(
      (error) => toast.update(id2, {
        status: "error",
        duration: 5e3,
        ...runIfFn(options.error, error)
      })
    );
  };
  toast.closeAll = toastStore.closeAll;
  toast.close = toastStore.close;
  toast.isActive = toastStore.isActive;
  return toast;
}
function useToast(options) {
  const { theme: theme2 } = useChakra();
  const defaultOptions2 = useToastOptionContext();
  return useMemo(
    () => createToastFn(theme2.direction, {
      ...defaultOptions2,
      ...options
    }),
    [options, theme2.direction, defaultOptions2]
  );
}
const scale = {
  exit: {
    scale: 0.85,
    opacity: 0,
    transition: {
      opacity: { duration: 0.15, easings: "easeInOut" },
      scale: { duration: 0.2, easings: "easeInOut" }
    }
  },
  enter: {
    scale: 1,
    opacity: 1,
    transition: {
      opacity: { easings: "easeOut", duration: 0.2 },
      scale: { duration: 0.2, ease: [0.175, 0.885, 0.4, 1.1] }
    }
  }
};
const getDoc = (ref) => {
  var _a;
  return ((_a = ref.current) == null ? void 0 : _a.ownerDocument) || document;
};
const getWin = (ref) => {
  var _a, _b;
  return ((_b = (_a = ref.current) == null ? void 0 : _a.ownerDocument) == null ? void 0 : _b.defaultView) || window;
};
function useTooltip(props = {}) {
  const {
    openDelay = 0,
    closeDelay = 0,
    closeOnClick = true,
    closeOnMouseDown,
    closeOnScroll,
    closeOnPointerDown = closeOnMouseDown,
    closeOnEsc = true,
    onOpen: onOpenProp,
    onClose: onCloseProp,
    placement,
    id: id2,
    isOpen: isOpenProp,
    defaultIsOpen,
    arrowSize = 10,
    arrowShadowColor,
    arrowPadding,
    modifiers,
    isDisabled,
    gutter,
    offset,
    direction,
    ...htmlProps
  } = props;
  const { isOpen, onOpen, onClose } = useDisclosure({
    isOpen: isOpenProp,
    defaultIsOpen,
    onOpen: onOpenProp,
    onClose: onCloseProp
  });
  const { referenceRef, getPopperProps, getArrowInnerProps, getArrowProps } = usePopper({
    enabled: isOpen,
    placement,
    arrowPadding,
    modifiers,
    gutter,
    offset,
    direction
  });
  const uuid = useId$1();
  const uid = id2 ?? uuid;
  const tooltipId = `tooltip-${uid}`;
  const ref = useRef(null);
  const enterTimeout = useRef();
  const clearEnterTimeout = useCallback(() => {
    if (enterTimeout.current) {
      clearTimeout(enterTimeout.current);
      enterTimeout.current = void 0;
    }
  }, []);
  const exitTimeout = useRef();
  const clearExitTimeout = useCallback(() => {
    if (exitTimeout.current) {
      clearTimeout(exitTimeout.current);
      exitTimeout.current = void 0;
    }
  }, []);
  const closeNow = useCallback(() => {
    clearExitTimeout();
    onClose();
  }, [onClose, clearExitTimeout]);
  const dispatchCloseEvent = useCloseEvent(ref, closeNow);
  const openWithDelay = useCallback(() => {
    if (!isDisabled && !enterTimeout.current) {
      if (isOpen)
        dispatchCloseEvent();
      const win = getWin(ref);
      enterTimeout.current = win.setTimeout(onOpen, openDelay);
    }
  }, [dispatchCloseEvent, isDisabled, isOpen, onOpen, openDelay]);
  const closeWithDelay = useCallback(() => {
    clearEnterTimeout();
    const win = getWin(ref);
    exitTimeout.current = win.setTimeout(closeNow, closeDelay);
  }, [closeDelay, closeNow, clearEnterTimeout]);
  const onClick = useCallback(() => {
    if (isOpen && closeOnClick) {
      closeWithDelay();
    }
  }, [closeOnClick, closeWithDelay, isOpen]);
  const onPointerDown = useCallback(() => {
    if (isOpen && closeOnPointerDown) {
      closeWithDelay();
    }
  }, [closeOnPointerDown, closeWithDelay, isOpen]);
  const onKeyDown = useCallback(
    (event) => {
      if (isOpen && event.key === "Escape") {
        closeWithDelay();
      }
    },
    [isOpen, closeWithDelay]
  );
  useEventListener(
    () => getDoc(ref),
    "keydown",
    closeOnEsc ? onKeyDown : void 0
  );
  useEventListener(
    () => {
      if (!closeOnScroll)
        return null;
      const node = ref.current;
      if (!node)
        return null;
      const scrollParent = getScrollParent(node);
      return scrollParent.localName === "body" ? getWin(ref) : scrollParent;
    },
    "scroll",
    () => {
      if (isOpen && closeOnScroll) {
        closeNow();
      }
    },
    { passive: true, capture: true }
  );
  useEffect(() => {
    if (!isDisabled)
      return;
    clearEnterTimeout();
    if (isOpen)
      onClose();
  }, [isDisabled, isOpen, onClose, clearEnterTimeout]);
  useEffect(() => {
    return () => {
      clearEnterTimeout();
      clearExitTimeout();
    };
  }, [clearEnterTimeout, clearExitTimeout]);
  useEventListener(() => ref.current, "pointerleave", closeWithDelay);
  const getTriggerProps = useCallback(
    (props2 = {}, _ref = null) => {
      const triggerProps = {
        ...props2,
        ref: mergeRefs(ref, _ref, referenceRef),
        onPointerEnter: callAllHandlers(props2.onPointerEnter, (e) => {
          if (e.pointerType === "touch")
            return;
          openWithDelay();
        }),
        onClick: callAllHandlers(props2.onClick, onClick),
        onPointerDown: callAllHandlers(props2.onPointerDown, onPointerDown),
        onFocus: callAllHandlers(props2.onFocus, openWithDelay),
        onBlur: callAllHandlers(props2.onBlur, closeWithDelay),
        "aria-describedby": isOpen ? tooltipId : void 0
      };
      return triggerProps;
    },
    [
      openWithDelay,
      closeWithDelay,
      onPointerDown,
      isOpen,
      tooltipId,
      onClick,
      referenceRef
    ]
  );
  const getTooltipPositionerProps = useCallback(
    (props2 = {}, forwardedRef = null) => getPopperProps(
      {
        ...props2,
        style: {
          ...props2.style,
          [cssVars.arrowSize.var]: arrowSize ? `${arrowSize}px` : void 0,
          [cssVars.arrowShadowColor.var]: arrowShadowColor
        }
      },
      forwardedRef
    ),
    [getPopperProps, arrowSize, arrowShadowColor]
  );
  const getTooltipProps = useCallback(
    (props2 = {}, ref2 = null) => {
      const styles2 = {
        ...props2.style,
        position: "relative",
        transformOrigin: cssVars.transformOrigin.varRef
      };
      return {
        ref: ref2,
        ...htmlProps,
        ...props2,
        id: tooltipId,
        role: "tooltip",
        style: styles2
      };
    },
    [htmlProps, tooltipId]
  );
  return {
    isOpen,
    show: openWithDelay,
    hide: closeWithDelay,
    getTriggerProps,
    getTooltipProps,
    getTooltipPositionerProps,
    getArrowProps,
    getArrowInnerProps
  };
}
const closeEventName = "chakra-ui:close-tooltip";
function useCloseEvent(ref, close) {
  useEffect(() => {
    const doc = getDoc(ref);
    doc.addEventListener(closeEventName, close);
    return () => doc.removeEventListener(closeEventName, close);
  }, [close, ref]);
  return () => {
    const doc = getDoc(ref);
    const win = getWin(ref);
    doc.dispatchEvent(new win.CustomEvent(closeEventName));
  };
}
const MotionDiv = chakra(motion.div);
const Tooltip = forwardRef((props, ref) => {
  const styles2 = useStyleConfig("Tooltip", props);
  const ownProps = omitThemingProps(props);
  const theme2 = useTheme();
  const {
    children,
    label,
    shouldWrapChildren,
    "aria-label": ariaLabel,
    hasArrow,
    bg,
    portalProps,
    background: background2,
    backgroundColor,
    bgColor,
    motionProps,
    animatePresenceProps,
    ...rest
  } = ownProps;
  const userDefinedBg = background2 ?? backgroundColor ?? bg ?? bgColor;
  if (userDefinedBg) {
    styles2.bg = userDefinedBg;
    const bgVar = getCSSVar(theme2, "colors", userDefinedBg);
    styles2[cssVars.arrowBg.var] = bgVar;
  }
  const tooltip = useTooltip({ ...rest, direction: theme2.direction });
  const shouldWrap = !isValidElement$1(children) || shouldWrapChildren;
  let trigger;
  if (shouldWrap) {
    trigger = /* @__PURE__ */ jsx$1(
      chakra.span,
      {
        display: "inline-block",
        tabIndex: 0,
        ...tooltip.getTriggerProps(),
        children
      }
    );
  } else {
    const child = Children.only(children);
    trigger = cloneElement(
      child,
      tooltip.getTriggerProps(child.props, child.ref)
    );
  }
  const hasAriaLabel = !!ariaLabel;
  const _tooltipProps = tooltip.getTooltipProps({}, ref);
  const tooltipProps = hasAriaLabel ? omit(_tooltipProps, ["role", "id"]) : _tooltipProps;
  const srOnlyProps = pick(_tooltipProps, ["role", "id"]);
  if (!label) {
    return /* @__PURE__ */ jsx$1(Fragment, { children });
  }
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    trigger,
    /* @__PURE__ */ jsx$1(AnimatePresence, { ...animatePresenceProps, children: tooltip.isOpen && /* @__PURE__ */ jsx$1(Portal, { ...portalProps, children: /* @__PURE__ */ jsx$1(
      chakra.div,
      {
        ...tooltip.getTooltipPositionerProps(),
        __css: {
          zIndex: styles2.zIndex,
          pointerEvents: "none"
        },
        children: /* @__PURE__ */ jsxs(
          MotionDiv,
          {
            variants: scale,
            initial: "exit",
            animate: "enter",
            exit: "exit",
            ...motionProps,
            ...tooltipProps,
            __css: styles2,
            children: [
              label,
              hasAriaLabel && /* @__PURE__ */ jsx$1(chakra.span, { srOnly: true, ...srOnlyProps, children: ariaLabel }),
              hasArrow && /* @__PURE__ */ jsx$1(
                chakra.div,
                {
                  "data-popper-arrow": true,
                  className: "chakra-tooltip__arrow-wrapper",
                  children: /* @__PURE__ */ jsx$1(
                    chakra.div,
                    {
                      "data-popper-arrow-inner": true,
                      className: "chakra-tooltip__arrow",
                      __css: { bg: styles2.bg }
                    }
                  )
                }
              )
            ]
          }
        )
      }
    ) }) })
  ] });
});
Tooltip.displayName = "Tooltip";
const Heading = forwardRef(
  function Heading2(props, ref) {
    const styles2 = useStyleConfig("Heading", props);
    const { className, ...rest } = omitThemingProps(props);
    return /* @__PURE__ */ jsx$1(
      chakra.h2,
      {
        ref,
        className: cx("chakra-heading", props.className),
        ...rest,
        __css: styles2
      }
    );
  }
);
Heading.displayName = "Heading";
const Text = forwardRef(function Text2(props, ref) {
  const styles2 = useStyleConfig("Text", props);
  const { className, align, decoration, casing, ...rest } = omitThemingProps(props);
  const aliasedProps = compact$1({
    textAlign: props.align,
    textDecoration: props.decoration,
    textTransform: props.casing
  });
  return /* @__PURE__ */ jsx$1(
    chakra.p,
    {
      ref,
      className: cx("chakra-text", props.className),
      ...aliasedProps,
      ...rest,
      __css: styles2
    }
  );
});
Text.displayName = "Text";
const VisuallyHidden = chakra("span", {
  baseStyle: visuallyHiddenStyle
});
VisuallyHidden.displayName = "VisuallyHidden";
const VisuallyHiddenInput = chakra("input", {
  baseStyle: visuallyHiddenStyle
});
VisuallyHiddenInput.displayName = "VisuallyHiddenInput";
const Wrap = forwardRef(function Wrap2(props, ref) {
  const {
    spacing = "0.5rem",
    spacingX,
    spacingY,
    children,
    justify,
    direction,
    align,
    className,
    shouldWrapChildren,
    ...rest
  } = props;
  const _children = useMemo(
    () => shouldWrapChildren ? Children.map(children, (child, index) => /* @__PURE__ */ jsx$1(WrapItem, { children: child }, index)) : children,
    [children, shouldWrapChildren]
  );
  return /* @__PURE__ */ jsx$1(chakra.div, { ref, className: cx("chakra-wrap", className), ...rest, children: /* @__PURE__ */ jsx$1(
    chakra.ul,
    {
      className: "chakra-wrap__list",
      __css: {
        display: "flex",
        flexWrap: "wrap",
        justifyContent: justify,
        alignItems: align,
        flexDirection: direction,
        listStyleType: "none",
        gap: spacing,
        columnGap: spacingX,
        rowGap: spacingY,
        padding: "0"
      },
      children: _children
    }
  ) });
});
Wrap.displayName = "Wrap";
const WrapItem = forwardRef(
  function WrapItem2(props, ref) {
    const { className, ...rest } = props;
    return /* @__PURE__ */ jsx$1(
      chakra.li,
      {
        ref,
        __css: { display: "flex", alignItems: "flex-start" },
        className: cx("chakra-wrap__listitem", className),
        ...rest
      }
    );
  }
);
WrapItem.displayName = "WrapItem";
function makeQueryInfoTrie() {
  return new Trie(false, function() {
    return {
      seen: false,
      observable: null
    };
  });
}
var RenderPromises = (
  /** @class */
  function() {
    function RenderPromises2() {
      this.queryPromises = /* @__PURE__ */ new Map();
      this.queryInfoTrie = makeQueryInfoTrie();
      this.stopped = false;
    }
    RenderPromises2.prototype.stop = function() {
      if (!this.stopped) {
        this.queryPromises.clear();
        this.queryInfoTrie = makeQueryInfoTrie();
        this.stopped = true;
      }
    };
    RenderPromises2.prototype.registerSSRObservable = function(observable) {
      if (this.stopped)
        return;
      this.lookupQueryInfo(observable.options).observable = observable;
    };
    RenderPromises2.prototype.getSSRObservable = function(props) {
      return this.lookupQueryInfo(props).observable;
    };
    RenderPromises2.prototype.addQueryPromise = function(queryInstance, finish) {
      if (!this.stopped) {
        var info = this.lookupQueryInfo(queryInstance.getOptions());
        if (!info.seen) {
          this.queryPromises.set(queryInstance.getOptions(), new Promise(function(resolve) {
            resolve(queryInstance.fetchData());
          }));
          return null;
        }
      }
      return finish ? finish() : null;
    };
    RenderPromises2.prototype.addObservableQueryPromise = function(obsQuery) {
      return this.addQueryPromise({
        // The only options which seem to actually be used by the
        // RenderPromises class are query and variables.
        getOptions: function() {
          return obsQuery.options;
        },
        fetchData: function() {
          return new Promise(function(resolve) {
            var sub = obsQuery.subscribe({
              next: function(result) {
                if (!result.loading) {
                  resolve();
                  sub.unsubscribe();
                }
              },
              error: function() {
                resolve();
                sub.unsubscribe();
              },
              complete: function() {
                resolve();
              }
            });
          });
        }
      });
    };
    RenderPromises2.prototype.hasPromises = function() {
      return this.queryPromises.size > 0;
    };
    RenderPromises2.prototype.consumeAndAwaitPromises = function() {
      var _this = this;
      var promises = [];
      this.queryPromises.forEach(function(promise, queryInstance) {
        _this.lookupQueryInfo(queryInstance).seen = true;
        promises.push(promise);
      });
      this.queryPromises.clear();
      return Promise.all(promises);
    };
    RenderPromises2.prototype.lookupQueryInfo = function(props) {
      return this.queryInfoTrie.lookup(props.query, canonicalStringify(props.variables));
    };
    return RenderPromises2;
  }()
);
function getDataFromTree(tree, context) {
  if (context === void 0) {
    context = {};
  }
  return getMarkupFromTree({
    tree,
    context,
    // If you need to configure this renderFunction, call getMarkupFromTree
    // directly instead of getDataFromTree.
    renderFunction: renderToStaticMarkup
  });
}
function getMarkupFromTree(_a) {
  var tree = _a.tree, _b = _a.context, context = _b === void 0 ? {} : _b, _c = _a.renderFunction, renderFunction = _c === void 0 ? renderToStaticMarkup : _c;
  var renderPromises = new RenderPromises();
  function process() {
    var ApolloContext = getApolloContext();
    return new Promise(function(resolve) {
      var element = React.createElement(ApolloContext.Provider, { value: __assign(__assign({}, context), { renderPromises }) }, tree);
      resolve(renderFunction(element));
    }).then(function(html) {
      return renderPromises.hasPromises() ? renderPromises.consumeAndAwaitPromises().then(process) : html;
    }).finally(function() {
      renderPromises.stop();
    });
  }
  return Promise.resolve().then(process);
}
const styles = {
  global: {
    html: { fontSize: "18px" },
    textarea: { underline: "none !important" },
    p: {
      marginTop: "0.5em",
      marginBottom: "0.5em"
    },
    ul: {
      listStylePosition: "inside"
    },
    // WordPress Block Editor content
    ".has-medium-font-size": {
      fontSize: "1rem"
    },
    ".has-large-font-size": {
      fontSize: "1.125rem"
    },
    ".has-x-large-font-size": {
      fontSize: "1.25rem"
    },
    ".has-2-x-large-font-size": {
      fontSize: "1.5rem"
    },
    ".has-3-x-large-font-size": {
      fontSize: "1.875rem"
    },
    ".has-4-x-large-font-size": {
      fontSize: "2.25rem"
    },
    ".has-5-x-large-font-size": {
      fontSize: "3rem"
    },
    ".wp-post-content": {
      a: {
        "&:not(.wp-block-button__link), &:not(.wp-element-button)": {
          textDecoration: "underline",
          color: "brand.blue"
        }
      },
      p: {
        marginTop: "1em",
        marginBottom: "1em",
        paddingBottom: "1em",
        "&:first-of-type": {
          marginTop: 0
        },
        "&:last-of-type": {
          marginBottom: 0
        }
      },
      ".wp-block-group": {
        "*": {
          flex: 1
        }
      }
    }
  }
};
const radioCheckboxButtonStyleObject = {
  container: {
    borderRadius: "md",
    borderWidth: 0,
    transitionDuration: "normal",
    px: 3,
    py: 2,
    m: 0,
    _dark: {
      bg: "gray.800",
      _checked: {
        bg: "gray.300"
      },
      _hover: {
        bg: "gray.600"
      }
    },
    _light: {
      bg: "gray.100",
      _checked: {
        bg: "gray.600"
      },
      _hover: {
        bg: "gray.200"
      }
    }
  },
  label: {
    letterSpacing: "0.06em",
    _dark: {
      _checked: {
        color: "gray.900"
      }
    },
    _light: {
      _checked: {
        color: "gray.100"
      }
    }
  },
  control: {
    borderColor: "gray.300",
    _checked: {
      bgColor: "brand.blue",
      color: "brand.blue",
      borderColor: "brand.blue"
    }
  }
};
const colors = {
  text: {
    light: "#fff",
    dark: "#000"
  },
  bg: {
    light: "#F7FAFC",
    dark: "#171923"
  },
  brand: {
    yellow: "#C9DB58",
    green: "#274F42",
    red: "#962F34",
    orange: "#F15A29",
    blue: "#00AEEF"
  },
  yellow: {
    50: "#f8fbe1",
    100: "#ebf1bc",
    200: "#dde895",
    300: "#d0df6c",
    400: "#c2d644",
    500: "#a8bd2b",
    600: "#839320",
    700: "#5e6915",
    800: "#373f09",
    900: "#131600"
  },
  green: {
    50: "#e5f9f3",
    100: "#c9e7dd",
    200: "#aad5c7",
    300: "#89c4b0",
    400: "#69b29a",
    500: "#509981",
    600: "#3d7864",
    700: "#2a5547",
    800: "#16332b",
    900: "#00130c"
  },
  red: {
    50: "#ffe9e9",
    100: "#f1c4c6",
    200: "#e29da1",
    300: "#d4777c",
    400: "#c75156",
    500: "#ae383d",
    600: "#882b2f",
    700: "#621d22",
    800: "#3c1013",
    900: "#1b0204"
  },
  orange: {
    50: "#ffeadf",
    100: "#ffc6b3",
    200: "#f9a285",
    300: "#f57d56",
    400: "#f15928",
    500: "#d73f0e",
    600: "#a9300a",
    700: "#792206",
    800: "#4b1201",
    900: "#1f0300"
  },
  blue: {
    50: "#d8fbff",
    100: "#abebff",
    200: "#7addff",
    300: "#48ceff",
    400: "#1ac1ff",
    500: "#00a7e6",
    600: "#0082b4",
    700: "#005d82",
    800: "#003951",
    900: "#001520"
  }
};
const fonts = {
  body: `'Victor Serif', serif`,
  heading: `'Victor Serif', serif`
};
const { definePartsStyle: definePartsStyle$8, defineMultiStyleConfig: defineMultiStyleConfig$8 } = createMultiStyleConfigHelpers(accordionAnatomy.keys);
const baseStyle$d = definePartsStyle$8({
  button: {
    fontWeight: "bold",
    fontSize: "xl"
  }
});
var accordionTheme = defineMultiStyleConfig$8({ baseStyle: baseStyle$d });
const { definePartsStyle: definePartsStyle$7, defineMultiStyleConfig: defineMultiStyleConfig$7 } = createMultiStyleConfigHelpers(
  alertAnatomy.keys
);
const baseStyle$c = definePartsStyle$7({
  container: {
    borderRadius: "md",
    fontSize: "sm",
    my: 4
  }
});
var alertTheme = defineMultiStyleConfig$7({ baseStyle: baseStyle$c });
const { definePartsStyle: definePartsStyle$6, defineMultiStyleConfig: defineMultiStyleConfig$6 } = createMultiStyleConfigHelpers(
  avatarAnatomy.keys
);
const superLg = defineStyle({
  width: 40,
  height: 40,
  fontSize: "3xl"
});
const sizes$2 = {
  superLg: definePartsStyle$6({ container: superLg })
};
var avatarTheme = defineMultiStyleConfig$6({ sizes: sizes$2 });
const baseStyle$b = defineStyle({
  borderRadius: "md"
});
var badgeTheme = defineStyleConfig({
  baseStyle: baseStyle$b
});
const baseStyle$a = defineStyle({
  fontWeight: "medium",
  borderRadius: "md",
  textDecoration: "none",
  _hover: {
    textDecoration: "none"
  }
});
const variants$8 = {
  invisible: defineStyle({
    border: "none",
    background: "transparent",
    _hover: {
      background: "transparent"
    },
    _active: {
      background: "transparent"
    }
  }),
  sampleIconButton: defineStyle({
    cursor: "default !important",
    alignItems: "center",
    borderRadius: "full",
    pointerEvents: "none",
    opacity: "1 !important"
  }),
  searchFilter: defineStyle({
    _dark: {
      bg: "gray.800",
      _checked: {
        bg: "gray.300"
      },
      _hover: {
        bg: "gray.600"
      }
    },
    _light: {
      bg: "gray.100",
      _checked: {
        bg: "gray.600"
      },
      _hover: {
        bg: "gray.50"
      }
    }
  })
};
const sizes$1 = {
  xl: defineStyle({
    fontSize: "xl",
    p: 4
  }),
  xxl: defineStyle({
    fontSize: "2xl",
    p: 4
  }),
  xxxl: defineStyle({
    fontSize: "3xl",
    p: 4
  })
};
var buttonTheme = defineStyleConfig({
  baseStyle: baseStyle$a,
  variants: variants$8,
  sizes: sizes$1
});
const { definePartsStyle: definePartsStyle$5, defineMultiStyleConfig: defineMultiStyleConfig$5 } = createMultiStyleConfigHelpers(
  cardAnatomy.keys
);
const baseStyle$9 = definePartsStyle$5({
  container: {
    gap: 4,
    my: 4,
    p: 4
  },
  header: {
    mb: 0,
    py: 0,
    fontSize: "2xl",
    fontWeight: "bold"
  }
});
const variants$7 = {
  gray: definePartsStyle$5({
    container: {
      _dark: {
        bgColor: "gray.800",
        borderColor: "gray.700"
      },
      _light: {
        bgColor: "gray.100",
        borderColor: "gray.200"
      }
    }
  }),
  important: definePartsStyle$5({
    container: {
      bgColor: "brand.red"
    }
  }),
  listItem: definePartsStyle$5({
    container: {
      px: 2,
      py: 3,
      my: 0,
      mr: 4,
      _dark: {
        _hover: {
          bg: "gray.700"
        }
      },
      _light: {
        _hover: {
          bg: "gray.200"
        }
      }
    }
  })
};
var cardTheme = defineMultiStyleConfig$5({ baseStyle: baseStyle$9, variants: variants$7 });
const { definePartsStyle: definePartsStyle$4, defineMultiStyleConfig: defineMultiStyleConfig$4 } = createMultiStyleConfigHelpers(
  checkboxAnatomy.keys
);
const buttonStyle$1 = definePartsStyle$4({
  ...radioCheckboxButtonStyleObject
});
var checkboxTheme = defineMultiStyleConfig$4({
  variants: { buttonStyle: buttonStyle$1 }
});
const baseStyle$8 = defineStyle({
  my: 4,
  _light: {
    borderColor: "text.dark"
  },
  _dark: {
    borderColor: "text.light"
  }
});
var dividerTheme = defineStyleConfig({
  baseStyle: baseStyle$8
});
const { definePartsStyle: definePartsStyle$3, defineMultiStyleConfig: defineMultiStyleConfig$3 } = createMultiStyleConfigHelpers(
  editableAnatomy.keys
);
const baseStyle$7 = definePartsStyle$3({
  preview: {
    borderTopStyle: "solid",
    borderTopWidth: "1px",
    borderTopColor: "gray.200",
    borderBottomWidth: "3px",
    borderBottomColor: "gray.400",
    borderBottomStyle: "dashed",
    color: "text.dark",
    bg: "whiteAlpha.600",
    px: 2,
    _hover: {
      borderBottomColor: "text.dark"
    }
  },
  input: {
    borderTopStyle: "solid",
    borderTopWidth: "1px",
    borderTopColor: "gray.200",
    borderBottomWidth: "3px",
    borderBottomColor: "gray.400",
    borderBottomStyle: "solid",
    bg: "whiteAlpha.700",
    px: 2,
    _focus: {
      boxShadow: "none"
    }
  },
  textarea: {
    borderWidth: "3px",
    borderColor: "gray.400",
    borderStyle: "solid",
    bg: "whiteAlpha.700",
    _focus: {
      boxShadow: "none"
    }
  }
});
var editableTheme = defineMultiStyleConfig$3({ baseStyle: baseStyle$7 });
const baseStyle$6 = defineStyle({
  mb: 2,
  fontWeight: "normal"
});
const variants$6 = {
  pageTitle: defineStyle({
    fontSize: "4xl"
  }),
  pageSubtitle: defineStyle({
    fontSize: "3xl",
    fontWeight: "bold"
  }),
  contentTitle: defineStyle({
    fontSize: "2xl",
    fontWeight: "bold",
    pb: 0
  }),
  contentSubtitle: defineStyle({
    fontSize: "lg",
    fontWeight: "bold",
    mt: 0,
    pb: 0
  }),
  centerline: defineStyle({
    size: "lg",
    _light: {
      bg: "bg.light"
    },
    _dark: {
      bg: "bg.dark",
      color: "text.light"
    },
    display: "inline",
    lineHeight: "none",
    zIndex: "2",
    pr: 2
  }),
  searchFilterTitle: defineStyle({
    fontSize: "3xl",
    mb: 6,
    w: "full",
    borderBottom: "2px",
    borderColor: "gray.600"
  })
};
var headingTheme = defineStyleConfig({
  baseStyle: baseStyle$6,
  variants: variants$6
});
const { definePartsStyle: definePartsStyle$2, defineMultiStyleConfig: defineMultiStyleConfig$2 } = createMultiStyleConfigHelpers(
  inputAnatomy.keys
);
const baseStyle$5 = definePartsStyle$2({
  field: {
    borderRadius: "md",
    _placeholder: {
      color: "gray.500"
    }
  }
});
const xl = defineStyle({
  fontSize: "3xl",
  fontWeight: "medium",
  px: 2,
  py: 2
});
const variants$5 = {
  filled: definePartsStyle$2({
    field: {
      color: "text.dark",
      bg: "gray.100",
      _hover: {
        bg: "gray.200"
      },
      _focus: {
        bg: "gray.200"
      },
      _active: {
        bg: "gray.200"
      }
    }
  }),
  file: definePartsStyle$2({
    field: {
      display: "none",
      border: "none",
      px: 0
    }
  }),
  flushed: definePartsStyle$2({
    field: {
      borderRadius: 0,
      borderTop: "none",
      borderLeft: "none",
      borderRight: "none",
      borderBottomWidth: "2px",
      _light: {
        color: "text.dark"
      },
      _dark: {
        color: "text.light"
      }
    }
  })
};
const sizes = {
  xl: definePartsStyle$2({ field: xl, addon: xl })
};
var inputTheme = defineMultiStyleConfig$2({ baseStyle: baseStyle$5, sizes, variants: variants$5 });
const baseStyle$4 = defineStyle({
  my: 2,
  color: "brand.blue",
  textDecoration: "underline",
  transition: "all 100ms ease-out",
  textDecorationColor: "transparent",
  _focus: {
    outline: "none"
  },
  _hover: {
    textDecorationColor: "initial"
  }
});
const variants$4 = {
  dotted: defineStyle({
    textDecoration: "none",
    borderBottomColor: "auto",
    borderBottomStyle: "dotted",
    borderBottomWidth: "1.5px",
    transition: "borderBottomStyle 100ms ease-out",
    lineHeight: "none",
    _hover: {
      textDecoration: "none",
      borderBottomStyle: "solid",
      borderBottomWidth: "1.5px"
    }
  })
};
var linkTheme = defineStyleConfig({
  baseStyle: baseStyle$4,
  variants: variants$4
});
const baseStyle$3 = defineStyle({
  borderRadius: "md",
  px: "2",
  rounded: "md",
  lineHeight: 1.5
});
var markTheme = defineStyleConfig({
  baseStyle: baseStyle$3
});
const { definePartsStyle: definePartsStyle$1, defineMultiStyleConfig: defineMultiStyleConfig$1 } = createMultiStyleConfigHelpers(
  menuAnatomy.keys
);
const variants$3 = {
  round: definePartsStyle$1({
    button: {
      border: "2px solid",
      borderRadius: "full"
    }
  })
};
var menuTheme = defineMultiStyleConfig$1({ variants: variants$3 });
const { definePartsStyle, defineMultiStyleConfig } = createMultiStyleConfigHelpers(
  radioAnatomy.keys
);
const buttonStyle = definePartsStyle({
  ...radioCheckboxButtonStyleObject
});
var radioTheme = defineMultiStyleConfig({
  variants: { buttonStyle }
});
const baseStyle$2 = {
  size: "xl",
  variant: "bold"
};
const variants$2 = {
  bold: {
    borderWidth: 4,
    color: "blue.500",
    emptyColor: "green.400"
  }
};
var spinnerTheme = defineStyleConfig({
  baseStyle: baseStyle$2,
  variants: variants$2
});
const baseStyle$1 = defineStyle({
  my: 2,
  lineHeight: "tall",
  textUnderlineOffset: "0.2em",
  fontWeight: "medium"
});
const variants$1 = {
  notice: defineStyle({
    lineHeight: "normal",
    _dark: {
      color: "brand.yellow"
    },
    _light: {
      color: "brand.blue"
    }
  }),
  helperText: defineStyle({
    lineHeight: "normal",
    fontSize: "xs",
    letterSpacing: "0.8px",
    opacity: 0.8,
    _dark: {
      color: "text.light"
    },
    _light: {
      color: "text.dark"
    }
  }),
  postExcerpt: defineStyle({
    fontSize: "md",
    lineHeight: "normal",
    m: 0
  })
};
var textTheme = defineStyleConfig({
  baseStyle: baseStyle$1,
  variants: variants$1
});
const baseStyle = defineStyle({
  borderRadius: "md",
  borderWidth: "1px",
  px: 2,
  py: 1,
  fontSize: "xs",
  _dark: {
    bg: "gray.700",
    color: "text.light",
    borderColor: "gray.500"
  },
  _light: {
    bg: "gray.50",
    color: "text.dark",
    borderColor: "gray.300"
  }
});
var tooltipTheme = defineStyleConfig({ baseStyle });
const variants = {
  pageContent: defineStyle(() => {
    return {
      maxWidth: "5xl",
      pt: 4,
      px: 0
    };
  })
};
var containerTheme = defineStyleConfig({
  variants
});
const config = {
  initialColorMode: "dark",
  useSystemColorMode: false
};
const overrides = {
  config,
  styles,
  fonts,
  colors,
  components: {
    Avatar: avatarTheme,
    Badge: badgeTheme,
    Button: buttonTheme,
    Card: cardTheme,
    Checkbox: checkboxTheme,
    Divider: dividerTheme,
    Editable: editableTheme,
    Alert: alertTheme,
    Heading: headingTheme,
    Input: inputTheme,
    Link: linkTheme,
    Menu: menuTheme,
    Accordion: accordionTheme,
    Mark: markTheme,
    Radio: radioTheme,
    Spinner: spinnerTheme,
    Text: textTheme,
    Tooltip: tooltipTheme,
    Container: containerTheme
  }
};
var theme = extendTheme(overrides);
const Fonts = () => /* @__PURE__ */ jsx$1(
  Global,
  {
    styles: `
			/* latin */
			@font-face {
				font-family: 'Victor Serif';
				font-style: normal;
				font-weight: normal;
				font-display: swap;
				src: url('/assets/fonts/VictorSerif-50Medium.woff2') format('woff2'), url('/assets/fonts/VictorSerif-50Medium.woff') format('woff');
				unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
			}
			/* latin */
			@font-face {
				font-family: 'Victor Serif';
				font-style: italic;
				font-weight: normal;
				font-display: swap;
				src: url('/assets/fonts/VictorSerif-55MediumItalic.woff2') format('woff2'), url('/assets/fonts/VictorSerif-55MediumItalic.woff') format('woff');
				unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
			}
		`
  }
);
const name = "rise-theatre-directory";
const author = "Roundhouse Designs <nick@roundhouse-designs.com> (https://roundhouse-designs.com)";
const version = "1.2-dev";
const type = "module";
const engines = {
  node: ">=20.12.0"
};
const packageManager = "yarn@1.22.22";
const copyright = "Copyright (c) 2024 Maestra Music and Roundhouse Designs. All rights reserved.";
const scripts = {
  dev: "vite",
  "dev:clean": "rm -rf dist",
  build: "yarn dev:clean && yarn build:client && yarn build:server && yarn build:copy",
  "build:client": "tsc && vite build --outDir dist/client",
  "build:server": "vite build --ssr src/entry-server.tsx --outDir dist/server",
  "build:copy": "cp dist/server/entry-server.js functions/",
  preview: "vite preview",
  "pages:dev": "WRANGLER_LOG=debug wrangler pages dev dist/client --port 3000 --proxy 3000",
  "pages:deploy": "yarn build && wrangler pages deploy dist/client",
  start: "yarn build && yarn pages:dev"
};
const dependencies = {
  "@apollo/client": "^3.11.3",
  "@chakra-ui/react": "^2.10.4",
  "@chakra-ui/system": "^2.6.2",
  "@choc-ui/chakra-autocomplete": "^5.8.0",
  "@emotion/react": "^11.13.5",
  "@emotion/styled": "^11.13.5",
  "apollo-upload-client": "^17.0.0",
  autosize: "^6.0.1",
  "check-password-strength": "^2.0.7",
  "date-fns": "^3.6.0",
  "framer-motion": "^8.5.0",
  graphql: "^16.10.0",
  "html-react-parser": "^3.0.16",
  "js-cookie": "^3.0.5",
  lodash: "^4.17.21",
  react: "^18.2.0",
  "react-datepicker": "^7.6.0",
  "react-dom": "^18.2.0",
  "react-dropzone": "^14.2.7",
  "react-ga4": "^2.1.0",
  "react-google-recaptcha-v3": "^1.10.1",
  "react-icons": "^4.12.0",
  "react-player": "^2.14.0",
  "react-router-dom": "^6.28.1",
  semver: "^7.6.2",
  "web-vitals": "^3.5.0"
};
const devDependencies = {
  "@babel/core": "^7.22.5",
  "@babel/eslint-parser": "^7.24.1",
  "@chakra-ui/react-utils": "^2.0.5",
  "@chakra-ui/utils": "^2.0.8",
  "@types/apollo-upload-client": "^17.0.2",
  "@types/autosize": "^4.0.1",
  "@types/chance": "^1.1.3",
  "@types/js-cookie": "^3.0.6",
  "@types/node": "^20.12.12",
  "@types/react": "^18.2.46",
  "@types/react-date-range": "^1.4.9",
  "@types/react-datepicker": "^7.0.0",
  "@types/react-dom": "^18.2.18",
  "@vitejs/plugin-react": "^4.0.4",
  chance: "^1.1.9",
  eslint: "^8.57.0",
  remark: "^14.0.3",
  typescript: "^4.9.5",
  vite: "^4.5.5",
  wrangler: "^3.109.1"
};
const main = "index.js";
const repository = "https://github.com/roundhousedesigns/rise-frontend";
const license = "MIT";
var pkgJSON = {
  name,
  author,
  "private": true,
  version,
  type,
  engines,
  packageManager,
  copyright,
  scripts,
  dependencies,
  devDependencies,
  main,
  repository,
  license
};
const { VITE_FRONTEND_URL } = { "VITE_FRONTEND_URL": "http://localhost:3000", "VITE_BACKEND_URL": "https://dev.risetheatre.org/graphql", "VITE_RECAPTCHA_SITE_KEY": "6Ld7k6UmAAAAAKtdro6-WCKInHPiJxuIfcUYL_3b", "VITE_RISE_VERSION": "v1.1.9-dev", "VITE_DEV_MODE": "true", "VITE_UW_ACCOUNT": "512EhPw1RR", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": true };
const additionalFilterKeys = [
  "locations",
  "unions",
  "experienceLevels",
  "genderIdentities",
  "racialIdentities",
  "personalIdentities"
];
function socialLink(network, value) {
  const socialLinkBases = new PersonalLinks({
    twitter: "https://twitter.com/",
    instagram: "https://www.instagram.com/",
    linkedin: "",
    facebook: ""
  });
  if (!(network in socialLinkBases)) {
    return "";
  }
  let suffix = value;
  if (network !== "facebook") {
    suffix = suffix.replace("@", "");
  }
  return socialLinkBases[network] + suffix;
}
function decodeString(str) {
  let txt = document.createElement("textarea");
  txt.innerHTML = str;
  return txt.value;
}
function sanitizeBoolean(value) {
  if (typeof value === "boolean") {
    return value;
  }
  const strLower = value.toLowerCase();
  return strLower === "true" ? true : strLower === "false" ? false : null;
}
function getWPItemsFromIds(ids, items) {
  return items.filter((item) => ids.includes(item.id));
}
const hasProfileChanged = (editProfile, origProfile) => {
  if (origProfile === null)
    return false;
  const ignoreFields = [
    "credits",
    "conflictRanges",
    "slug",
    "image",
    "resume",
    "mediaImage1",
    "mediaImage2",
    "mediaImage3",
    "mediaImage4",
    "mediaImage5",
    "mediaImage6"
  ];
  const profile1 = new UserProfile({
    ...omit$1(editProfile, ignoreFields),
    id: 0,
    slug: ""
  });
  const profile2 = new UserProfile({
    ...omit$1(origProfile, ignoreFields),
    id: 0,
    slug: ""
  });
  return !isEqual$1(profile1, profile2);
};
function prepareUserProfileForGQL(profile) {
  const {
    slug,
    image,
    multilingual,
    resume,
    mediaImage1,
    mediaImage2,
    mediaImage3,
    mediaImage4,
    mediaImage5,
    mediaImage6,
    conflictRanges,
    credits,
    ...sanitized
  } = profile;
  if (!multilingual) {
    sanitized.languages = "";
  }
  return sanitized;
}
function sortAndCompareArrays(a, b) {
  return isEqual$1(a.sort(), b.sort());
}
function generateRandomString(length = 8) {
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * characters.length));
  }
  return result;
}
async function handleReCaptchaVerify({
  label,
  executeRecaptcha
}) {
  if (!executeRecaptcha) {
    return;
  }
  const token2 = await executeRecaptcha(label);
  return token2;
}
const getProfilePrefix = () => `${VITE_FRONTEND_URL}/profile/`;
function validateProfileSlug(str) {
  if (!str)
    return true;
  var regexp = /^[a-zA-Z0-9_-]+$/;
  return regexp.test(str);
}
const sortWPItemsByName = (a, b) => {
  const nameA = a.name.toLowerCase();
  const nameB = b.name.toLowerCase();
  if (nameA < nameB) {
    return -1;
  }
  if (nameA > nameB) {
    return 1;
  }
  return 0;
};
function extractSearchTermIds(obj) {
  if (!obj)
    return [];
  const numbersArray = [];
  Object.keys(obj).forEach((key) => {
    const value = obj[key];
    if (typeof value === "object" && value !== null) {
      numbersArray.push(...extractSearchTermIds(value));
    }
    if (typeof value === "string") {
      const number2 = Number(value);
      if (!isNaN(number2)) {
        numbersArray.push(number2);
      }
    }
  });
  return numbersArray;
}
function searchFilterSetsAreEqual(a, b) {
  const filtersA = a.toQueryableFilterSet();
  const filtersB = b.toQueryableFilterSet();
  return isEqual$1(filtersA, filtersB);
}
function convertUnscoredToScored(userIds) {
  return userIds.map((id2) => {
    return {
      id: parseInt(id2.toString()),
      score: 0
    };
  });
}
function setCookie(name2, value, days = 7) {
  Cookies.set(name2, String(value), { expires: days });
}
function getCookie(name2) {
  return Cookies.get(name2);
}
function deleteCookie(name2) {
  Cookies.remove(name2);
}
function prepareCreditsFromGQLNodes(nodes) {
  const credits = [];
  nodes.forEach((credit) => {
    var _a;
    if (!credit.id || !credit.title)
      return null;
    const jobs = credit.positions.nodes.filter(
      (position2) => position2.parentId !== null
    );
    const departments = credit.positions.nodes.filter(
      (position2) => position2.parentId === null
    );
    if ((!departments || !departments.length) && jobs) {
      jobs.forEach((job) => {
        if (job.parentId) {
          departments.push(new WPItem({ id: job.parentId }));
        }
      });
    }
    const newCredit = new Credit({
      id: credit.id,
      index: credit.index,
      title: credit.title,
      jobTitle: credit.jobTitle,
      jobLocation: credit.jobLocation,
      venue: credit.venue,
      workStart: credit.workStart,
      workEnd: credit.workEnd,
      workCurrent: credit.workCurrent,
      intern: credit.intern,
      fellow: credit.fellow,
      positions: {
        departments: departments == null ? void 0 : departments.map((department) => department.id),
        jobs: jobs == null ? void 0 : jobs.map((job) => job.id)
      },
      skills: (_a = credit.skills) == null ? void 0 : _a.nodes.map((skill) => skill.id)
    });
    credits.push(newCredit);
  });
  return credits;
}
function prepareUnavailDatesFromGQLNodes(nodes) {
  return nodes.map((node) => new DateRange(node));
}
function sortCreditsByIndex(credits) {
  const sorted = [...credits];
  sorted.sort((a, b) => Number(a.index) - Number(b.index));
  return sorted;
}
function validatePassword(password) {
  if (!password)
    return;
  const { value } = passwordStrength(password, [
    {
      id: 0,
      value: "weak",
      minDiversity: 0,
      minLength: 0
    },
    {
      id: 1,
      value: "strong",
      minDiversity: 4,
      minLength: 8
    }
  ]);
  return value;
}
function obscureEmail(emailString) {
  if (!emailString.includes("@")) {
    throw new Error("Invalid email format");
  }
  const [username, domain] = emailString.split("@");
  const visibleCount = Math.min(3, username.length);
  const obscuredPart = "*".repeat(username.length - visibleCount);
  return `${username.substring(0, visibleCount)}${obscuredPart}@${domain}`;
}
function dateRangesOverlap(jobDates, conflictRange) {
  const { startDate: jobStart, endDate: jobEnd } = jobDates || {};
  const { startDate: rangeStart, endDate: rangeEnd } = conflictRange;
  if (!jobStart || !rangeStart || !rangeEnd)
    return false;
  if (!jobEnd) {
    return jobStart <= rangeEnd;
  }
  return rangeStart <= jobEnd && rangeEnd >= jobStart;
}
function cloneInstance(instance) {
  const newInstance = Object.create(Object.getPrototypeOf(instance));
  return Object.assign(newInstance, instance);
}
class User {
  constructor(params) {
    __publicField(this, "id", null);
    __publicField(this, "slug", null);
    __publicField(this, "firstName");
    __publicField(this, "lastName");
    if (params) {
      Object.assign(this, params, {
        id: params.id ? Number(params.id) : null
      });
    }
  }
  /**
   * Generate a full name from a first and last name.
   */
  fullName() {
    const { firstName, lastName } = this;
    return [firstName, lastName].filter(Boolean).join(" ");
  }
}
class UserProfile extends User {
  constructor(userParams, conflictRanges, credits) {
    const {
      id: id2,
      slug,
      firstName,
      lastName,
      selfTitle,
      email,
      homebase,
      image,
      pronouns,
      phone,
      description,
      resume,
      willTravel,
      willTour,
      education,
      multilingual,
      languages,
      socials,
      twitter,
      linkedin,
      instagram,
      facebook,
      website,
      locations,
      unions,
      partnerDirectories,
      experienceLevels,
      genderIdentities,
      racialIdentities,
      personalIdentities,
      mediaVideo1,
      mediaVideo2,
      mediaImage1,
      mediaImage2,
      mediaImage3,
      mediaImage4,
      mediaImage5,
      mediaImage6
    } = userParams || {};
    super({ id: id2 ? id2 : null, firstName, lastName, slug: slug ? slug : null });
    __publicField(this, "firstName");
    __publicField(this, "lastName");
    __publicField(this, "email");
    __publicField(this, "selfTitle");
    __publicField(this, "homebase");
    __publicField(this, "image");
    __publicField(this, "pronouns");
    __publicField(this, "phone");
    __publicField(this, "description");
    __publicField(this, "resume");
    __publicField(this, "willTravel", false);
    __publicField(this, "willTour", false);
    __publicField(this, "education");
    __publicField(this, "website");
    __publicField(this, "multilingual");
    __publicField(this, "languages");
    __publicField(this, "socials", new PersonalLinks());
    __publicField(this, "locations", []);
    __publicField(this, "unions", []);
    __publicField(this, "partnerDirectories", []);
    __publicField(this, "experienceLevels", []);
    __publicField(this, "genderIdentities", []);
    __publicField(this, "racialIdentities", []);
    __publicField(this, "personalIdentities", []);
    __publicField(this, "mediaVideo1");
    __publicField(this, "mediaVideo2");
    __publicField(this, "mediaImage1");
    __publicField(this, "mediaImage2");
    __publicField(this, "mediaImage3");
    __publicField(this, "mediaImage4");
    __publicField(this, "mediaImage5");
    __publicField(this, "mediaImage6");
    __publicField(this, "conflictRanges", []);
    __publicField(this, "credits", []);
    this.firstName = firstName ? decodeString(firstName) : firstName;
    this.lastName = lastName ? decodeString(lastName) : lastName;
    this.pronouns = pronouns ? decodeString(pronouns) : pronouns;
    this.email = email;
    this.homebase = homebase ? decodeString(homebase) : homebase;
    this.selfTitle = selfTitle ? decodeString(selfTitle) : selfTitle;
    this.image = image;
    this.phone = phone;
    this.website = website;
    this.multilingual = multilingual !== void 0 ? multilingual : languages ? true : false;
    this.languages = languages ? decodeString(languages) : languages;
    this.description = description ? decodeString(description) : description;
    this.resume = resume;
    this.education = education ? decodeString(education) : education;
    this.mediaVideo1 = mediaVideo1;
    this.mediaVideo2 = mediaVideo2;
    this.mediaImage1 = mediaImage1;
    this.mediaImage2 = mediaImage2;
    this.mediaImage3 = mediaImage3;
    this.mediaImage4 = mediaImage4;
    this.mediaImage5 = mediaImage5;
    this.mediaImage6 = mediaImage6;
    if (willTravel) {
      this.willTravel = true;
    }
    if (willTour) {
      this.willTour = true;
    }
    if (locations && locations.length > 0) {
      this.locations = this.extractIdsFromNodes(locations);
    }
    if (unions && unions.length > 0) {
      this.unions = this.extractIdsFromNodes(unions);
    }
    if (partnerDirectories && partnerDirectories.length > 0) {
      this.partnerDirectories = this.extractIdsFromNodes(partnerDirectories);
    }
    if (experienceLevels && experienceLevels.length > 0) {
      this.experienceLevels = this.extractIdsFromNodes(experienceLevels);
    }
    if (genderIdentities && genderIdentities.length > 0) {
      this.genderIdentities = this.extractIdsFromNodes(genderIdentities);
    }
    if (racialIdentities && racialIdentities.length > 0) {
      this.racialIdentities = this.extractIdsFromNodes(racialIdentities);
    }
    if (personalIdentities && personalIdentities.length > 0) {
      this.personalIdentities = this.extractIdsFromNodes(personalIdentities);
    }
    if (twitter || (socials == null ? void 0 : socials.twitter)) {
      this.socials.twitter = twitter || (socials == null ? void 0 : socials.twitter) || "";
    }
    if (linkedin || (socials == null ? void 0 : socials.linkedin)) {
      this.socials.linkedin = linkedin || (socials == null ? void 0 : socials.linkedin) || "";
    }
    if (instagram || (socials == null ? void 0 : socials.instagram)) {
      this.socials.instagram = instagram || (socials == null ? void 0 : socials.instagram) || "";
    }
    if (facebook || (socials == null ? void 0 : socials.facebook)) {
      this.socials.facebook = facebook || (socials == null ? void 0 : socials.facebook) || "";
    }
    if (credits && credits.length > 0) {
      this.credits = credits.map((credit) => new Credit(credit));
    }
    if (conflictRanges && conflictRanges.length > 0) {
      this.conflictRanges = conflictRanges.map((dates) => {
        return new DateRange(dates);
      });
    }
  }
  /**
   * Setter for any property
   */
  set(key, value) {
    this[key] = value;
  }
  /**
   * Get the user's full name.
   *
   * @returns The user's full name.
   */
  fullName() {
    return super.fullName();
  }
  /**
   * Extract sorted IDs from a collection of nodes.
   */
  extractIdsFromNodes(nodes) {
    const ids = nodes.map((node) => typeof node === "object" ? node.id : Number(node) || 0);
    return ids.sort((a, b) => a - b);
  }
}
class Candidate extends User {
  constructor(params) {
    super(params);
    __publicField(this, "slug", "");
    __publicField(this, "searchScore");
    __publicField(this, "selfTitle");
    __publicField(this, "image");
    Object.assign(this, params);
  }
}
class SearchFilterSet {
  constructor(params, terms) {
    __publicField(this, "positions", {
      departments: [],
      jobs: []
    });
    __publicField(this, "skills");
    __publicField(this, "jobDates");
    __publicField(this, "unions");
    __publicField(this, "locations");
    __publicField(this, "experienceLevels");
    __publicField(this, "genderIdentities");
    __publicField(this, "racialIdentities");
    __publicField(this, "personalIdentities");
    if (!params)
      return;
    Object.assign(this, params);
    const { positions } = params;
    if (Array.isArray(positions) || !!positions.departments) {
      if (terms && terms.length > 0) {
        const jobTerms = terms.filter(
          (term) => term.taxonomyName === "position" && (!!term.parent || !!term.parentId)
        );
        const departments = [];
        jobTerms.forEach((job) => {
          const { parent, parentId } = job;
          if (!!parent) {
            departments.push(parent.id.toString());
          } else if (!!parentId) {
            departments.push(parentId.toString());
          }
        });
        const jobs = jobTerms.map((job) => job.id.toString());
        this.positions = {
          departments,
          jobs
        };
      }
    }
  }
  /**
   * Setter for any property
   */
  set(key, value) {
    this[key] = value;
  }
  /**
   * Setter for departments
   */
  setDepartments(value) {
    this.positions.departments = value;
    this.positions.jobs = [];
  }
  /**
   * Setter for jobs
   */
  setJobs(value) {
    this.positions.jobs = value;
  }
  /**
   * Returns a new object with the properties of the current instance,
   * excluding the `positions` property, and including a new `positions`
   * property with the value of the `jobs` property of the current instance.
   *
   * @return {Object} A new object with the properties of the current instance,
   *                  but with a flattened `positions` property.
   */
  toQueryableFilterSet() {
    return {
      ...this,
      positions: this.positions.jobs
    };
  }
}
class PersonalLinks {
  constructor(params = {}) {
    __publicField(this, "twitter", "");
    __publicField(this, "linkedin", "");
    __publicField(this, "instagram", "");
    __publicField(this, "facebook", "");
    Object.assign(this, params);
  }
  /**
   * Check if all properties are empty.
   * @returns {boolean} True if all properties are empty.
   */
  isEmpty() {
    return Object.keys(this).every((key) => !this[key]);
  }
}
class Credit {
  constructor(params) {
    __publicField(this, "id");
    __publicField(this, "index", 0);
    __publicField(this, "title");
    __publicField(this, "jobTitle");
    __publicField(this, "jobLocation");
    __publicField(this, "venue");
    __publicField(this, "workStart");
    __publicField(this, "workEnd");
    __publicField(this, "workCurrent");
    __publicField(this, "intern");
    __publicField(this, "fellow");
    __publicField(this, "positions", { departments: [], jobs: [] });
    __publicField(this, "skills");
    __publicField(this, "isNew", false);
    this.id = params.id.toString();
    this.index = params.index;
    this.title = params.title ? params.title : "";
    this.jobTitle = params.jobTitle ? params.jobTitle : "";
    this.jobLocation = params.jobLocation ? params.jobLocation : "";
    this.venue = params.venue ? params.venue : "";
    this.workStart = params.workStart ? params.workStart : "";
    this.workEnd = params.workEnd ? params.workEnd : "";
    this.workCurrent = params.workCurrent || false;
    this.intern = params.intern || false;
    this.fellow = params.fellow || false;
    this.skills = params.skills ? params.skills : [];
    this.positions = this.getPositions(params) || { departments: [], jobs: [] };
    this.isNew = Boolean(params.isNew) || false;
  }
  /**
   * Get the positions of the credit.
   *
   * @param {CreditParams} params - Credit parameters
   * @returns {Object} An object containing departments and jobs
   */
  getPositions(params) {
    if (params.positions) {
      return params.positions;
    }
    if (params.departments && params.departments.length > 0 && params.jobs && params.jobs.length > 0) {
      return {
        departments: params.departments.map((departments) => Number(departments)),
        jobs: params.jobs.map((job) => Number(job))
      };
    }
    return this.positions;
  }
  /**
   * Sanitize properties for GraphQL mutation.
   *
   * @returns {CreditOutput} A sanitized credit object.
   */
  prepareCreditForGraphQL() {
    const { positions, ...rest } = this;
    return {
      ...rest,
      id: Number(this.id),
      departments: positions.departments,
      jobs: positions.jobs
    };
  }
}
class JobPost {
  constructor(params) {
    __publicField(this, "id");
    __publicField(this, "title");
    __publicField(this, "companyName");
    __publicField(this, "companyAddress");
    __publicField(this, "contactName");
    __publicField(this, "contactEmail");
    __publicField(this, "startDate");
    __publicField(this, "endDate");
    __publicField(this, "contactPhone");
    __publicField(this, "instructions");
    __publicField(this, "compensation");
    __publicField(this, "applicationUrl");
    __publicField(this, "applicationPhone");
    __publicField(this, "applicationEmail");
    __publicField(this, "description");
    __publicField(this, "isInternship");
    __publicField(this, "isPaid");
    __publicField(this, "isUnion");
    this.id = params.id;
    this.title = params.title;
    this.companyName = params.companyName;
    this.companyAddress = params.companyAddress;
    this.contactEmail = params.contactEmail;
    this.contactName = params.contactName;
    this.startDate = params.startDate;
    this.instructions = params.instructions;
    Object.assign(this, params);
  }
}
class DateRange {
  constructor(params) {
    __publicField(this, "id");
    __publicField(this, "startDate");
    __publicField(this, "endDate");
    this.id = (params == null ? void 0 : params.id) ? Number(params.id) : void 0;
    this.startDate = (params == null ? void 0 : params.startDate) ? new Date(params.startDate) : void 0;
    this.endDate = (params == null ? void 0 : params.endDate) ? new Date(params.endDate) : void 0;
  }
  /**
   * Converts the DateRange to a string in the given format.
   *
   * @param {string} [format='default'] - The format to use for the string. Accepted values are:
   *     - 'default': The default format, which is 'MM-DD-YYYY'.
   *     - 'iso': The ISO format, which is 'YYYY-MM-DD'.
   *     - 'long': The long format, which is a more human-readable format, like "May 20, 2004".
   * @return {string} The formatted date range string.
   */
  toString(format = "default") {
    if (!this.startDate || !this.endDate) {
      return "";
    }
    switch (format) {
      case "iso":
        return `${this.startDate.toISOString().slice(0, 10)} - ${this.endDate.toISOString().slice(0, 10)}`;
      case "long":
        return `${new Intl.DateTimeFormat(void 0, {
          month: "long",
          day: "numeric",
          year: "numeric"
        }).format(this.startDate)} - ${new Intl.DateTimeFormat(void 0, {
          month: "long",
          day: "numeric",
          year: "numeric"
        }).format(this.endDate)}`;
      default:
        return `${this.startDate.toLocaleDateString()} - ${this.endDate.toLocaleDateString()}`;
    }
  }
  hasConflict(conflictDateRanges) {
    return conflictDateRanges.some((dateRange) => dateRangesOverlap(this, dateRange));
  }
}
class WPItem {
  constructor(params) {
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "slug");
    __publicField(this, "parentId");
    __publicField(this, "parent");
    __publicField(this, "taxonomyName");
    __publicField(this, "externalUrl");
    this.id = params.id ? Number(params.id) : 0;
    this.name = params.name ? unescape(params.name) : "";
    this.slug = params.slug ? params.slug : void 0;
    this.parentId = params.parentId ? Number(params.parentId) : void 0;
    this.parent = params.parent ? new WPItem(params.parent.node) : void 0;
    this.taxonomyName = params.taxonomyName ? params.taxonomyName : void 0;
    this.externalUrl = params.externalUrl ? params.externalUrl : void 0;
  }
}
class WPPost extends WPItem {
  constructor(params) {
    super(params);
    __publicField(this, "postType");
    __publicField(this, "author");
    __publicField(this, "title");
    __publicField(this, "excerpt");
    __publicField(this, "content");
    __publicField(this, "uri");
    __publicField(this, "featuredImage");
    this.postType = params.postType;
    this.author = params.author ? params.author : void 0;
    this.title = params.title ? unescape(params.title) : void 0;
    this.excerpt = params.excerpt ? unescape(params.excerpt) : void 0;
    this.content = params.content ? unescape(params.content) : void 0;
    this.uri = params.uri ? params.uri : void 0;
    this.featuredImage = params.featuredImage ? new WPAttachment(params.featuredImage) : void 0;
  }
}
class WPAttachment extends WPItem {
  constructor(params) {
    super(params);
    __publicField(this, "srcSet");
    this.srcSet = params.srcSet;
  }
}
const getInitialSearchState = () => ({
  filters: {
    name: "",
    filterSet: new SearchFilterSet()
  },
  searchWizardActive: false,
  additionalFiltersActive: [],
  savedSearch: {
    id: 0,
    filterSet: new SearchFilterSet()
  },
  results: []
});
const SearchContext = createContext({
  search: getInitialSearchState(),
  searchDispatch: ({}) => {
  }
});
function searchContextReducer(state2, action) {
  var _a, _b, _c, _d, _e, _f;
  switch (action.type) {
    case "SET_NAME":
      return {
        ...state2,
        filters: {
          ...getInitialSearchState().filters,
          name: action.payload.name ? action.payload.name : ""
        },
        // Clear all other filters and set the main search controls to inactive
        searchWizardActive: false
      };
    case "SET_DEPARTMENTS": {
      if (!((_a = action.payload) == null ? void 0 : _a.departments))
        return state2;
      const filterSet = new SearchFilterSet(state2.filters.filterSet);
      filterSet.setDepartments(action.payload.departments);
      return {
        ...state2,
        filters: {
          ...state2.filters,
          filterSet
        },
        searchWizardActive: true
      };
    }
    case "SET_JOBS": {
      if (!((_b = action.payload) == null ? void 0 : _b.jobs))
        return state2;
      const filterSet = new SearchFilterSet(state2.filters.filterSet);
      filterSet.setJobs(action.payload.jobs);
      return {
        ...state2,
        filters: {
          ...state2.filters,
          filterSet
        },
        searchWizardActive: true
      };
    }
    case "SET_POSITIONS": {
      if (!((_c = action.payload) == null ? void 0 : _c.departments) || !((_d = action.payload) == null ? void 0 : _d.jobs))
        return state2;
      const filterSet = new SearchFilterSet(state2.filters.filterSet);
      filterSet.setDepartments(action.payload.departments);
      filterSet.setJobs(action.payload.jobs);
      return {
        ...state2,
        filters: {
          ...state2.filters,
          filterSet
        },
        searchWizardActive: true
      };
    }
    case "SET_FILTER": {
      if (!((_e = action.payload) == null ? void 0 : _e.filter))
        return state2;
      const { key, value } = action.payload.filter;
      const filterSet = new SearchFilterSet(state2.filters.filterSet);
      filterSet.set(key, value);
      return {
        ...state2,
        filters: {
          ...state2.filters,
          filterSet
        },
        searchWizardActive: true
      };
    }
    case "SET_ADDITIONAL_FILTERS_ACTIVE": {
      if (!((_f = action.payload) == null ? void 0 : _f.additionalFiltersActive))
        return state2;
      return {
        ...state2,
        additionalFiltersActive: action.payload.additionalFiltersActive
      };
    }
    case "SET_SAVED_SEARCH_FILTERS": {
      const {
        payload: { filterSet, savedSearchId }
      } = action;
      if (!filterSet)
        return state2;
      return {
        ...state2,
        filters: {
          ...state2.filters,
          filterSet
        },
        searchWizardActive: true,
        savedSearch: {
          id: savedSearchId ? savedSearchId : 0,
          filterSet
        }
      };
    }
    case "RESTORE_SAVED_SEARCH": {
      const {
        payload: { filterSet, savedSearchId }
      } = action;
      if (!filterSet || !savedSearchId)
        return state2;
      const filterIndexes = [];
      additionalFilterKeys.forEach((key, index) => {
        if (!!filterSet[key] && filterSet[key].length)
          filterIndexes.push(index);
      });
      return {
        ...state2,
        filters: {
          ...state2.filters,
          name: "",
          filterSet
        },
        searchWizardActive: true,
        additionalFiltersActive: filterIndexes.length ? filterIndexes : [],
        savedSearch: {
          id: savedSearchId,
          filterSet
        }
      };
    }
    case "SET_RESULTS":
      return {
        ...state2,
        results: action.payload.results || []
      };
    case "RESET_SEARCH_FILTERS":
      return getInitialSearchState();
    default:
      return state2;
  }
}
const SearchContextProvider = ({ children }) => {
  const [search, searchDispatch] = useReducer(searchContextReducer, getInitialSearchState());
  return /* @__PURE__ */ jsx$1(SearchContext.Provider, { value: { search, searchDispatch }, children });
};
const defaultSearchDrawerContext = {
  drawerIsOpen: false,
  openDrawer: () => {
  },
  closeDrawer: () => {
  }
};
const SearchDrawerContext = createContext(defaultSearchDrawerContext);
var logo = "/assets/RISETHEATREDIRECTORY-white logo-slim-68b03b4a.svg";
var circleLogo = "/assets/rise-blue-circle-b650602d.png";
const QUERY_VIEWER = gql`
	query QueryViewer {
		viewer {
			id: databaseId
			slug
			firstName
			lastName
			email
			username
			disableProfile
			starredProfiles(first: 100) {
				nodes {
					databaseId
				}
			}
		}
	}
`;
const useViewer = () => {
  var _a;
  const result = useQuery(QUERY_VIEWER);
  const {
    id: loggedInId,
    slug: loggedInSlug,
    firstName,
    lastName,
    email,
    username,
    disableProfile,
    starredProfiles: starredProfilesRaw
  } = ((_a = result == null ? void 0 : result.data) == null ? void 0 : _a.viewer) || {};
  const starredProfiles = (starredProfilesRaw == null ? void 0 : starredProfilesRaw.nodes.map((node) => node.databaseId)) || [];
  return [
    {
      loggedInId,
      loggedInSlug,
      firstName,
      lastName,
      email,
      username,
      disableProfile,
      starredProfiles
    },
    omit$1(result, ["data"])
  ];
};
const QUERY_CANDIDATES$1 = gql`
	query FilteredCandidates(
		$positions: [ID] = []
		$skills: [ID] = []
		$unions: [ID] = []
		$locations: [ID] = []
		$experienceLevels: [ID] = []
		$genderIdentities: [ID] = []
		$racialIdentities: [ID] = []
		$personalIdentities: [ID] = []
		$searchUserId: ID = ""
	) {
		filteredCandidates(
			positions: $positions
			skills: $skills
			unions: $unions
			locations: $locations
			experienceLevels: $experienceLevels
			genderIdentities: $genderIdentities
			racialIdentities: $racialIdentities
			personalIdentities: $personalIdentities
			searchUserId: $searchUserId
		) {
			id: user_id
			score
		}
	}
`;
const useCandidateSearch = () => {
  return useLazyQuery(QUERY_CANDIDATES$1);
};
function SearchFilterAccordionItem({
  heading,
  headingProps,
  panelProps,
  children,
  isDisabled,
  ...props
}) {
  const HeadingContent = () => typeof heading === "object" ? heading : /* @__PURE__ */ jsx$1(
    Text,
    {
      as: "span",
      textAlign: "left",
      fontWeight: "normal",
      my: 0,
      fontSize: (headingProps == null ? void 0 : headingProps.fontSize) ? headingProps.fontSize : "inherit",
      lineHeight: "normal",
      children: heading
    }
  );
  return /* @__PURE__ */ jsxs(AccordionItem, { ...props, children: [
    /* @__PURE__ */ jsx$1(Heading, { as: "h3", flex: "1", my: 0, children: /* @__PURE__ */ jsxs(AccordionButton, { ...headingProps, disabled: isDisabled, children: [
      /* @__PURE__ */ jsx$1(HeadingContent, {}),
      /* @__PURE__ */ jsx$1(AccordionIcon, {})
    ] }) }),
    /* @__PURE__ */ jsx$1(AccordionPanel, { pt: 0, pb: 2, pr: 1, pl: 0, mt: 0, mb: 2, fontSize: "sm", ...panelProps, children: /* @__PURE__ */ jsx$1(Box, { mt: 2, children }) })
  ] });
}
function SearchFilterSection({
  id: id2,
  heading,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs(Box, { id: id2, ...props, children: [
    heading ? /* @__PURE__ */ jsx$1(Heading, { as: "h3", variant: "searchFilterTitle", children: heading }) : false,
    children
  ] });
}
const QUERY_POSITION_TERMS = gql`
	query JobsQuery($departments: [ID] = "") {
		jobsByDepartments(departments: $departments) {
			id: databaseId
			parentId: parentDatabaseId
			name
			slug
		}
	}
`;
const usePositions = (parents = [0]) => {
  var _a;
  const result = useQuery(QUERY_POSITION_TERMS, {
    variables: {
      departments: parents
    },
    skip: !parents.length
  });
  const preparedResult = (_a = result.data) == null ? void 0 : _a.jobsByDepartments.map(
    (term) => new WPItem(term)
  );
  preparedResult == null ? void 0 : preparedResult.sort(sortWPItemsByName);
  return [preparedResult, omit$1(result, ["data"])];
};
function RadioButton({
  value,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsx$1(Radio, { value, variant: "buttonStyle", position: "relative", ...props, children });
}
function SearchFilterDepartment() {
  const [data, { loading, error }] = usePositions();
  const {
    search: {
      filters: {
        filterSet: {
          positions: { departments }
        }
      },
      savedSearch: { id: savedSearchId }
    },
    searchDispatch
  } = useContext(SearchContext);
  const handleToggleTerm = (term) => {
    searchDispatch({
      type: "SET_DEPARTMENTS",
      payload: {
        departments: [term]
      }
    });
    const nextSection = document.getElementById("filterJobs");
    if (nextSection) {
      nextSection.scrollIntoView({ behavior: "smooth" });
    }
  };
  const departmentId = useMemo(() => {
    return departments && departments.length > 0 ? departments[0] : "";
  }, [departments]);
  return !loading && !error ? /* @__PURE__ */ jsxs(Box, { id: "filterDepartment", children: [
    /* @__PURE__ */ jsxs(Heading, { as: "h3", variant: "searchFilterTitle", mb: 4, children: [
      savedSearchId ? "Browse" : "Or, browse",
      " by department:"
    ] }),
    /* @__PURE__ */ jsx$1(RadioGroup, { onChange: handleToggleTerm, value: departmentId, size: "sm", children: /* @__PURE__ */ jsx$1(Wrap, { children: data.map((term) => {
      return /* @__PURE__ */ jsx$1(
        RadioButton,
        {
          name: "search-departments",
          value: term.id.toString(),
          children: term.name
        },
        term.id
      );
    }) }) })
  ] }) : loading ? /* @__PURE__ */ jsx$1(Spinner, {}) : error ? /* @__PURE__ */ jsx$1(Fragment, { children: "Error" }) : /* @__PURE__ */ jsx$1(Fragment, {});
}
function CheckboxButton({
  value,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsx$1(Checkbox, { value, variant: "buttonStyle", position: "relative", ...props, children: /* @__PURE__ */ jsx$1(Box, { pl: 1, children }) });
}
function SearchFilterJobs() {
  const {
    search: {
      filters: {
        filterSet: {
          positions: { departments = [], jobs }
        }
      }
    },
    searchDispatch
  } = useContext(SearchContext);
  const [jobItems, { loading, error }] = usePositions([Number(departments[0])]);
  const handleToggleTerm = (terms) => {
    searchDispatch({
      type: "SET_JOBS",
      payload: {
        jobs: terms
      }
    });
  };
  return /* @__PURE__ */ jsx$1(Box, { children: !loading && !error ? /* @__PURE__ */ jsx$1(CheckboxGroup, { value: jobs, onChange: handleToggleTerm, size: "sm", children: /* @__PURE__ */ jsx$1(Wrap, { children: jobItems.map((term) => /* @__PURE__ */ jsx$1(CheckboxButton, { value: term.id.toString(), children: term.name }, term.id)) }) }) : loading ? /* @__PURE__ */ jsx$1(Spinner, {}) : error ? /* @__PURE__ */ jsx$1(Fragment, { children: "Error" }) : /* @__PURE__ */ jsx$1(Fragment, { children: "Nada" }) });
}
const QUERY_RELATED_SKILLS = gql`
	query RelatedSkillsQuery($jobs: [ID!]) {
		jobSkills(jobs: $jobs) {
			id: databaseId
			name
			slug
		}
	}
`;
const useRelatedSkills = (jobs = []) => {
  var _a;
  const result = useQuery(QUERY_RELATED_SKILLS, {
    variables: {
      jobs
    },
    skip: !jobs.length
  });
  const preparedResult = (_a = result.data) == null ? void 0 : _a.jobSkills.map((skill) => new WPItem(skill));
  preparedResult == null ? void 0 : preparedResult.sort(sortWPItemsByName);
  return [preparedResult, omit$1(result, ["data"])];
};
function ErrorAlert({ message }) {
  return /* @__PURE__ */ jsx$1(Alert, { status: "error", children: message });
}
function SearchFilterSkills() {
  const {
    search: {
      filters: {
        filterSet: { positions, skills }
      }
    },
    searchDispatch
  } = useContext(SearchContext);
  const [data, { loading, error }] = useRelatedSkills(positions.jobs);
  const handleToggleTerm = (terms) => {
    searchDispatch({
      type: "SET_FILTER",
      payload: {
        filter: {
          key: "skills",
          value: terms
        }
      }
    });
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx$1(Skeleton, { isLoaded: (data == null ? void 0 : data.length) > 0 && !loading && !error, children: /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsx$1(CheckboxGroup, { defaultValue: skills, onChange: handleToggleTerm, size: "sm", children: /* @__PURE__ */ jsx$1(Wrap, { children: data == null ? void 0 : data.map((term) => /* @__PURE__ */ jsx$1(CheckboxButton, { value: term.id.toString(), children: term.name }, term.id)) }) }) }) }),
    error ? /* @__PURE__ */ jsx$1(ErrorAlert, { message: error.message }) : false
  ] });
}
const QUERY_USERS_BY_NAME = gql`
	query UsersByName($name: String!) {
		usersByName(name: $name)
	}
`;
const useSearchByName = () => {
  return useLazyQuery(QUERY_USERS_BY_NAME);
};
const TextInput = forwardRef$1(
  ({
    label,
    labelHidden,
    helperText,
    placeholder,
    value,
    variant,
    name: name2,
    isDisabled,
    isRequired,
    error,
    leftElement,
    maxLength,
    sizeToken = "md",
    inputProps,
    onChange,
    debounceTime,
    onDebounceStart,
    onDebounceEnd,
    ...props
  }, forwardedRef) => {
    const inputVariant = variant ? variant : "filled";
    const boxSize = () => {
      switch (sizeToken) {
        case "sm":
          return 8;
        case "md":
          return 10;
        case "lg":
          return 12;
      }
      return void 0;
    };
    const [localValue, setLocalValue] = useState(value);
    const isDebouncing = useRef(false);
    const handleDebouncedChange = (value2) => {
      onChange({ target: { name: name2, value: value2 } });
      isDebouncing.current = false;
      onDebounceEnd == null ? void 0 : onDebounceEnd();
    };
    const debouncedOnChange = useCallback(debounce(handleDebouncedChange, debounceTime), [
      onChange,
      name2,
      debounceTime,
      onDebounceEnd
    ]);
    const handleChange = (e) => {
      const newValue = e.target.value;
      setLocalValue(newValue);
      if (debounceTime) {
        if (!isDebouncing.current) {
          isDebouncing.current = true;
          onDebounceStart == null ? void 0 : onDebounceStart();
        }
        handleDebouncedChange(newValue);
      } else {
        onChange(e);
      }
    };
    useEffect(() => {
      return () => {
        debouncedOnChange.cancel();
      };
    }, [debouncedOnChange]);
    return /* @__PURE__ */ jsxs(FormControl, { isRequired, isInvalid: !!error, my: 1, children: [
      /* @__PURE__ */ jsxs(InputGroup, { position: "relative", children: [
        leftElement && /* @__PURE__ */ jsx$1(
          InputLeftElement,
          {
            pointerEvents: "none",
            _dark: { color: "text.dark" },
            boxSize: boxSize(),
            children: leftElement
          }
        ),
        /* @__PURE__ */ jsx$1(
          Input,
          {
            variant: inputVariant,
            focusBorderColor: "brand.blue",
            placeholder,
            isDisabled,
            px: 3,
            value: localValue,
            name: name2,
            ref: forwardedRef,
            fontSize: sizeToken,
            size: sizeToken,
            onChange: handleChange,
            _dark: {
              color: "text.dark"
            },
            maxLength: maxLength ? maxLength : void 0,
            ...inputProps
          }
        ),
        maxLength ? /* @__PURE__ */ jsx$1(Flex, { position: "absolute", right: 1, top: 0, height: "full", alignItems: "flex-end", children: /* @__PURE__ */ jsx$1(Text, { m: 0, variant: "helperText", _dark: { color: "text.dark", opacity: 0.8 }, children: `${localValue ? localValue.length : 0}/${maxLength}` }) }) : null
      ] }),
      /* @__PURE__ */ jsx$1(Flex, { direction: "row", pt: 1, my: 0, alignItems: "top", justifyContent: "space-between", children: label ? /* @__PURE__ */ jsx$1(
        FormLabel,
        {
          ml: 2,
          w: "full",
          mr: 0,
          my: 0,
          pt: 0,
          lineHeight: "normal",
          fontSize: "sm",
          flexGrow: "1",
          sx: {
            visibility: labelHidden ? "hidden" : "visible",
            position: labelHidden ? "absolute" : "initial"
          },
          children: label
        }
      ) : null }),
      /* @__PURE__ */ jsx$1(Wrap, { w: "full", alignItems: "flex-start", opacity: 0.9, fontStyle: "italic", children: /* @__PURE__ */ jsx$1(FormHelperText, { my: 0, ml: 2, flex: "1", w: "full", children: /* @__PURE__ */ jsx$1(
        Flex,
        {
          w: "full",
          justifyContent: "space-between",
          alignItems: "center",
          lineHeight: "normal",
          children: error ? /* @__PURE__ */ jsx$1(FormErrorMessage, { fontWeight: "bold", mt: 0, flex: "1", fontSize: "xs", children: error }) : helperText ? /* @__PURE__ */ jsx$1(Text, { m: 0, variant: "helperText", fontSize: "2xs", children: helperText }) : null
        }
      ) }) })
    ] });
  }
);
function TooltipIconButton({
  icon,
  label,
  tooltipProps,
  isDisabled,
  ...props
}) {
  const [hovered, setHovered] = useState(false);
  const { colorMode } = useColorMode();
  const isLargerThanMd = useBreakpointValue(
    {
      base: false,
      md: true
    },
    { ssr: false }
  );
  return /* @__PURE__ */ jsx$1(Box, { onMouseEnter: () => setHovered(true), onMouseLeave: () => setHovered(false), children: /* @__PURE__ */ jsx$1(
    Tooltip,
    {
      label,
      placement: "bottom",
      "aria-hidden": true,
      role: "presentation",
      border: "none",
      bg: colorMode === "dark" ? "gray.700" : "text.light",
      isOpen: !!hovered,
      isDisabled: !isLargerThanMd,
      hasArrow: true,
      ...tooltipProps,
      children: /* @__PURE__ */ jsx$1(
        IconButton,
        {
          icon,
          variant: "solid",
          "aria-label": label,
          pointerEvents: isDisabled ? "none" : "auto",
          ...props
        }
      )
    }
  ) });
}
function SearchFilterName({ ...props }) {
  const {
    search: {
      filters: { name: name2 },
      results: results2
    },
    searchDispatch
  } = useContext(SearchContext);
  const { closeDrawer } = useContext(SearchDrawerContext);
  const [getSearchResults, { data: { usersByName } = [], loading }] = useSearchByName();
  const navigate = useNavigate();
  const [_ignored, setOpen] = useState(false);
  useEffect(() => {
    if (name2)
      setOpen(true);
  }, [name2]);
  useEffect(() => {
    if (isEqual$1(usersByName, results2) || !usersByName)
      return;
    const searchByNameResults = convertUnscoredToScored(usersByName);
    searchDispatch({
      type: "SET_RESULTS",
      payload: {
        results: searchByNameResults
      }
    });
  }, [usersByName]);
  const handleInputChange = (e) => {
    e.preventDefault();
    const { value } = e.target;
    searchDispatch({
      type: "SET_NAME",
      payload: {
        name: value
      }
    });
  };
  const handleClear = () => {
    searchDispatch({
      type: "SET_NAME",
      payload: {
        name: ""
      }
    });
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    getSearchResults({
      variables: {
        name: name2
      }
    }).then(() => {
      navigate("/results");
      closeDrawer();
    }).catch((err) => {
      console.error(err);
    });
  };
  return /* @__PURE__ */ jsx$1(Box, { ...props, children: /* @__PURE__ */ jsx$1(chakra.form, { id: "search-by-name", onSubmit: handleSubmit, children: /* @__PURE__ */ jsxs(Flex, { gap: 2, justifyContent: "space-between", maxW: "lg", children: [
    /* @__PURE__ */ jsx$1(
      TextInput,
      {
        placeholder: "Name",
        leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiSearch }),
        name: "name",
        label: "Search by name",
        labelHidden: true,
        value: name2,
        sizeToken: "sm",
        onChange: handleInputChange,
        flex: "1 0 60%"
      }
    ),
    /* @__PURE__ */ jsxs(
      Stack,
      {
        direction: "row",
        w: name2 ? "auto" : 0,
        overflow: "hidden",
        transition: "width 250ms ease, opacity 250ms ease",
        children: [
          /* @__PURE__ */ jsx$1(
            TooltipIconButton,
            {
              icon: /* @__PURE__ */ jsx$1(FiXCircle, {}),
              onClick: handleClear,
              label: "Clear name",
              colorScheme: "orange",
              size: "sm",
              isDisabled: !name2 || loading
            }
          ),
          /* @__PURE__ */ jsx$1(
            TooltipIconButton,
            {
              label: "Search",
              colorScheme: "green",
              type: "submit",
              form: "search-by-name",
              size: "sm",
              isDisabled: !name2,
              isLoading: loading,
              icon: /* @__PURE__ */ jsx$1(FiSearch, {})
            }
          )
        ]
      }
    )
  ] }) }) });
}
const QUERY_USER_TAXONOMIES = gql`
	query UserTaxonomies {
		locations(first: 100, where: { orderby: TERM_ORDER }) {
			nodes {
				id: databaseId
				slug
				name
			}
		}
		unions(first: 100, where: { orderby: TERM_ORDER }) {
			nodes {
				id: databaseId
				slug
				name
			}
		}
		experienceLevels(first: 100, where: { orderby: TERM_ORDER }) {
			nodes {
				id: databaseId
				slug
				name
			}
		}
		partnerDirectories(first: 100, where: { orderby: TERM_ORDER }) {
			nodes {
				id: databaseId
				slug
				name
				externalUrl
			}
		}
		genderIdentities(first: 100, where: { orderby: TERM_ORDER }) {
			nodes {
				id: databaseId
				slug
				name
			}
		}
		personalIdentities(first: 100, where: { orderby: TERM_ORDER }) {
			nodes {
				id: databaseId
				slug
				name
			}
		}
		racialIdentities(first: 100, where: { orderby: TERM_ORDER }) {
			nodes {
				id: databaseId
				slug
				name
			}
		}
	}
`;
const useUserTaxonomies = () => {
  const result = useQuery(QUERY_USER_TAXONOMIES);
  const dataKeys = [
    "locations",
    "unions",
    "partnerDirectories",
    "experienceLevels",
    "genderIdentities",
    "personalIdentities",
    "racialIdentities"
  ];
  const preparedResult = dataKeys.reduce((acc, key) => {
    var _a, _b;
    acc[key] = (_b = (_a = result.data) == null ? void 0 : _a[key].nodes.map((term) => new WPItem(term))) == null ? void 0 : _b.sort(sortWPItemsByName);
    return acc;
  }, {});
  return [preparedResult, omit$1(result, ["data"])];
};
function ProfileCheckboxGroup({
  name: name2,
  items,
  checked,
  isRequired,
  requiredMessage,
  handleChange,
  ...props
}) {
  const numberChecked = checked == null ? void 0 : checked.length;
  return items ? /* @__PURE__ */ jsxs(CheckboxGroup, { value: checked, onChange: handleChange(name2), ...props, children: [
    isRequired && requiredMessage && numberChecked < 1 ? /* @__PURE__ */ jsx$1(Text, { color: "red.500", fontSize: "sm", children: requiredMessage }) : null,
    /* @__PURE__ */ jsx$1(Wrap, { spacing: 2, children: items.map((item, index) => {
      return /* @__PURE__ */ jsx$1(CheckboxButton, { value: item.id.toString(), children: item.name }, index);
    }) })
  ] }) : null;
}
function AdditionalSearchFilters() {
  const {
    search: {
      filters: { filterSet },
      additionalFiltersActive
    },
    searchDispatch
  } = useContext(SearchContext);
  const {
    locations,
    unions,
    experienceLevels,
    genderIdentities,
    personalIdentities,
    racialIdentities
  } = filterSet;
  const [
    {
      locations: locationTerms,
      unions: unionTerms,
      experienceLevels: experienceLevelTerms,
      genderIdentities: genderIdentityTerms,
      personalIdentities: personalIdentityTerms,
      racialIdentities: racialIdentityTermsUnfiltered
    }
  ] = useUserTaxonomies();
  const racialIdentityTerms = racialIdentityTermsUnfiltered ? racialIdentityTermsUnfiltered.filter((item) => item.slug !== "white") : [];
  const handleInputChange = (name2) => (newValue) => {
    searchDispatch({
      type: "SET_FILTER",
      payload: {
        filter: {
          key: name2,
          value: newValue
        }
      }
    });
  };
  useEffect(() => {
    const newActiveFilters = additionalFilterKeys.reduce((acc, key, index) => {
      if (!isEmpty$1(filterSet[key]))
        return [...acc, index];
      return acc.filter((item) => item !== index);
    }, []);
    searchDispatch({
      type: "SET_ADDITIONAL_FILTERS_ACTIVE",
      payload: {
        additionalFiltersActive: newActiveFilters
      }
    });
  }, [filterSet]);
  return (
    /* The order of these items must match the order of filters in the useEffect. */
    /* @__PURE__ */ jsxs(
      Accordion,
      {
        allowMultiple: true,
        w: "full",
        defaultIndex: additionalFiltersActive.length ? additionalFiltersActive : void 0,
        mt: 0,
        pt: 0,
        children: [
          /* @__PURE__ */ jsx$1(SearchFilterAccordionItem, { heading: "Locations", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "locations",
              items: locationTerms,
              checked: locations,
              handleChange: handleInputChange,
              pt: 0
            }
          ) }),
          /* @__PURE__ */ jsx$1(SearchFilterAccordionItem, { heading: "Unions", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "unions",
              items: unionTerms,
              checked: unions,
              handleChange: handleInputChange
            }
          ) }),
          /* @__PURE__ */ jsx$1(SearchFilterAccordionItem, { heading: "Experience Levels", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "experienceLevels",
              items: experienceLevelTerms,
              checked: experienceLevels,
              handleChange: handleInputChange
            }
          ) }),
          /* @__PURE__ */ jsx$1(SearchFilterAccordionItem, { heading: "Gender Identity", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "genderIdentities",
              items: genderIdentityTerms,
              checked: genderIdentities,
              handleChange: handleInputChange
            }
          ) }),
          /* @__PURE__ */ jsx$1(SearchFilterAccordionItem, { heading: "Personal Identity", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "personalIdentities",
              items: personalIdentityTerms,
              checked: personalIdentities,
              handleChange: handleInputChange
            }
          ) }),
          /* @__PURE__ */ jsx$1(SearchFilterAccordionItem, { heading: "Racial Identity", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "racialIdentities",
              items: racialIdentityTerms,
              checked: racialIdentities,
              handleChange: handleInputChange
            }
          ) })
        ]
      }
    )
  );
}
const QUERY_SAVED_SEARCHES = gql`
	query QuerySavedSearches($author: Int!, $in: [ID] = []) {
		savedSearches(where: { author: $author, in: $in }) {
			nodes {
				content(format: RAW)
				title
				id: databaseId
				author: authorDatabaseId
			}
		}
	}
`;
function useSavedSearches(ids = []) {
  var _a, _b, _c;
  const [{ loggedInId }] = useViewer();
  const result = useQuery(QUERY_SAVED_SEARCHES, {
    variables: {
      author: loggedInId,
      in: ids
    }
  });
  const savedSearches = (_c = (_b = (_a = result.data) == null ? void 0 : _a.savedSearches) == null ? void 0 : _b.nodes) == null ? void 0 : _c.map(
    (savedSearch) => {
      const { id: id2, author: author2, title, content } = savedSearch;
      const params = {
        id: id2,
        author: author2,
        title,
        content
      };
      return new WPPost(params);
    }
  );
  return [savedSearches, omit$1(result, ["data"])];
}
const QUERY_TAXONOMY_TERMS = gql`
	query TaxonomyTerms($include: [ID] = []) {
		terms(where: { include: $include, order: ASC }, first: 9999) {
			nodes {
				id: databaseId
				name
				slug
				taxonomyName
				... on Position {
					name
					id: databaseId
					parent {
						node {
							id: databaseId
							name
						}
					}
				}
			}
		}
	}
`;
const useTaxonomyTerms = (ids) => {
  var _a;
  const result = useQuery(QUERY_TAXONOMY_TERMS, {
    variables: {
      include: ids
    }
  });
  const preparedResult = [];
  if (((_a = result.data) == null ? void 0 : _a.terms.nodes) && result.data.terms.nodes.length > 0)
    result.data.terms.nodes.forEach((node) => preparedResult.push(new WPItem(node)));
  return [preparedResult, omit$1(result, ["data"])];
};
const useLazyTaxonomyTerms = () => {
  return useLazyQuery(QUERY_TAXONOMY_TERMS);
};
const QUERY_PROFILE = gql`
	query UserQuery($id: ID!, $author: Int!, $lastCredits: Int = 5) {
		user(id: $id, idType: DATABASE_ID) {
			id: databaseId
			firstName
			lastName
			pronouns
			email: contactEmail
			selfTitle
			homebase
			image
			phone
			description
			languages
			resume
			willTravel
			willTour
			education
			twitter
			instagram
			linkedin
			facebook
			website: websiteUrl
			locations {
				id: databaseId
			}
			unions {
				id: databaseId
			}
			partnerDirectories {
				id: databaseId
			}
			experienceLevels {
				id: databaseId
			}
			genderIdentities {
				id: databaseId
			}
			racialIdentities {
				id: databaseId
			}
			personalIdentities {
				id: databaseId
			}
			mediaVideo1(format: RAW)
			mediaVideo2(format: RAW)
			mediaImage1(format: RAW)
			mediaImage2(format: RAW)
			mediaImage3(format: RAW)
			mediaImage4(format: RAW)
			mediaImage5(format: RAW)
			mediaImage6(format: RAW)
		}
		credits(where: { author: $author }, last: $lastCredits) {
			nodes {
				id: databaseId
				index
				title(format: RENDERED)
				jobTitle(format: RENDERED)
				jobLocation(format: RENDERED)
				venue(format: RENDERED)
				workStart(format: RENDERED)
				workEnd(format: RENDERED)
				workCurrent
				intern
				fellow
				positions(first: 50) {
					nodes {
						id: databaseId
						parentId: parentDatabaseId
					}
				}
				skills(first: 50) {
					nodes {
						id: databaseId
					}
				}
			}
		}
		conflictRanges(where: { author: $author }) {
			nodes {
				id: databaseId
				startDate
				endDate
			}
		}
	}
`;
const useUserProfile = (id2, count) => {
  var _a, _b;
  const result = useQuery(QUERY_PROFILE, {
    variables: {
      id: id2,
      author: id2,
      last: count
    },
    skip: id2 === null
  });
  const credits = ((_a = result.data) == null ? void 0 : _a.credits.nodes) ? prepareCreditsFromGQLNodes(result.data.credits.nodes) : [];
  const conflictRanges = ((_b = result.data) == null ? void 0 : _b.conflictRanges.nodes) ? prepareUnavailDatesFromGQLNodes(result.data.conflictRanges.nodes) : [];
  const preparedProfile = result.data ? new UserProfile(result.data.user, conflictRanges, credits) : null;
  return [preparedProfile, omit$1(result, ["data"])];
};
const useErrorMessage = (errorCode, defaultMessage = "Error") => {
  if (!errorCode)
    return "";
  switch (errorCode) {
    case "invalid_username":
    case "invalid_email":
      return "No account exists for that email address.";
    case "empty_login":
      return "Please enter a username or email address.";
    case "invalid_account":
      return "Please use a different account.";
    case "bad_login":
      return "Something went wrong. Please try again.";
    case "empty_password":
      return "Please enter your password.";
    case "incorrect_password":
      return "Incorrect password.";
    case "password_mismatch":
      return "Passwords do not match.";
    case "password_too_weak":
      return "Please make sure your password contains at least one lowercase letter, one uppercase letter, one number, and one special character.";
    case "existing_user_login":
      return "An account already exists for that email address. Please try logging in.";
    case "unspecified_create_user_error":
      return "Something went wrong. Please try again.";
    case "recaptcha_error":
    case "no_recaptcha_token":
    case "bad_recaptcha_token":
      return "reCAPTCHA error.";
    case "user_not_found":
      return "There was an error updating your profile URL. Please contact support.";
    case "user_not_authorized":
      return "You do not appear to be logged in.";
    case "user_slug_not_unique":
      return "This alias is already in use. Please choose another.";
    case "user_slug_invalid":
      return "Only letters, numbers, dashes (-) and underscores (_) are allowed.";
    case "conflict_range_overlap":
      return "This date range overlaps with an existing busy time. Please try again.";
    case "multilingual_no_languages":
      return "Please enter at least one language.";
    default:
      return defaultMessage + ": " + errorCode;
  }
};
const useProfileUrl = (slug) => {
  const prefix2 = getProfilePrefix();
  return `${prefix2}${slug}`;
};
const useValidateProfileSlug = (slug) => validateProfileSlug(slug);
const useValidatePassword = (password) => validatePassword(password);
const useSavedSearchFiltersChanged = () => {
  const {
    search: {
      filters: { filterSet: currentFilterSet },
      savedSearch: { filterSet: savedSearchFilterSet }
    }
  } = useContext(SearchContext);
  return !searchFilterSetsAreEqual(currentFilterSet, savedSearchFilterSet);
};
const useProfileCompletion = (profileId) => {
  const [profile] = useUserProfile(profileId);
  const fieldsToCalculate = {
    selfTitle: 10,
    email: 10,
    image: 10,
    homebase: 10,
    pronouns: 5,
    description: 10,
    resume: 15,
    education: 5,
    locations: 10,
    socials: 5,
    website: 5,
    unions: 5,
    experienceLevels: 5,
    credits: 30
    // firstName: 1,
    // lastName: 1,
    // phone: 1,
    // willTravel: 1,
    // willTour: 1,
    // partnerDirectories: 1,
    // multilingual: 1,
    // languages: 1,
    // genderIdentities: 1,
    // racialIdentities,
    // personalIdentities,
    // mediaVideo1: 1,
    // mediaVideo2: 1,
    // mediaImage1: 1,
    // mediaImage2: 1,
    // mediaImage3: 1,
    // mediaImage4: 1,
    // mediaImage5: 1,
    // mediaImage6: 1,
  };
  const totalWeight = Object.values(fieldsToCalculate).reduce((a, b) => a + b, 0);
  let profileCompletion = 0;
  if (!profile) {
    return 0;
  }
  for (const [field, weight] of Object.entries(fieldsToCalculate)) {
    if (profile[field] && typeof profile[field] === "object") {
      if (Object.values(profile[field]).some((value) => value)) {
        profileCompletion += weight;
      }
    } else if (profile[field]) {
      profileCompletion += weight;
    }
  }
  return Math.round(profileCompletion / totalWeight * 100);
};
const MUTATE_DELETE_CREDIT$1 = gql`
	mutation DeleteOwnSavedSearch($input: DeleteOwnSavedSearchInput!) {
		deleteOwnSavedSearch(input: $input) {
			result
			clientMutationId
		}
	}
`;
const useDeleteOwnSavedSearch = () => {
  const [mutation, results2] = useMutation(MUTATE_DELETE_CREDIT$1);
  const deleteOwnSavedSearchMutation = (id2, userId) => {
    return mutation({
      variables: {
        input: {
          clientMutationId: "deleteOwnSavedSearchMutation",
          id: Number(id2),
          userId
        }
      },
      refetchQueries: [{ query: QUERY_SAVED_SEARCHES, variables: { author: userId } }]
    });
  };
  return { deleteOwnSavedSearchMutation, results: results2 };
};
const MUTATE_UPDATE_SAVED_SEARCH = gql`
	mutation SaveSearch(
		$filterSet: QueryableSearchFilterSet!
		$id: ID!
		$title: String!
		$userId: ID!
	) {
		updateOrCreateSavedSearch(
			input: { filterSet: $filterSet, id: $id, title: $title, userId: $userId }
		) {
			id
		}
	}
`;
const useSaveSearch = () => {
  const [mutation, results2] = useMutation(MUTATE_UPDATE_SAVED_SEARCH);
  const saveSearchMutation = ({
    id: id2,
    title,
    filterSet,
    userId
  }) => {
    return mutation({
      variables: {
        id: id2 ? id2 : 0,
        title,
        filterSet,
        userId
      },
      refetchQueries: [{ query: QUERY_SAVED_SEARCHES, variables: { author: userId } }]
    });
  };
  return { saveSearchMutation, results: results2 };
};
function SearchParamTags({
  termIds,
  termItems,
  tagProps,
  ...props
}) {
  var _a;
  if (!termIds.length || !termItems.length)
    return null;
  const terms = termIds.map(
    (termId) => termItems.find((term) => term.id === termId)
  );
  const departments = terms.filter((term) => term.taxonomyName === "position").reduce((positions, term) => {
    const termToAdd = term.parent || term;
    if (!positions.find((item) => item.id === termToAdd.id)) {
      positions.push(termToAdd);
    }
    return positions;
  }, []);
  const jobs = terms.filter((term) => {
    return term.taxonomyName === "position" && term.parent;
  });
  const skills = terms.filter((term) => term.taxonomyName === "skill");
  const filters = terms.filter(
    (term) => term.taxonomyName !== "position" && term.taxonomyName !== "skill"
  );
  const renderTags = (items, colorScheme) => {
    return items.map(({ id: id2, name: name2 }) => /* @__PURE__ */ jsx$1(Tag, { colorScheme, size: "sm", ...tagProps, children: /* @__PURE__ */ jsx$1(TagLabel, { children: name2 }) }, id2));
  };
  const termTags = () => {
    const departmentTags = renderTags(departments, "orange");
    const jobTags = renderTags(jobs, "blue");
    const skillTags = renderTags(skills, "green");
    const filterTags = renderTags(filters, "purple");
    if (!departmentTags.length && !jobTags.length && !skillTags.length && !filterTags.length)
      return [];
    if (departmentTags.length || jobTags.length || skillTags.length || filterTags.length)
      return [departmentTags, jobTags, skillTags, filterTags];
  };
  return /* @__PURE__ */ jsx$1(Flex, { flexWrap: "wrap", gap: 1, alignItems: "center", ...props, children: (_a = termTags()) == null ? void 0 : _a.map((tag) => tag) });
}
function ConfirmActionDialog({
  isOpen,
  onClose,
  confirmAction,
  headerText,
  buttonsText,
  confirmButtonColorScheme,
  children
}) {
  const cancelRef = useRef(null);
  return /* @__PURE__ */ jsx$1(AlertDialog, { isOpen, leastDestructiveRef: cancelRef, onClose, children: /* @__PURE__ */ jsx$1(ModalOverlay, { children: /* @__PURE__ */ jsxs(AlertDialogContent, { children: [
    /* @__PURE__ */ jsx$1(ModalHeader, { fontSize: "lg", fontWeight: "bold", children: headerText }),
    /* @__PURE__ */ jsx$1(ModalBody, { children }),
    /* @__PURE__ */ jsxs(ModalFooter, { children: [
      /* @__PURE__ */ jsx$1(Button, { ref: cancelRef, onClick: onClose, children: (buttonsText == null ? void 0 : buttonsText.cancel) ? buttonsText.cancel : "Cancel" }),
      /* @__PURE__ */ jsx$1(
        Button,
        {
          colorScheme: confirmButtonColorScheme ? confirmButtonColorScheme : "green",
          onClick: confirmAction,
          ml: 3,
          children: (buttonsText == null ? void 0 : buttonsText.confirm) ? buttonsText.confirm : "OK"
        }
      )
    ] })
  ] }) }) });
}
function LinkWithIcon({
  href,
  onClick,
  icon,
  iconSide = "left",
  isExternal,
  children,
  iconProps,
  ...props
}) {
  return /* @__PURE__ */ jsx$1(
    Link,
    {
      href: href ? href : void 0,
      onClick: onClick ? onClick : void 0,
      fontWeight: "medium",
      display: "inline-block",
      variant: "dotted",
      isExternal: !!isExternal,
      my: 0,
      ...props,
      children: /* @__PURE__ */ jsxs(
        Flex,
        {
          alignItems: "center",
          flexDirection: iconSide === "left" ? "row" : "row-reverse",
          justifyContent: "flex-start",
          gap: 0,
          w: "auto",
          children: [
            /* @__PURE__ */ jsx$1(Icon, { as: icon, pos: "relative", mr: 2, ...iconProps }),
            /* @__PURE__ */ jsx$1(Text, { as: "span", m: 0, lineHeight: "normal", display: "block", children }),
            /* @__PURE__ */ jsx$1(Spacer, {})
          ]
        }
      )
    }
  );
}
function EditSavedSearchModal({ id: id2, title, searchTerms, isOpen, onClose }) {
  const [{ loggedInId }] = useViewer();
  const { searchDispatch } = useContext(SearchContext);
  const initialSaveModalRef = useRef(null);
  const {
    saveSearchMutation,
    results: { loading: saveLoading }
  } = useSaveSearch();
  const [saveSearchFieldText, setSaveSearchFieldText] = useState("");
  useEffect(() => {
    setSaveSearchFieldText(title ? title : "");
  }, [title]);
  const toast = useToast();
  const handleEditOnClose = () => {
    onClose();
  };
  const handleSavedSearchNameChange = (event) => {
    setSaveSearchFieldText(event.target.value);
  };
  const handleSave = (e) => {
    e.preventDefault();
    saveSearchMutation({
      userId: loggedInId,
      title: saveSearchFieldText,
      filterSet: searchTerms.toQueryableFilterSet(),
      id: id2
    }).then((results2) => {
      const {
        data: {
          updateOrCreateSavedSearch: { id: id22 }
        }
      } = results2;
      searchDispatch({
        type: "SET_SAVED_SEARCH_FILTERS",
        payload: {
          filterSet: searchTerms,
          savedSearchId: id22
        }
      });
    }).then(() => {
      onClose();
      toast({
        title: "Saved!",
        description: "This search has been saved for later.",
        position: "bottom",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    });
  };
  return /* @__PURE__ */ jsxs(Modal, { initialFocusRef: initialSaveModalRef, isOpen, onClose: handleEditOnClose, children: [
    /* @__PURE__ */ jsx$1(ModalOverlay, {}),
    /* @__PURE__ */ jsxs(ModalContent, { children: [
      /* @__PURE__ */ jsx$1(ModalHeader, { pb: 2, children: !!title ? "Rename this search" : "Save this search" }),
      /* @__PURE__ */ jsx$1(ModalCloseButton, {}),
      /* @__PURE__ */ jsxs(ModalBody, { pb: 6, children: [
        /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", mt: 0, children: "Give this search a short, descriptive name to easily run it again." }),
        /* @__PURE__ */ jsxs(chakra.form, { id: "rename-search", onSubmit: handleSave, children: [
          /* @__PURE__ */ jsxs(FormControl, { children: [
            /* @__PURE__ */ jsx$1(
              FormLabel,
              {
                "aria-label": "Name",
                visibility: "hidden",
                position: "absolute",
                left: "9000px",
                children: "Name"
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                name: "title",
                placeholder: "My search",
                onChange: handleSavedSearchNameChange,
                value: saveSearchFieldText,
                ref: initialSaveModalRef
              }
            )
          ] }),
          /* @__PURE__ */ jsx$1(
            Button,
            {
              colorScheme: "blue",
              mr: 3,
              type: "submit",
              isDisabled: saveLoading,
              isLoading: saveLoading,
              children: "Save"
            }
          ),
          /* @__PURE__ */ jsx$1(Button, { onClick: handleEditOnClose, colorScheme: "red", isDisabled: saveLoading, children: "Cancel" })
        ] })
      ] })
    ] })
  ] });
}
function SavedSearchItem({
  id: id2,
  title,
  searchTerms,
  showControls = true,
  showSaveButton = false,
  ...props
}) {
  const [{ loggedInId }] = useViewer();
  const [_ignored, { data: { filteredCandidates } = [] }] = useCandidateSearch();
  const {
    search: { results: results2 },
    searchDispatch
  } = useContext(SearchContext);
  const { openDrawer, drawerIsOpen } = useContext(SearchDrawerContext);
  const { isOpen: editIsOpen, onOpen: editOnOpen, onClose: editOnClose } = useDisclosure();
  const { isOpen: deleteIsOpen, onOpen: deleteOnOpen, onClose: deleteOnClose } = useDisclosure();
  const { deleteOwnSavedSearchMutation } = useDeleteOwnSavedSearch();
  const [saveNewSearch, setSaveNewSearch] = useState(false);
  const [searchFilterSet, setSearchFilterSet] = useState(null);
  const [terms, setTerms] = useState([]);
  const savedSearchFiltersChanged = useSavedSearchFiltersChanged();
  const [whichButtonClicked, setWhichButtonClicked] = useState("");
  const {
    saveSearchMutation,
    results: { loading: saveLoading }
  } = useSaveSearch();
  const termIds = extractSearchTermIds(searchTerms);
  const [getTerms] = useLazyTaxonomyTerms();
  useEffect(() => {
    if (!termIds.length)
      return;
    getTerms({
      variables: {
        include: termIds
      }
    }).then((res) => {
      const {
        data: {
          terms: { nodes }
        }
      } = res;
      if (!nodes)
        return;
      setTerms(nodes.map((term) => new WPItem(term)));
    });
  }, [termIds.length]);
  useEffect(() => {
    if (!searchTerms || !terms)
      return;
    const newSearchFilterSet = new SearchFilterSet(searchTerms, terms);
    if (!isEqual$1(searchFilterSet, newSearchFilterSet)) {
      setSearchFilterSet(newSearchFilterSet);
    }
  }, [searchTerms, terms]);
  const toast = useToast();
  useEffect(() => {
    if (isEqual$1(filteredCandidates, results2) || !filteredCandidates)
      return;
    searchDispatch({
      type: "SET_RESULTS",
      payload: {
        results: filteredCandidates
      }
    });
  }, [filteredCandidates]);
  const handleSearchClick = () => {
    if (!searchFilterSet)
      return;
    setWhichButtonClicked("search");
    searchDispatch({
      type: "RESTORE_SAVED_SEARCH",
      payload: {
        savedSearchId: id2,
        filterSet: searchFilterSet
      }
    });
    const filterDepartment = document.getElementById("filterDepartment");
    if (filterDepartment) {
      filterDepartment.scrollIntoView({ behavior: "smooth" });
    }
    if (!drawerIsOpen)
      openDrawer();
  };
  const handleEditTitleClick = () => {
    editOnOpen();
  };
  const handleSaveNewSearchClick = () => {
    setWhichButtonClicked("new");
    setSaveNewSearch(true);
    editOnOpen();
  };
  const handleUpdateClick = () => {
    if (!searchFilterSet || !title)
      return;
    setWhichButtonClicked("update");
    saveSearchMutation({
      userId: loggedInId,
      title,
      filterSet: searchFilterSet.toQueryableFilterSet(),
      id: saveNewSearch ? 0 : id2
    }).then((results22) => {
      const {
        data: {
          updateOrCreateSavedSearch: { id: id22 }
        }
      } = results22;
      searchDispatch({
        type: "SET_SAVED_SEARCH_FILTERS",
        payload: {
          filterSet: searchFilterSet,
          savedSearchId: id22
        }
      });
    }).then(() => {
      editOnClose();
      setSaveNewSearch(false);
      toast({
        title: "Saved!",
        description: "This search has been saved for later.",
        position: "bottom",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
      setWhichButtonClicked("");
    });
  };
  const handleDelete = () => {
    setWhichButtonClicked("delete");
    if (!id2)
      return;
    deleteOwnSavedSearchMutation(id2, loggedInId).then(() => {
      deleteOnClose();
      toast({
        title: "Deleted!",
        description: "This saved search has been deleted.",
        position: "bottom",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    });
  };
  const handleEditClose = () => {
    setWhichButtonClicked("");
    editOnClose();
  };
  return terms && terms.length > 0 ? /* @__PURE__ */ jsxs(Card, { p: 0, my: 0, ...props, children: [
    /* @__PURE__ */ jsxs(Flex, { justifyContent: "space-between", children: [
      /* @__PURE__ */ jsxs(Stack, { w: "auto", alignItems: "space-between", p: 2, children: [
        /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsx$1(Flex, { alignItems: "flex-end", children: /* @__PURE__ */ jsx$1(
          LinkWithIcon,
          {
            onClick: handleEditTitleClick,
            icon: FiEdit2,
            fontSize: "lg",
            mb: 1,
            flex: 1,
            iconSide: "left",
            color: "inherit",
            borderBottomWidth: "2px",
            borderBottomStyle: "dotted",
            textDecoration: "none !important",
            transition: "border 150ms ease",
            _hover: { borderBottomStyle: "dotted", borderBottomWidth: "2px" },
            _light: {
              borderBottomColor: "gray.300",
              _hover: { borderBottomColor: "gray.500" }
            },
            _dark: {
              borderBottomColor: "gray.600",
              _hover: { borderBottomColor: "gray.500" }
            },
            iconProps: { boxSize: 4, mb: "2px", ml: 1, position: "relative", top: "2px" },
            children: title ? title : /* @__PURE__ */ jsx$1(Text, { as: "span", opacity: "0.5", lineHeight: "normal", children: "Save this search" })
          }
        ) }) }),
        /* @__PURE__ */ jsx$1(Box, { as: Flex, w: "full", justifyContent: "space-between", flexWrap: "wrap", gap: 6, children: /* @__PURE__ */ jsx$1(Skeleton, { isLoaded: !!terms.length, children: /* @__PURE__ */ jsx$1(SearchParamTags, { termIds, termItems: terms, flex: "1" }) }) })
      ] }),
      id2 ? /* @__PURE__ */ jsx$1(Box, { p: 2, children: showControls ? /* @__PURE__ */ jsxs(ButtonGroup, { size: "sm", children: [
        /* @__PURE__ */ jsx$1(
          TooltipIconButton,
          {
            icon: /* @__PURE__ */ jsx$1(FiSearch, {}),
            "aria-label": "Load these filters",
            label: "Load these filters",
            colorScheme: "green",
            onClick: handleSearchClick,
            children: "Search"
          }
        ),
        /* @__PURE__ */ jsx$1(
          TooltipIconButton,
          {
            icon: /* @__PURE__ */ jsx$1(FiDelete, {}),
            "aria-label": "Delete this search",
            label: "Delete this search",
            colorScheme: "red",
            onClick: deleteOnOpen,
            children: "Delete"
          }
        )
      ] }) : savedSearchFiltersChanged ? /* @__PURE__ */ jsxs(Stack, { textAlign: "center", children: [
        /* @__PURE__ */ jsx$1(
          Button,
          {
            colorScheme: "yellow",
            leftIcon: /* @__PURE__ */ jsx$1(FiSave, {}),
            "aria-label": "Update saved filters",
            title: "Update saved filters",
            onClick: handleUpdateClick,
            size: "sm",
            isLoading: saveLoading && whichButtonClicked === "update",
            isDisabled: saveLoading,
            children: "Update"
          }
        ),
        /* @__PURE__ */ jsx$1(
          Button,
          {
            colorScheme: "blue",
            leftIcon: /* @__PURE__ */ jsx$1(FiPlusCircle, {}),
            "aria-label": "Update saved filters",
            title: "Update saved filters",
            onClick: handleSaveNewSearchClick,
            size: "sm",
            isLoading: saveLoading && whichButtonClicked === "new",
            isDisabled: saveLoading,
            children: "Save New"
          }
        )
      ] }) : false }) : false
    ] }),
    /* @__PURE__ */ jsx$1(
      EditSavedSearchModal,
      {
        id: id2 && !saveNewSearch ? id2 : 0,
        title: title ? title : "",
        isOpen: editIsOpen,
        onClose: handleEditClose,
        searchTerms: searchFilterSet ? searchFilterSet : new SearchFilterSet()
      }
    ),
    /* @__PURE__ */ jsx$1(
      ConfirmActionDialog,
      {
        confirmAction: handleDelete,
        isOpen: deleteIsOpen,
        onClose: deleteOnClose,
        headerText: "Delete this search",
        children: "Are you sure you want to delete this saved search?"
      }
    )
  ] }) : null;
}
function SavedSearchItemList({ ...props }) {
  const [savedSearches] = useSavedSearches();
  const isLargerThanMd = useBreakpointValue(
    {
      base: false,
      md: true
    },
    { ssr: false }
  );
  const parsedSearches = useMemo(() => {
    return savedSearches ? savedSearches.map((savedSearch) => {
      const { id: id2, title, content } = savedSearch;
      if (!content) {
        return null;
      }
      const json = JSON.parse(content);
      const filters = new SearchFilterSet(json);
      return { id: id2, title, filters };
    }).filter(Boolean) : [];
  }, [savedSearches]);
  return /* @__PURE__ */ jsx$1(Box, { ...props, children: parsedSearches.length > 0 ? /* @__PURE__ */ jsx$1(Flex, { ml: 0, px: 0, maxW: "4xl", "justify-content": "center", gap: 2, flexWrap: "wrap", children: /* @__PURE__ */ jsx$1(AnimatePresence, { children: parsedSearches.map(({ id: id2, title, filters }) => {
    return /* @__PURE__ */ jsx$1(
      SavedSearchItem,
      {
        as: motion.div,
        initial: { opacity: 1 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        flex: "0 1 450px",
        searchTerms: filters,
        title,
        id: id2,
        _light: {
          bgColor: !isLargerThanMd && id2 % 2 === 0 ? "blackAlpha.200" : "blackAlpha.50"
        }
      },
      id2
    );
  }) }) }) : null });
}
var reactDatepicker = "";
const DatePickerButton = forwardRef$1(
  ({ defaultText, ariaLabel, value, onClick, ...props }, ref) => /* @__PURE__ */ jsx$1(
    Button,
    {
      onClick,
      leftIcon: /* @__PURE__ */ jsx$1(FiCalendar, {}),
      ref,
      variant: "searchFilter",
      "aria-label": ariaLabel ? ariaLabel : defaultText,
      ...props,
      children: value ? value : defaultText
    }
  )
);
const InlineIconText = ({
  text,
  icon,
  description,
  query,
  iconProps,
  ...props
}) => {
  const regex = new RegExp(`(\\b${query}\\b)`, "gi");
  const InlineIcon = () => {
    return /* @__PURE__ */ jsx$1(
      IconButton,
      {
        icon,
        variant: "sampleIconButton",
        title: "Search",
        mx: 1,
        position: "relative",
        bottom: "2px",
        "aria-label": `${description} icon`,
        bgColor: "blackAlpha.300",
        isDisabled: true,
        ...iconProps
      }
    );
  };
  const parts = text.split(regex);
  return /* @__PURE__ */ jsx$1(Text, { fontSize: "xl", my: 0, display: "inline", lineHeight: "none", ...props, children: parts.map((part, index) => /* @__PURE__ */ jsx$1(Fragment$1, { children: part.toLowerCase() === query.toLowerCase() ? /* @__PURE__ */ jsx$1(InlineIcon, {}) : part }, index)) });
};
function SearchFilterDates() {
  const {
    search: {
      filters: {
        filterSet: { jobDates }
      }
    },
    searchDispatch
  } = useContext(SearchContext);
  const { startDate, endDate } = jobDates || new DateRange();
  useEffect(() => {
    if (startDate && endDate && startDate > endDate) {
      searchDispatch({
        type: "SET_FILTER",
        payload: {
          filter: { key: "jobDates", value: new DateRange({ startDate, endDate: void 0 }) }
        }
      });
    }
  }, [startDate]);
  const handleDateChange = (targetId) => (date) => {
    if (!date)
      return;
    searchDispatch({
      type: "SET_FILTER",
      payload: {
        filter: {
          key: "jobDates",
          value: new DateRange({ ...jobDates, [targetId]: date })
        }
      }
    });
  };
  const handleClearDates = () => {
    searchDispatch({
      type: "SET_FILTER",
      payload: { filter: { key: "jobDates", value: new DateRange() } }
    });
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Flex, { gap: 4, alignItems: "center", flexWrap: "wrap", children: [
      /* @__PURE__ */ jsx$1(
        DatePicker,
        {
          closeOnScroll: (e) => e.target === document,
          selected: startDate,
          customInput: /* @__PURE__ */ jsx$1(DatePickerButton, { defaultText: "Start", ariaLabel: "Start date" }),
          onChange: handleDateChange("startDate"),
          minDate: /* @__PURE__ */ new Date()
        }
      ),
      startDate && /* @__PURE__ */ jsx$1(Text, { fontSize: "md", children: " to " }),
      startDate && /* @__PURE__ */ jsx$1(
        DatePicker,
        {
          closeOnScroll: (e) => e.target === document,
          selected: endDate,
          customInput: /* @__PURE__ */ jsx$1(DatePickerButton, { defaultText: "End (optional)", ariaLabel: "End date (optional)" }),
          onChange: handleDateChange("endDate"),
          minDate: startDate
        }
      ),
      startDate && /* @__PURE__ */ jsx$1(
        TooltipIconButton,
        {
          icon: /* @__PURE__ */ jsx$1(FiXCircle, {}),
          label: "Clear dates",
          onClick: handleClearDates,
          colorScheme: "red"
        }
      )
    ] }),
    /* @__PURE__ */ jsx$1(
      InlineIconText,
      {
        icon: /* @__PURE__ */ jsx$1(FiCalendar, {}),
        text: "Candidates with potential scheduling conflicts will be highlighted with a badge.",
        query: "badge",
        description: "scheduling conflict",
        fontSize: "sm",
        iconProps: { size: "xs", bgColor: "red.300", color: "text.dark" }
      }
    )
  ] });
}
function DepartmentsAutocomplete() {
  const { searchDispatch } = useContext(SearchContext);
  const [allDepartments] = usePositions([0]);
  const [allJobs] = usePositions(allDepartments == null ? void 0 : allDepartments.map((job) => job.id));
  const allPositions = {};
  allDepartments == null ? void 0 : allDepartments.forEach((d) => {
    allPositions[d.id.toString()] = allJobs == null ? void 0 : allJobs.filter((job) => job.parentId === d.id);
  });
  const handleAutocompleteSelect = (params) => {
    const {
      item: {
        originalValue: { id: id2, parentId }
      }
    } = params;
    searchDispatch({
      type: "SET_POSITIONS",
      payload: {
        departments: [parentId.toString()],
        jobs: [id2.toString()]
      }
    });
    const filterSkills = document.getElementById("filterSkills");
    if (filterSkills) {
      filterSkills.scrollIntoView({ behavior: "smooth" });
    }
  };
  return /* @__PURE__ */ jsx$1(Box, { id: "autocompleteDepartment", children: /* @__PURE__ */ jsxs(FormControl, { children: [
    /* @__PURE__ */ jsx$1(Heading, { as: FormLabel, variant: "searchFilterTitle", mb: 4, children: "Type a job title to begin." }),
    /* @__PURE__ */ jsx$1(Box, { flex: "1 0 400px", children: /* @__PURE__ */ jsxs(AutoComplete, { onSelectOption: handleAutocompleteSelect, openOnFocus: true, children: [
      /* @__PURE__ */ jsx$1(AutoCompleteInput, { variant: "filled", placeholder: "Start typing" }),
      /* @__PURE__ */ jsx$1(AutoCompleteList, { children: Object.entries(allPositions).map(([departmentId, positions]) => {
        const department = allDepartments.find(
          (d) => d.id.toString() === departmentId
        );
        return /* @__PURE__ */ jsxs(AutoCompleteGroup, { showDivider: true, children: [
          /* @__PURE__ */ jsx$1(AutoCompleteGroupTitle, { textTransform: "capitalize", children: department == null ? void 0 : department.name }),
          positions == null ? void 0 : positions.map((job) => /* @__PURE__ */ jsx$1(
            AutoCompleteItem,
            {
              value: job,
              getValue: (job2) => job2.name,
              textTransform: "capitalize",
              children: job.name
            },
            job.id
          ))
        ] }, department == null ? void 0 : department.id);
      }) })
    ] }) }),
    /* @__PURE__ */ jsx$1(FormHelperText, { fontSize: "xs", maxW: "75%", children: "Your starting filters will be selected automatically, and you can adjust them as you like." })
  ] }) });
}
function SearchWizardView({ onSubmit }) {
  const {
    search: {
      searchWizardActive,
      filters: {
        name: name2,
        filterSet: {
          positions: { departments = [], jobs = [] }
        }
      },
      savedSearch: { id: savedSearchId }
    }
  } = useContext(SearchContext);
  const [savedSearches] = useSavedSearches();
  const [orange] = useToken("colors", ["orange.300"]);
  return /* @__PURE__ */ jsxs(
    Stack,
    {
      direction: "column",
      justifyContent: "space-between",
      height: "full",
      pt: searchWizardActive ? 4 : 0,
      transition: "padding 250ms ease",
      children: [
        searchWizardActive ? null : /* @__PURE__ */ jsx$1(Accordion, { allowToggle: true, mb: 4, defaultIndex: name2 ? 0 : void 0, children: /* @__PURE__ */ jsx$1(
          SearchFilterAccordionItem,
          {
            heading: /* @__PURE__ */ jsxs(Flex, { alignItems: "center", children: [
              /* @__PURE__ */ jsx$1(Icon, { as: FiUser, mr: 2 }),
              /* @__PURE__ */ jsx$1(Text, { as: "span", my: 0, children: "Search by Name" })
            ] }),
            headingProps: { fontSize: "md" },
            panelProps: { mb: 0, mt: -2, px: 3 },
            children: /* @__PURE__ */ jsx$1(SearchFilterName, {})
          }
        ) }),
        /* @__PURE__ */ jsx$1(
          Box,
          {
            opacity: name2 ? 0.2 : 1,
            pointerEvents: name2 ? "none" : "auto",
            transition: "opacity 250ms ease",
            children: /* @__PURE__ */ jsx$1(chakra.form, { id: "search-candidates", onSubmit, children: /* @__PURE__ */ jsxs(Stack, { gap: 6, mt: searchWizardActive ? 0 : 2, mb: 4, children: [
              /* @__PURE__ */ jsx$1(Fade, { in: !savedSearchId, unmountOnExit: true, children: /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsx$1(Box, { maxW: "lg", children: /* @__PURE__ */ jsx$1(DepartmentsAutocomplete, {}) }) }) }),
              /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsxs(Stack, { gap: 8, children: [
                /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsx$1(SearchFilterSection, { id: "filterDepartment", children: /* @__PURE__ */ jsx$1(SearchFilterDepartment, {}) }) }),
                /* @__PURE__ */ jsx$1(Fade, { in: !!departments.length, unmountOnExit: true, children: /* @__PURE__ */ jsx$1(
                  SearchFilterSection,
                  {
                    id: "filterJobs",
                    heading: "What job(s) are you looking to fill?",
                    children: /* @__PURE__ */ jsx$1(SearchFilterJobs, {})
                  }
                ) }),
                /* @__PURE__ */ jsx$1(Fade, { in: !!departments.length && !!jobs.length, unmountOnExit: true, children: /* @__PURE__ */ jsx$1(
                  SearchFilterSection,
                  {
                    id: "filterSkills",
                    heading: "What skills are you looking for?",
                    children: /* @__PURE__ */ jsx$1(SearchFilterSkills, {})
                  }
                ) }),
                /* @__PURE__ */ jsx$1(Fade, { in: !!departments.length && !!jobs.length, unmountOnExit: true, children: /* @__PURE__ */ jsx$1(
                  SearchFilterSection,
                  {
                    id: "filterDates",
                    heading: "Are you hiring for a particular date?",
                    children: /* @__PURE__ */ jsx$1(SearchFilterDates, {})
                  }
                ) }),
                /* @__PURE__ */ jsx$1(Fade, { in: searchWizardActive && jobs && !!jobs.length, unmountOnExit: true, children: /* @__PURE__ */ jsx$1(
                  SearchFilterSection,
                  {
                    id: "filterAdditional",
                    heading: "And some additional filters to refine your search:",
                    children: /* @__PURE__ */ jsx$1(AdditionalSearchFilters, {})
                  }
                ) })
              ] }) })
            ] }) })
          }
        ),
        /* @__PURE__ */ jsx$1(Spacer, {}),
        /* @__PURE__ */ jsx$1(
          Accordion,
          {
            allowToggle: true,
            mb: 4,
            defaultIndex: savedSearchId ? 0 : void 0,
            _dark: { bgColor: "blackAlpha.300" },
            _light: { bgColor: "gray.100" },
            children: /* @__PURE__ */ jsx$1(
              SearchFilterAccordionItem,
              {
                heading: /* @__PURE__ */ jsxs(Flex, { alignItems: "center", children: [
                  /* @__PURE__ */ jsx$1(
                    Icon,
                    {
                      as: FiFolder,
                      fill: (savedSearches == null ? void 0 : savedSearches.length) > 0 ? orange : "transparent",
                      mr: 2
                    }
                  ),
                  /* @__PURE__ */ jsx$1(Text, { as: "span", my: 0, children: "Saved Searches" })
                ] }),
                isDisabled: !savedSearches || !savedSearches.length,
                headingProps: { fontSize: "md" },
                panelProps: { mb: 0, px: 3, pb: 4 },
                children: /* @__PURE__ */ jsx$1(SavedSearchItemList, {})
              }
            )
          }
        )
      ]
    }
  );
}
function SearchDrawer({ isOpen, onClose }) {
  const [{ loggedInId }] = useViewer();
  const {
    search: {
      filters: {
        name: name2,
        filterSet: {
          positions: { departments, jobs },
          skills,
          unions,
          locations,
          experienceLevels,
          genderIdentities,
          racialIdentities,
          personalIdentities
        }
      },
      results: results2,
      searchWizardActive
    },
    searchDispatch
  } = useContext(SearchContext);
  const navigate = useNavigate();
  const [getSearchResults, { data: { filteredCandidates } = [], loading: searchResultsLoading }] = useCandidateSearch();
  useEffect(() => {
    if (isEqual$1(filteredCandidates, results2) || !filteredCandidates)
      return;
    searchDispatch({
      type: "SET_RESULTS",
      payload: {
        results: filteredCandidates
      }
    });
  }, [filteredCandidates]);
  const runSearch = () => {
    const positions = jobs && jobs.length > 0 ? jobs : departments;
    getSearchResults({
      variables: {
        positions,
        skills: skills && skills.length > 0 ? skills : [],
        unions: unions && unions.length > 0 ? unions : [],
        locations: locations && locations.length > 0 ? locations : [],
        experienceLevels: experienceLevels && experienceLevels.length > 0 ? experienceLevels : [],
        genderIdentities: genderIdentities && genderIdentities.length > 0 ? genderIdentities : [],
        racialIdentities: racialIdentities && racialIdentities.length > 0 ? racialIdentities : [],
        personalIdentities: personalIdentities && personalIdentities.length > 0 ? personalIdentities : [],
        searchUserId: loggedInId
      }
    }).then(() => {
      onClose();
      navigate("/results");
    }).catch((err) => {
      console.error(err);
    });
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    runSearch();
  };
  const handleSearchReset = () => {
    searchDispatch({
      type: "RESET_SEARCH_FILTERS",
      payload: {}
    });
  };
  return /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsxs(Drawer, { isOpen, onClose, placement: "top", isFullHeight: name2 ? false : true, children: [
    /* @__PURE__ */ jsx$1(ModalOverlay, {}),
    /* @__PURE__ */ jsxs(DrawerContent, { display: "flex", flexDirection: "column", height: "100%", children: [
      /* @__PURE__ */ jsx$1(
        ModalHeader,
        {
          bg: "text.dark",
          color: "text.light",
          borderBottomWidth: "2px",
          _light: {
            borderBottomColor: "text.dark"
          },
          _dark: {
            borderBottomColor: "text.light"
          },
          children: /* @__PURE__ */ jsxs(Stack, { direction: "row", justifyContent: "space-between", alignItems: "center", children: [
            /* @__PURE__ */ jsx$1(Heading, { as: "h2", variant: "contentTitle", mb: 0, color: "text.light", children: "Search" }),
            /* @__PURE__ */ jsx$1(
              IconButton,
              {
                icon: /* @__PURE__ */ jsx$1(FiX, {}),
                "aria-label": "Close",
                fontSize: "3xl",
                onClick: onClose,
                variant: "invisible"
              }
            )
          ] })
        }
      ),
      /* @__PURE__ */ jsx$1(ModalBody, { pt: 0, pb: 4, px: { base: 4, md: 8 }, my: 0, children: /* @__PURE__ */ jsx$1(SearchWizardView, { onSubmit: handleSubmit }) }),
      /* @__PURE__ */ jsx$1(Collapse, { in: searchWizardActive && !name2, unmountOnExit: false, children: /* @__PURE__ */ jsx$1(
        ModalFooter,
        {
          mt: 0,
          py: 2,
          borderTop: "1px",
          borderTopColor: "gray.300",
          _light: { bgColor: "gray.300" },
          _dark: { bgColor: "gray.100" },
          children: /* @__PURE__ */ jsxs(ButtonGroup, { w: "full", justifyContent: "flex-end", children: [
            /* @__PURE__ */ jsx$1(
              Button,
              {
                colorScheme: "green",
                onClick: handleSubmit,
                form: "search-candidates",
                isDisabled: !searchWizardActive || searchResultsLoading,
                leftIcon: searchResultsLoading ? /* @__PURE__ */ jsx$1(Spinner, {}) : /* @__PURE__ */ jsx$1(FiSearch, {}),
                isLoading: !!searchResultsLoading,
                children: "Search"
              }
            ),
            /* @__PURE__ */ jsx$1(
              Button,
              {
                isDisabled: searchResultsLoading ? true : false,
                colorScheme: "orange",
                onClick: handleSearchReset,
                leftIcon: /* @__PURE__ */ jsx$1(FiRefreshCcw, {}),
                children: "Reset"
              }
            )
          ] })
        }
      ) })
    ] })
  ] }) });
}
function ProfileNotice({
  code,
  status = "info",
  dismissExpire = 30,
  ...props
}) {
  const notice = profileNoticeAlerts[code];
  const cookieName = `profile_notice_${code}_dismissed`;
  const dismissedCookieSet = getCookie(cookieName) ? true : false;
  const { isOpen: isVisible, onClose } = useDisclosure({ defaultIsOpen: !dismissedCookieSet });
  if (!notice)
    return /* @__PURE__ */ jsx$1(Fragment, {});
  const { title, description, cta } = notice;
  const colorScheme = status === "warning" ? "orange" : void 0;
  const color2 = status === "warning" ? "text.dark" : void 0;
  const CTA = () => /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx$1(Spacer, {}),
    (cta == null ? void 0 : cta.element) ? cta.element : (cta == null ? void 0 : cta.button) ? /* @__PURE__ */ jsx$1(Button, { as: Link$1, to: cta.button.to, children: cta.button.text }) : /* @__PURE__ */ jsx$1(Fragment, {})
  ] });
  const handleCloseAlert = () => {
    onClose();
    setCookie(`profile_notice_${code}_dismissed`, 1, dismissExpire);
  };
  return /* @__PURE__ */ jsx$1(Collapse, { in: isVisible, unmountOnExit: true, children: /* @__PURE__ */ jsx$1(LightMode, { children: /* @__PURE__ */ jsx$1(
    Alert,
    {
      status: "warning",
      colorScheme,
      color: color2,
      variant: "subtle",
      fontSize: "sm",
      borderRadius: 0,
      py: 2,
      my: 0,
      justifyContent: "space-between",
      ...props,
      children: /* @__PURE__ */ jsx$1(Container, { maxW: "90vw", children: /* @__PURE__ */ jsxs(Flex, { alignItems: "center", children: [
        /* @__PURE__ */ jsx$1(AlertIcon, {}),
        /* @__PURE__ */ jsx$1(AlertTitle, { lineHeight: "unset", children: title }),
        description ? /* @__PURE__ */ jsxs(AlertDescription, { lineHeight: "unset", children: [
          description,
          " "
        ] }) : false,
        cta ? /* @__PURE__ */ jsx$1(CTA, {}) : /* @__PURE__ */ jsx$1(Spacer, {}),
        /* @__PURE__ */ jsx$1(CloseButton, { onClick: handleCloseAlert })
      ] }) })
    }
  ) }) });
}
const profileNoticeAlerts = {
  no_credits: {
    title: "You haven't added any professional credits.",
    description: /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(
        Link,
        {
          as: Link$1,
          to: "/profile/edit",
          variant: "dotted",
          color: "text.dark",
          borderBottomColor: "blackAlpha.800",
          children: "Add some credits"
        }
      ),
      " ",
      "to allow people to find you in the Directory!"
    ] })
  },
  profile_disabled: {
    title: "Your profile is currently hidden.",
    description: /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(Link, { as: Link$1, to: "/settings", color: "text.dark", textDecorationColor: "initial", children: "Take your profile public" }),
      " ",
      "to appear in searches."
    ] })
  }
};
function ProfileNotices() {
  const [{ disableProfile, loggedInId }] = useViewer();
  const [profile] = useUserProfile(loggedInId);
  if (!profile) {
    return /* @__PURE__ */ jsx$1(Fragment, {});
  }
  const { credits } = profile;
  return disableProfile ? /* @__PURE__ */ jsx$1(ProfileNotice, { code: "profile_disabled", status: "warning" }) : credits && credits.length < 1 ? /* @__PURE__ */ jsx$1(ProfileNotice, { code: "no_credits", status: "warning" }) : /* @__PURE__ */ jsx$1(Fragment, {});
}
const MUTATE_LOGOUT = gql`
	mutation Logout($input: LogoutInput = {}) {
		logout(input: $input) {
			clientMutationId
			status
		}
	}
`;
const useLogout = () => {
  const [mutation, results2] = useMutation(MUTATE_LOGOUT);
  const logoutMutation = () => {
    return mutation({
      variables: {
        input: {
          clientMutationId: "logoutMutation"
        }
      }
    });
  };
  return { logoutMutation, results: results2 };
};
function ToggleOptionSwitch({
  checked,
  id: id2,
  colorScheme = "green",
  label,
  showLabel = true,
  iconLeft,
  iconRight,
  size = "lg",
  loading,
  callback,
  children,
  ...props
}) {
  const [toggleState, setToggleState] = useState(checked);
  useEffect(() => {
    setToggleState(checked);
  }, [checked]);
  const handleChange = () => {
    setToggleState(!toggleState);
    callback();
  };
  const sizeProps = {
    fontSize: size,
    iconBoxSize: size === "lg" ? 8 : 6
  };
  return /* @__PURE__ */ jsxs(FormControl, { display: "flex", alignItems: "center", position: "relative", ...props, children: [
    iconLeft ? /* @__PURE__ */ jsx$1(Icon, { as: iconLeft, boxSize: sizeProps.iconBoxSize, p: 1, color: "inherit" }) : false,
    /* @__PURE__ */ jsx$1(
      Switch,
      {
        id: id2,
        onChange: handleChange,
        isChecked: toggleState,
        color: "inherit",
        mx: 1,
        colorScheme,
        "aria-label": label,
        isDisabled: loading
      }
    ),
    iconRight ? /* @__PURE__ */ jsx$1(Icon, { as: iconRight, boxSize: sizeProps.iconBoxSize, p: 1 }) : false,
    /* @__PURE__ */ jsxs(Box, { ml: 4, children: [
      /* @__PURE__ */ jsx$1(
        FormLabel,
        {
          htmlFor: id2,
          visibility: showLabel ? "visible" : "hidden",
          my: 0,
          fontWeight: "bold",
          children: label
        }
      ),
      children ? /* @__PURE__ */ jsx$1(FormHelperText, { my: 0, fontStyle: "italic", children }) : false
    ] })
  ] });
}
function DarkModeToggle({
  size = "md",
  showLabel = true,
  showHelperText = true,
  ...props
}) {
  const { colorMode, toggleColorMode } = useColorMode();
  return /* @__PURE__ */ jsx$1(
    ToggleOptionSwitch,
    {
      id: "darkMode",
      "aria-label": `Switch to ${colorMode === "dark" ? "light" : "dark"} mode`,
      checked: colorMode === "dark",
      callback: toggleColorMode,
      label: "Theme",
      iconLeft: FiSun,
      iconRight: FiMoon,
      size,
      showLabel,
      ...props,
      children: showHelperText ? /* @__PURE__ */ jsx$1(Subtext, { colorMode }) : /* @__PURE__ */ jsx$1(Fragment, {})
    }
  );
}
const Subtext = ({ colorMode }) => {
  const text = colorMode === "dark" ? "Dark mode" : "Light mode";
  return /* @__PURE__ */ jsx$1(Text, { as: "span", children: /* @__PURE__ */ jsx$1(Highlight, { query: [colorMode], styles: { bg: "brand.yellow", px: 1 }, children: text }) });
};
function MainMenu() {
  const [{ loggedInSlug }] = useViewer();
  const { logoutMutation } = useLogout();
  const isLargerThanMd = useBreakpointValue(
    {
      base: false,
      md: true
    },
    { ssr: false }
  );
  const { colorMode } = useColorMode();
  const logout = () => {
    logoutMutation().then(() => {
      window.location.href = "/login";
    });
  };
  return /* @__PURE__ */ jsxs(Menu, { children: [
    /* @__PURE__ */ jsx$1(
      MenuButton,
      {
        "aria-label": "Menu",
        as: IconButton,
        borderRadius: "full",
        colorScheme: "yellow",
        icon: /* @__PURE__ */ jsx$1(FiMenu, {}),
        size: "sm"
      }
    ),
    /* @__PURE__ */ jsxs(MenuList, { zIndex: "100", color: colorMode === "dark" ? "text.light" : "text.dark", children: [
      !isLargerThanMd ? /* @__PURE__ */ jsxs(MenuOptionGroup, { children: [
        /* @__PURE__ */ jsx$1(MenuItem, { as: Link$1, to: `/profile/${loggedInSlug}`, icon: /* @__PURE__ */ jsx$1(FiHome, {}), children: "My Profile" }),
        /* @__PURE__ */ jsx$1(MenuDivider, {})
      ] }) : false,
      /* @__PURE__ */ jsx$1(MenuItem, { as: Link$1, to: "/", icon: /* @__PURE__ */ jsx$1(FiCompass, {}), children: "Dashboard" }),
      /* @__PURE__ */ jsx$1(MenuItem, { as: Link$1, to: "/starred", icon: /* @__PURE__ */ jsx$1(FiStar, {}), children: "Starred Profiles" }),
      /* @__PURE__ */ jsx$1(MenuItem, { as: Link$1, to: "/searches", icon: /* @__PURE__ */ jsx$1(FiFolder, {}), children: "Your Searches" }),
      /* @__PURE__ */ jsx$1(MenuItem, { as: Link$1, to: "/settings", icon: /* @__PURE__ */ jsx$1(FiSettings, {}), children: "Settings" }),
      /* @__PURE__ */ jsx$1(MenuDivider, {}),
      /* @__PURE__ */ jsx$1(
        MenuItem,
        {
          as: Link,
          my: 0,
          href: "https://risetheatre.org",
          icon: /* @__PURE__ */ jsx$1(FiHome, {}),
          isExternal: true,
          _hover: {
            textDecoration: "none"
          },
          children: "RISE Home"
        }
      ),
      /* @__PURE__ */ jsx$1(MenuItem, { as: Link$1, to: "/help", icon: /* @__PURE__ */ jsx$1(FiHelpCircle, {}), children: "Help" }),
      /* @__PURE__ */ jsx$1(MenuDivider, {}),
      /* @__PURE__ */ jsxs(Flex, { mx: 2, justifyContent: "space-between", alignItems: "center", children: [
        /* @__PURE__ */ jsx$1(DarkModeToggle, { showLabel: false, showHelperText: false }),
        /* @__PURE__ */ jsx$1(
          IconButton,
          {
            "aria-label": "Logout",
            icon: /* @__PURE__ */ jsx$1(FiLogOut, {}),
            boxSize: 8,
            onClick: logout,
            variant: "ghost"
          }
        )
      ] })
    ] })
  ] });
}
const RiseStar = ({ ...props }) => /* @__PURE__ */ jsx$1(
  Circle,
  {
    height: "auto",
    width: "auto",
    px: 2,
    lineHeight: "normal",
    title: "separator",
    display: "inline",
    ...props,
    children: "✺"
  }
);
const Header = forwardRef((props, ref) => {
  const [{ loggedInId, loggedInSlug, starredProfiles }] = useViewer();
  const [savedSearches] = useSavedSearches();
  const [profile] = useUserProfile(loggedInId);
  const { drawerIsOpen, openDrawer, closeDrawer } = useContext(SearchDrawerContext);
  const {
    search: { results: results2 }
  } = useContext(SearchContext);
  const [orange, blue, gray, textLight, textDark] = useToken("colors", [
    "brand.orange",
    "brand.blue",
    "gray.400",
    "text.light",
    "text.dark"
  ]);
  const isLargerThanMd = useBreakpointValue(
    {
      base: false,
      md: true
    },
    { ssr: false }
  );
  const handleDrawerOpen = () => {
    openDrawer();
  };
  const StarSeparator = () => /* @__PURE__ */ jsx$1(RiseStar, { fontSize: "sm", color: gray });
  return /* @__PURE__ */ jsxs(
    Box,
    {
      ref,
      id: "header",
      w: "full",
      bg: textDark,
      color: textLight,
      position: "fixed",
      top: "0",
      borderBottomWidth: 2,
      borderBottomColor: textLight,
      zIndex: 1e3,
      children: [
        /* @__PURE__ */ jsx$1(Container, { centerContent: true, w: "full", maxW: "9xl", p: 2, children: /* @__PURE__ */ jsxs(Flex, { w: "full", justifyContent: "space-between", align: "center", children: [
          /* @__PURE__ */ jsx$1(
            Link,
            {
              as: Link$1,
              to: "/",
              my: 0,
              w: "auto",
              display: "block",
              maxW: { base: "50%", md: "350px" },
              position: "relative",
              children: /* @__PURE__ */ jsx$1(
                Image$1,
                {
                  src: logo,
                  alt: "RISE logo",
                  loading: "eager",
                  h: "auto",
                  position: "relative",
                  display: "block",
                  ml: { base: 1, md: 4 },
                  pr: 3,
                  mt: 1
                }
              )
            }
          ),
          /* @__PURE__ */ jsx$1(Spacer, {}),
          !loggedInId ? /* @__PURE__ */ jsx$1(
            Link,
            {
              as: Link$1,
              to: "https://risetheatre.org",
              my: 0,
              isExternal: true,
              flex: "0 0 auto",
              children: /* @__PURE__ */ jsx$1(Image$1, { src: circleLogo, alt: "RISE icon", loading: "eager", h: 12 })
            }
          ) : false,
          loggedInId ? /* @__PURE__ */ jsxs(Flex, { alignItems: "center", gap: 0, children: [
            /* @__PURE__ */ jsxs(
              ButtonGroup,
              {
                color: "text.light",
                mx: { base: 0, md: 2 },
                flex: "1 0 auto",
                justifyContent: "flex-end",
                size: "md",
                children: [
                  /* @__PURE__ */ jsx$1(
                    TooltipIconButton,
                    {
                      icon: /* @__PURE__ */ jsx$1(FiLink, {}),
                      label: "Network Partners",
                      as: Link$1,
                      to: "/partners"
                    }
                  ),
                  /* @__PURE__ */ jsx$1(
                    TooltipIconButton,
                    {
                      icon: /* @__PURE__ */ jsx$1(FiBriefcase, {}),
                      label: "Jobs",
                      as: Link$1,
                      to: "/jobs"
                    }
                  ),
                  /* @__PURE__ */ jsx$1(
                    TooltipIconButton,
                    {
                      icon: /* @__PURE__ */ jsx$1(FiStar, { fill: starredProfiles && starredProfiles.length ? orange : "none" }),
                      label: "Starred profiles",
                      as: Link$1,
                      to: "/stars"
                    }
                  ),
                  /* @__PURE__ */ jsx$1(
                    TooltipIconButton,
                    {
                      icon: /* @__PURE__ */ jsx$1(FiFolder, { fill: (savedSearches == null ? void 0 : savedSearches.length) ? orange : "none" }),
                      as: Link$1,
                      label: "Saved searches",
                      to: "/searches"
                    }
                  ),
                  results2.length ? /* @__PURE__ */ jsx$1(
                    TooltipIconButton,
                    {
                      as: Link$1,
                      to: "/results",
                      icon: /* @__PURE__ */ jsx$1(
                        Badge,
                        {
                          py: 1,
                          px: 2,
                          borderRadius: "full",
                          variant: "subtle",
                          colorScheme: "orange",
                          children: results2.length
                        }
                      ),
                      label: "Search results"
                    }
                  ) : false
                ]
              }
            ),
            isLargerThanMd ? /* @__PURE__ */ jsx$1(StarSeparator, {}) : null,
            /* @__PURE__ */ jsxs(
              ButtonGroup,
              {
                color: "text.light",
                mx: 2,
                flex: "1 0 auto",
                justifyContent: "flex-end",
                size: "md",
                children: [
                  /* @__PURE__ */ jsx$1(
                    TooltipIconButton,
                    {
                      icon: /* @__PURE__ */ jsx$1(FiSearch, {}),
                      onClick: handleDrawerOpen,
                      label: "Search",
                      colorScheme: "green"
                    }
                  ),
                  isLargerThanMd ? /* @__PURE__ */ jsx$1(
                    TooltipIconButton,
                    {
                      icon: /* @__PURE__ */ jsx$1(FiUser, {}),
                      as: Link$1,
                      label: "My Profile",
                      colorScheme: "blue",
                      to: `/profile/${loggedInSlug}`
                    }
                  ) : null
                ]
              }
            ),
            isLargerThanMd ? /* @__PURE__ */ jsx$1(StarSeparator, {}) : null,
            /* @__PURE__ */ jsx$1(Box, { ml: 1.5, children: /* @__PURE__ */ jsx$1(MainMenu, {}) })
          ] }) : false
        ] }) }),
        /* @__PURE__ */ jsx$1(SearchDrawer, { isOpen: drawerIsOpen, onClose: closeDrawer }),
        profile ? /* @__PURE__ */ jsx$1(ProfileNotices, {}) : false
      ]
    }
  );
});
function Shell({
  title,
  description,
  actions,
  loading,
  fullWidthTemplate,
  children,
  titleProps,
  ...props
}) {
  const fullWidthTitleProps = {
    maxWidth: "5xl",
    mx: "auto"
  };
  return loading ? /* @__PURE__ */ jsx$1(Center, { children: /* @__PURE__ */ jsx$1(Spinner, { position: "relative", top: 12 }) }) : /* @__PURE__ */ jsxs(
    Container,
    {
      maxWidth: fullWidthTemplate ? "full" : "5xl",
      pt: fullWidthTemplate ? 4 : 0,
      px: 0,
      mx: "auto",
      mt: fullWidthTemplate ? 0 : 3,
      mb: 4,
      ...props,
      children: [
        !!title || !!actions ? /* @__PURE__ */ jsxs(
          Flex,
          {
            justifyContent: "space-between",
            alignItems: "flex-end",
            gap: 2,
            flexWrap: "wrap",
            m: 0,
            p: 0,
            ...fullWidthTemplate ? fullWidthTitleProps : {},
            children: [
              title ? /* @__PURE__ */ jsx$1(
                Heading,
                {
                  variant: "pageTitle",
                  as: "h1",
                  my: 0,
                  px: 4,
                  lineHeight: "normal",
                  w: "full",
                  ...titleProps,
                  children: title
                }
              ) : null,
              actions ? /* @__PURE__ */ jsx$1(Flex, { flexWrap: "wrap", gap: 2, justifyContent: "flex-end", children: actions }) : null
            ]
          }
        ) : null,
        description ? /* @__PURE__ */ jsx$1(Text, { as: Box, ml: 1, fontSize: "sm", children: description }) : null,
        /* @__PURE__ */ jsx$1(Box, { px: 4, mx: "auto", children })
      ]
    }
  );
}
const QUERY_CANDIDATES = gql`
	query QueryCandidates($include: [Int!]!) {
		users(where: { include: $include }, first: 100) {
			nodes {
				id: databaseId
				firstName
				lastName
				selfTitle
				image
				slug
			}
		}
	}
`;
function useCandidates(include_ids) {
  var _a, _b, _c;
  const result = useQuery(QUERY_CANDIDATES, {
    variables: {
      include: include_ids
    },
    skip: !include_ids.length
  });
  const preparedCandidates = (_c = (_b = (_a = result.data) == null ? void 0 : _a.users) == null ? void 0 : _b.nodes) == null ? void 0 : _c.map(
    (candidate) => {
      const id2 = Number(candidate.id);
      return new Candidate({ ...candidate, id: id2 });
    }
  );
  return [preparedCandidates, omit$1(result, ["data"])];
}
const MUTATE_TOGGLE_STARRED_PROFILE = gql`
	mutation updateStarredProfilesMutation($toggledId: Int!) {
		updateStarredProfiles(input: { toggledId: $toggledId }) {
			starredProfiles
		}
	}
`;
const useUpdateStarredProfiles = () => {
  const [mutation, results2] = useMutation(MUTATE_TOGGLE_STARRED_PROFILE);
  const updateStarredProfilesMutation = (toggledId) => {
    return mutation({
      variables: {
        toggledId
      },
      refetchQueries: [
        {
          query: QUERY_VIEWER
        }
      ]
    });
  };
  return { updateStarredProfilesMutation, results: results2 };
};
function StarToggleIcon({ id: id2, ...props }) {
  const [{ starredProfiles }] = useViewer();
  const [isStarred, setIsStarred] = useState(false);
  const [hovered, setHovered] = useState(false);
  const {
    updateStarredProfilesMutation,
    results: { loading }
  } = useUpdateStarredProfiles();
  const { colorMode } = useColorMode();
  const [orange, lightGray, darkGray] = useToken("colors", ["orange.300", "gray.300", "gray.600"]);
  const {
    isOpen: isOpenConfirmation,
    onOpen: onOpenConfirmation,
    onClose: onCloseConfirmation
  } = useDisclosure();
  useEffect(() => {
    if (starredProfiles) {
      setIsStarred(starredProfiles.includes(id2));
    }
    return () => setIsStarred(false);
  }, [JSON.stringify(starredProfiles), id2]);
  const updateStarredProfilesHandler = () => {
    if (!id2)
      return;
    updateStarredProfilesMutation(id2).then(() => {
      onCloseConfirmation();
    });
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx$1(
      TooltipIconButton,
      {
        icon: hovered && isStarred ? /* @__PURE__ */ jsx$1(FiMinusCircle, { fill: orange }) : /* @__PURE__ */ jsx$1(
          FiStar,
          {
            color: isStarred ? orange : "",
            fill: isStarred ? orange : "transparent",
            stroke: colorMode === "dark" ? lightGray : darkGray,
            size: 20
          }
        ),
        cursor: loading ? "default !important" : "pointer",
        borderRadius: "full",
        label: isStarred ? "Unstar this profile" : "Star this profile",
        onClick: isStarred ? onOpenConfirmation : updateStarredProfilesHandler,
        mx: 2,
        isLoading: loading,
        onMouseEnter: () => setHovered(true),
        onMouseLeave: () => setHovered(false),
        ...props
      }
    ),
    /* @__PURE__ */ jsx$1(
      ConfirmActionDialog,
      {
        isOpen: isOpenConfirmation,
        onClose: onCloseConfirmation,
        confirmAction: updateStarredProfilesHandler,
        headerText: "Unstar this profile?",
        buttonsText: { confirm: "Yes", cancel: "No" },
        children: "Are you sure you want to unstar this profile? You can always star it again later."
      }
    )
  ] });
}
function CandidateAvatarBadge({ reason }) {
  if (!reason)
    return null;
  const badgeProps = {
    label: "",
    icon: void 0,
    bgColor: "",
    color: ""
  };
  switch (reason) {
    case "dateConflict":
      badgeProps.label = "Possible scheduling conflict";
      badgeProps.icon = FiCalendar;
      badgeProps.bgColor = "red.300";
      badgeProps.color = "text.dark";
      break;
    default:
      return null;
  }
  return /* @__PURE__ */ jsx$1(
    AvatarBadge,
    {
      boxSize: 6,
      borderWidth: 2,
      bg: badgeProps.bgColor,
      color: badgeProps.color,
      "aria-label": badgeProps.label,
      children: /* @__PURE__ */ jsx$1(Icon, { as: badgeProps.icon, boxSize: 3, "aria-label": "hidden" })
    }
  );
}
const CandidateItem = ({ candidate, showToggle = true, ...props }) => {
  const { id: id2, image, slug, selfTitle } = candidate || {};
  const [profile] = useUserProfile(id2 ? id2 : 0);
  const { conflictRanges } = profile || {};
  const [{ loggedInId }] = useViewer();
  const {
    search: {
      filters: {
        filterSet: { jobDates }
      }
    }
  } = useContext(SearchContext);
  const hasDateConflict = conflictRanges && jobDates && jobDates.startDate ? jobDates.hasConflict(conflictRanges) : false;
  return id2 ? /* @__PURE__ */ jsxs(Flex, { alignItems: "center", children: [
    showToggle ? /* @__PURE__ */ jsx$1(StarToggleIcon, { id: id2, isDisabled: loggedInId === id2 }) : null,
    /* @__PURE__ */ jsx$1(
      Card,
      {
        role: "article",
        "aria-labelledby": `candidate-${id2}`,
        flex: 1,
        as: Link$1,
        to: `/profile/${slug}`,
        variant: "listItem",
        ...props,
        children: /* @__PURE__ */ jsxs(
          Flex,
          {
            direction: "row",
            justifyContent: "flex-start",
            alignItems: "center",
            flexWrap: { base: "wrap", md: "nowrap" },
            gap: { base: "initial", md: 0 },
            children: [
              /* @__PURE__ */ jsx$1(
                Avatar,
                {
                  size: "md",
                  name: candidate.fullName(),
                  flex: "0 0 auto",
                  mr: 2,
                  src: image,
                  ignoreFallback: image ? true : false,
                  "aria-label": candidate.fullName() || "Profile picture",
                  children: /* @__PURE__ */ jsx$1(CandidateAvatarBadge, { reason: hasDateConflict ? "dateConflict" : void 0 })
                }
              ),
              /* @__PURE__ */ jsxs(Flex, { flex: "1", alignItems: "center", flexWrap: "wrap", children: [
                /* @__PURE__ */ jsx$1(
                  Heading,
                  {
                    as: "h3",
                    id: `candidate-${id2}`,
                    fontSize: "lg",
                    fontWeight: "normal",
                    textAlign: "left",
                    flex: { base: "0 0 100%", md: "1" },
                    mt: 0,
                    mb: { base: "4px", md: 0 },
                    children: candidate.fullName() ? candidate.fullName() : "No name"
                  }
                ),
                /* @__PURE__ */ jsx$1(
                  Text,
                  {
                    textAlign: { base: "left", md: "right" },
                    ml: { base: "0 !important", lg: "initial" },
                    my: 0,
                    lineHeight: { base: "normal" },
                    fontSize: "sm",
                    noOfLines: 2,
                    flex: { base: "0 0 100%", md: "1" },
                    style: { hyphens: "auto" },
                    wordBreak: "break-word",
                    children: selfTitle
                  }
                )
              ] })
            ]
          }
        )
      }
    )
  ] }) : /* @__PURE__ */ jsx$1(Fragment, {});
};
function StarredProfileList({
  showToggle,
  ...props
}) {
  const [{ starredProfiles }] = useViewer();
  const [profiles, { error, loading }] = useCandidates(starredProfiles ? starredProfiles : []);
  const profilesRef = useRef(starredProfiles);
  useEffect(() => {
    if (!isEqual$1(profilesRef.current, starredProfiles)) {
      profilesRef.current = starredProfiles;
    }
  }, [starredProfiles]);
  const renderedProfiles = useMemo(() => {
    var _a;
    return (_a = profilesRef.current) == null ? void 0 : _a.map((id2) => {
      const profile = profiles == null ? void 0 : profiles.find((profile2) => profile2.id === id2);
      if (!profile)
        return null;
      return /* @__PURE__ */ jsx$1(
        ListItem,
        {
          as: motion.li,
          initial: { opacity: 0 },
          animate: { opacity: 1 },
          exit: { opacity: 0 },
          children: /* @__PURE__ */ jsx$1(CandidateItem, { candidate: profile, showToggle })
        },
        id2
      );
    });
  }, [profiles]);
  return /* @__PURE__ */ jsx$1(Box, { ...props, children: !error && !loading ? /* @__PURE__ */ jsx$1(List, { alignItems: "left", h: "auto", mt: 2, w: "full", spacing: 4, children: /* @__PURE__ */ jsx$1(AnimatePresence, { children: renderedProfiles }) }) : loading ? /* @__PURE__ */ jsx$1(Spinner, {}) : error ? /* @__PURE__ */ jsx$1(ErrorAlert, { message: error.message }) : /* @__PURE__ */ jsx$1(Fragment, {}) });
}
function ShareButton({ url, ...props }) {
  const { onCopy, setValue, hasCopied } = useClipboard("");
  const toast = useToast();
  const handleShareClick = () => {
    if (navigator.share) {
      navigator.share({
        title: "Share this profile",
        text: "Check out this profile on the RISE Theatre Directory.",
        url
      }).catch((error) => {
        console.error(error);
      });
    } else {
      setValue(url);
      onCopy();
    }
  };
  useEffect(() => {
    setValue(url);
  }, [url]);
  useEffect(() => {
    if (hasCopied) {
      toast({
        title: "Copied!",
        position: "bottom",
        description: "The profile link has been copied to your clipboard.",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    }
  }, [hasCopied]);
  return /* @__PURE__ */ jsx$1(TooltipIconButton, { label: "Share", icon: /* @__PURE__ */ jsx$1(FiShare2, {}), onClick: handleShareClick, ...props });
}
const ProfilePercentComplete = ({ ...props }) => {
  const [{ loggedInId }] = useViewer();
  const percentComplete = useProfileCompletion(loggedInId);
  return /* @__PURE__ */ jsxs(Box, { children: [
    /* @__PURE__ */ jsx$1(Text, { variant: "helperText", children: "Complete your profile!" }),
    /* @__PURE__ */ jsx$1(Progress, { hasStripe: true, value: percentComplete, position: "relative", ...props }),
    /* @__PURE__ */ jsx$1(Text, { m: 0, fontSize: "xs", textAlign: "right", fontStyle: "italic", children: `${percentComplete}%` })
  ] });
};
function MiniProfileView({
  profile,
  allowStar = true,
  ...props
}) {
  const [{ loggedInSlug, loggedInId, disableProfile }] = useViewer();
  const { image, pronouns, selfTitle, homebase } = profile || {};
  const percentComplete = useProfileCompletion(loggedInId);
  const profileUrl = useProfileUrl(loggedInSlug);
  const ProfileSubtitle = ({ ...props2 }) => {
    const SelfTitle = () => {
      return /* @__PURE__ */ jsx$1(Text, { as: "span", textDecoration: "underline", children: selfTitle });
    };
    const HomeBase = () => {
      return /* @__PURE__ */ jsx$1(Text, { as: "span", textDecoration: "underline", children: homebase });
    };
    return /* @__PURE__ */ jsx$1(Heading, { size: "md", mt: 2, fontWeight: "medium", ...props2, children: selfTitle && homebase ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(SelfTitle, {}),
      " based in ",
      /* @__PURE__ */ jsx$1(HomeBase, {})
    ] }) : selfTitle || /* @__PURE__ */ jsx$1(HomeBase, {}) });
  };
  return profile ? /* @__PURE__ */ jsxs(Card, { px: 4, align: "center", ...props, children: [
    /* @__PURE__ */ jsx$1(Box, { position: "absolute", top: 2, right: 2, children: percentComplete > 30 && !disableProfile ? /* @__PURE__ */ jsx$1(ShareButton, { url: profileUrl }) : null }),
    /* @__PURE__ */ jsxs(Stack, { direction: "column", lineHeight: 1, w: "full", children: [
      image ? /* @__PURE__ */ jsx$1(Box, { textAlign: "center", children: /* @__PURE__ */ jsx$1(Avatar, { size: "superLg", src: image, name: profile.fullName() }) }) : null,
      /* @__PURE__ */ jsx$1(
        Box,
        {
          flexWrap: "wrap",
          justifyContent: { base: "center", md: "flex-start" },
          alignItems: "center",
          children: /* @__PURE__ */ jsxs(Flex, { justifyContent: "center", flexWrap: "wrap", gap: 2, children: [
            /* @__PURE__ */ jsx$1(Heading, { size: "lg", m: 0, fontWeight: "bold", lineHeight: "none", children: profile.fullName() }),
            pronouns ? /* @__PURE__ */ jsx$1(Tag, { colorScheme: "blue", size: "md", children: pronouns }) : null
          ] })
        }
      ),
      percentComplete > 30 || disableProfile ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Box, { as: ProfileSubtitle, textAlign: "center", fontSize: "md", my: 0 }),
        percentComplete < 100 && !!image ? /* @__PURE__ */ jsx$1(Box, { as: RiseStar, textAlign: "center", color: "brand.blue" }) : null,
        /* @__PURE__ */ jsxs(Box, { textAlign: "right", children: [
          percentComplete < 100 ? /* @__PURE__ */ jsx$1(ProfilePercentComplete, { colorScheme: "blue" }) : null,
          /* @__PURE__ */ jsxs(ButtonGroup, { size: "xs", mt: 2, children: [
            /* @__PURE__ */ jsx$1(
              Button,
              {
                as: Link$1,
                leftIcon: /* @__PURE__ */ jsx$1(FiUser, {}),
                to: `/profile/${loggedInSlug}`,
                colorScheme: "blue",
                my: 0,
                children: "View"
              }
            ),
            /* @__PURE__ */ jsx$1(
              Button,
              {
                as: Link$1,
                leftIcon: /* @__PURE__ */ jsx$1(FiEdit3, {}),
                to: "/profile/edit",
                colorScheme: "green",
                my: 0,
                children: "Edit"
              }
            )
          ] })
        ] })
      ] }) : /* @__PURE__ */ jsx$1(
        Button,
        {
          as: Link$1,
          leftIcon: /* @__PURE__ */ jsx$1(FiEdit3, {}),
          to: "/profile/edit",
          colorScheme: "orange",
          my: 2,
          children: "Create Your Profile"
        }
      )
    ] })
  ] }) : /* @__PURE__ */ jsx$1(Fragment, {});
}
const QUERY_GLOBAL_NOTICES = gql`
	query LatestUserNoticeQuery($last: Int = 4) {
		userNotices(last: $last) {
			nodes {
				id: databaseId
				title(format: RENDERED)
				content(format: RENDERED)
			}
		}
	}
`;
const useUserNotices = (last = 4) => {
  var _a;
  const result = useQuery(QUERY_GLOBAL_NOTICES, {
    variables: {
      last
    }
  });
  const preparedNotices = ((_a = result.data) == null ? void 0 : _a.userNotices.nodes.map((notice) => {
    const { __typename: postType, id: id2, title, content } = notice;
    return new WPPost({ postType, id: id2, title, content });
  })) || [];
  return [preparedNotices, omit$1(result, ["data"])];
};
const Widget = ({ children, ...props }) => /* @__PURE__ */ jsx$1(Box, { m: 0, ...props, children });
function ShortPost({ post, ...props }) {
  const { id: id2, title, content } = post;
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsxs(Card, { id: id2.toString(), pt: 0, px: 0, gap: 2, ...props, children: [
    /* @__PURE__ */ jsx$1(CardHeader, { px: 3, py: 2, bg: colorMode === "dark" ? "blackAlpha.300" : "blackAlpha.100", children: /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", my: 0, children: title ? title : " " }) }),
    content ? /* @__PURE__ */ jsx$1(Box, { my: 0, px: 3, children: parse$1(content) }) : null
  ] });
}
function DashboardView__Widgets() {
  const [{ loggedInId, starredProfiles }] = useViewer();
  const [notices] = useUserNotices();
  const [savedSearches] = useSavedSearches();
  const [profile, { loading }] = useUserProfile(loggedInId);
  return /* @__PURE__ */ jsxs(Grid, { templateColumns: { base: "1fr", md: "1fr 2fr" }, gap: 8, w: "full", maxW: "none", children: [
    /* @__PURE__ */ jsxs(GridItem, { as: Stack, spacing: 6, id: "dashboard-secondary", children: [
      /* @__PURE__ */ jsx$1(Widget, { children: profile ? /* @__PURE__ */ jsx$1(MiniProfileView, { profile, allowStar: false }) : loading ? /* @__PURE__ */ jsx$1(Spinner, {}) : /* @__PURE__ */ jsx$1(Fragment, {}) }),
      (savedSearches == null ? void 0 : savedSearches.length) ? /* @__PURE__ */ jsx$1(Widget, { children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Heading, { as: "h2", variant: "contentTitle", children: "Saved Searches" }),
        /* @__PURE__ */ jsx$1(SavedSearchItemList, {})
      ] }) }) : null
    ] }),
    /* @__PURE__ */ jsxs(GridItem, { as: Stack, spacing: 6, id: "dashboard-primary", children: [
      notices.length > 0 ? /* @__PURE__ */ jsx$1(Widget, { children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Heading, { as: "h2", hidden: true, children: "News" }),
        /* @__PURE__ */ jsx$1(List, { spacing: 4, children: notices.map((notice) => /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(ShortPost, { post: notice, mb: 4, as: Card }) }, notice.id)) })
      ] }) }) : null,
      (starredProfiles == null ? void 0 : starredProfiles.length) ? /* @__PURE__ */ jsx$1(Widget, { children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Heading, { as: "h2", variant: "contentTitle", children: "Following" }),
        /* @__PURE__ */ jsx$1(StarredProfileList, { showToggle: false })
      ] }) }) : null
    ] })
  ] });
}
function Dashboard() {
  return /* @__PURE__ */ jsx$1(Shell, { children: /* @__PURE__ */ jsx$1(DashboardView__Widgets, {}) });
}
var f;
!function(e) {
  e.SCRIPT_NOT_AVAILABLE = "Recaptcha script is not available";
}(f || (f = {}));
var v = createContext({ executeRecaptcha: function() {
  throw Error("GoogleReCaptcha Context has not yet been implemented, if you are using useGoogleReCaptcha hook, make sure the hook is called inside component wrapped by GoogleRecaptchaProvider");
} });
v.Consumer;
var g = function() {
  return useContext(v);
};
function w(e, t2) {
  return e(t2 = { exports: {} }, t2.exports), t2.exports;
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
}
var $ = "function" == typeof Symbol && Symbol.for, C = $ ? Symbol.for("react.element") : 60103, P = $ ? Symbol.for("react.portal") : 60106, x = $ ? Symbol.for("react.fragment") : 60107, E = $ ? Symbol.for("react.strict_mode") : 60108, R = $ ? Symbol.for("react.profiler") : 60114, M = $ ? Symbol.for("react.provider") : 60109, N = $ ? Symbol.for("react.context") : 60110, O = $ ? Symbol.for("react.async_mode") : 60111, _ = $ ? Symbol.for("react.concurrent_mode") : 60111, T = $ ? Symbol.for("react.forward_ref") : 60112, j = $ ? Symbol.for("react.suspense") : 60113, L = $ ? Symbol.for("react.suspense_list") : 60120, k = $ ? Symbol.for("react.memo") : 60115, F = $ ? Symbol.for("react.lazy") : 60116, A = $ ? Symbol.for("react.block") : 60121, V = $ ? Symbol.for("react.fundamental") : 60117, z = $ ? Symbol.for("react.responder") : 60118, G = $ ? Symbol.for("react.scope") : 60119;
function I(e) {
  if ("object" == typeof e && null !== e) {
    var t2 = e.$$typeof;
    switch (t2) {
      case C:
        switch (e = e.type) {
          case O:
          case _:
          case x:
          case R:
          case E:
          case j:
            return e;
          default:
            switch (e = e && e.$$typeof) {
              case N:
              case T:
              case F:
              case k:
              case M:
                return e;
              default:
                return t2;
            }
        }
      case P:
        return t2;
    }
  }
}
function D(e) {
  return I(e) === _;
}
var q = { AsyncMode: O, ConcurrentMode: _, ContextConsumer: N, ContextProvider: M, Element: C, ForwardRef: T, Fragment: x, Lazy: F, Memo: k, Portal: P, Profiler: R, StrictMode: E, Suspense: j, isAsyncMode: function(e) {
  return D(e) || I(e) === O;
}, isConcurrentMode: D, isContextConsumer: function(e) {
  return I(e) === N;
}, isContextProvider: function(e) {
  return I(e) === M;
}, isElement: function(e) {
  return "object" == typeof e && null !== e && e.$$typeof === C;
}, isForwardRef: function(e) {
  return I(e) === T;
}, isFragment: function(e) {
  return I(e) === x;
}, isLazy: function(e) {
  return I(e) === F;
}, isMemo: function(e) {
  return I(e) === k;
}, isPortal: function(e) {
  return I(e) === P;
}, isProfiler: function(e) {
  return I(e) === R;
}, isStrictMode: function(e) {
  return I(e) === E;
}, isSuspense: function(e) {
  return I(e) === j;
}, isValidElementType: function(e) {
  return "string" == typeof e || "function" == typeof e || e === x || e === _ || e === R || e === E || e === j || e === L || "object" == typeof e && null !== e && (e.$$typeof === F || e.$$typeof === k || e.$$typeof === M || e.$$typeof === N || e.$$typeof === T || e.$$typeof === V || e.$$typeof === z || e.$$typeof === G || e.$$typeof === A);
}, typeOf: I }, B = w(function(e, t2) {
}), J = (B.AsyncMode, B.ConcurrentMode, B.ContextConsumer, B.ContextProvider, B.Element, B.ForwardRef, B.Fragment, B.Lazy, B.Memo, B.Portal, B.Profiler, B.StrictMode, B.Suspense, B.isAsyncMode, B.isConcurrentMode, B.isContextConsumer, B.isContextProvider, B.isElement, B.isForwardRef, B.isFragment, B.isLazy, B.isMemo, B.isPortal, B.isProfiler, B.isStrictMode, B.isSuspense, B.isValidElementType, B.typeOf, w(function(e) {
  e.exports = q;
})), H = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, Q = {};
Q[J.ForwardRef] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, Q[J.Memo] = H;
const QUERY_PAGES = gql`
	query PagesQuery($id: Int) {
		pages(where: { id: $id }) {
			nodes {
				id: databaseId
				title
				content(format: RENDERED)
			}
		}
	}
`;
const usePageById = (id2) => {
  var _a;
  const result = useQuery(QUERY_PAGES, {
    variables: {
      id: id2
    }
  });
  if (!((_a = result.data) == null ? void 0 : _a.pages)) {
    return [null, omit$1(result, ["data"])];
  }
  const { id: postId, title, content } = result.data.pages.nodes[0];
  const post = new WPPost({
    id: postId,
    title,
    content,
    postType: "page"
  });
  return [post, omit$1(result, ["data"])];
};
function PageView({
  postId,
  pageObject,
  titleProps,
  ...props
}) {
  const [pageById] = usePageById(!!pageObject ? 0 : Number(postId));
  const page = pageObject || pageById;
  const content = (page == null ? void 0 : page.content) ? parse$1(page.content) : null;
  return /* @__PURE__ */ jsxs(Container, { variant: "pageContent", className: "wp-post-content", ...props, children: [
    /* @__PURE__ */ jsx$1(Heading, { as: "h1", ...titleProps, children: page == null ? void 0 : page.title }),
    content
  ] });
}
const MUTATE_LOGIN = gql`
	mutation Login($login: String!, $password: String!, $reCaptchaToken: String!) {
		loginWithCookiesAndReCaptcha(
			input: { login: $login, password: $password, reCaptchaToken: $reCaptchaToken }
		) {
			status
		}
	}
`;
const useLogin = () => {
  const [mutation, results2] = useMutation(MUTATE_LOGIN);
  const loginMutation = ({ login, password, reCaptchaToken }) => {
    return mutation({
      variables: {
        clientMutationId: "loginMutation",
        login,
        password,
        reCaptchaToken
      },
      refetchQueries: [{ query: QUERY_VIEWER }]
    });
  };
  return { loginMutation, results: results2 };
};
function LoginView$1({ alert, alertStatus, signInTitle }) {
  const [credentials, setCredentials] = useState({
    login: "",
    password: "",
    reCaptchaToken: ""
  });
  const [errorCode, setErrorCode] = useState("");
  const [isLargerThanMd] = useMediaQuery("(min-width: 48rem)");
  const { isOpen, onOpen, onClose } = useDisclosure();
  const {
    loginMutation,
    results: { loading: submitLoading }
  } = useLogin();
  const { executeRecaptcha } = g();
  const errorMessage = useErrorMessage(errorCode);
  const handleInputChange = (e) => {
    setCredentials({
      ...credentials,
      [e.target.name]: e.target.value
    });
  };
  const handleLoginSubmit = (e) => {
    e.preventDefault();
    handleReCaptchaVerify({ label: "login", executeRecaptcha }).then((token2) => {
      if (!token2) {
        setErrorCode("recaptcha_error");
        return;
      }
      loginMutation({ ...credentials, reCaptchaToken: token2 }).catch(
        (errors) => {
          setErrorCode(errors.message);
        }
      );
    }).catch(() => {
      setErrorCode("recaptcha_error");
    });
  };
  const sanitizedAlertStatus = alertStatus === "error" ? "error" : "success";
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsxs(Flex, { alignItems: "center", gap: 8, flexWrap: "wrap", children: [
      /* @__PURE__ */ jsx$1(Box, { flex: "1", children: /* @__PURE__ */ jsxs(Box, { maxWidth: "md", children: [
        signInTitle ? /* @__PURE__ */ jsx$1(Heading, { variant: "pageTitle", as: "h1", my: 0, lineHeight: "normal", children: "Sign in to RISE" }) : false,
        /* @__PURE__ */ jsx$1(Text, { fontSize: "lg", children: "You'll need an account to create a profile or to search for candidates." }),
        /* @__PURE__ */ jsx$1(Divider, { my: 4 }),
        /* @__PURE__ */ jsxs(Box, { flex: "1 1 auto", children: [
          alert ? /* @__PURE__ */ jsx$1(Alert, { status: sanitizedAlertStatus, children: alert }) : false,
          /* @__PURE__ */ jsxs(chakra.form, { onSubmit: handleLoginSubmit, children: [
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: credentials.login,
                name: "login",
                label: "Email",
                autoComplete: "username",
                isRequired: true,
                onChange: handleInputChange,
                error: ["invalid_username", "invalid_email", "invalid_account"].includes(errorCode) ? errorMessage : "",
                inputProps: {
                  autoComplete: "username",
                  fontSize: "lg"
                }
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: credentials.password,
                name: "password",
                label: "Password",
                isRequired: true,
                onChange: handleInputChange,
                error: errorCode === "incorrect_password" ? errorMessage : "",
                inputProps: {
                  type: "password",
                  autoComplete: "current-password",
                  fontSize: "lg"
                }
              }
            ),
            /* @__PURE__ */ jsxs(
              Flex,
              {
                gap: 4,
                alignItems: "center",
                justifyContent: "space-between",
                mt: 4,
                flexWrap: "wrap",
                children: [
                  /* @__PURE__ */ jsx$1(Button, { type: "submit", colorScheme: "blue", px: 6, isLoading: !!submitLoading, children: "Sign In" }),
                  /* @__PURE__ */ jsx$1(Link, { as: Link$1, to: "/lost-password", fontSize: "sm", children: "Lost your password?" })
                ]
              }
            ),
            /* @__PURE__ */ jsx$1(Box, { id: "recaptcha-badge" }),
            /* @__PURE__ */ jsx$1(Divider, {}),
            /* @__PURE__ */ jsxs(Box, { textAlign: "center", flex: "1", children: [
              /* @__PURE__ */ jsx$1(Heading, { variant: "pageSubtitle", fontSize: "xl", children: "Don't have an account?" }),
              /* @__PURE__ */ jsx$1(
                Button,
                {
                  as: Link$1,
                  to: "/register",
                  borderRadius: { base: "md", md: "lg" },
                  colorScheme: "green",
                  color: "text.dark",
                  size: "lg",
                  children: "Join Now"
                }
              )
            ] })
          ] })
        ] })
      ] }) }),
      !isLargerThanMd ? /* @__PURE__ */ jsx$1(Divider, { my: 0 }) : false,
      /* @__PURE__ */ jsx$1(Box, { textAlign: "center", flex: "1", pb: 2, children: /* @__PURE__ */ jsxs(Stack, { textAlign: "center", gap: 6, children: [
        /* @__PURE__ */ jsxs(Heading, { as: "h2", my: 0, fontSize: { base: "2xl", md: "3xl" }, children: [
          /* @__PURE__ */ jsx$1(Highlight, { query: ["project"], styles: { bg: "blue.200" }, children: "Find your next project" }),
          /* @__PURE__ */ jsx$1("br", {}),
          /* @__PURE__ */ jsx$1(Highlight, { query: ["team"], styles: { bg: "green.200" }, children: "Discover your next team" })
        ] }),
        /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsx$1(Button, { onClick: onOpen, size: "xxl", colorScheme: "yellow", children: `What is RISE? ${decodeString("&raquo;")}` }) })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxs(
      Drawer,
      {
        placement: "right",
        size: { base: "full", md: "md" },
        onClose,
        closeOnEsc: true,
        isOpen,
        isFullHeight: false,
        children: [
          /* @__PURE__ */ jsx$1(ModalOverlay, {}),
          /* @__PURE__ */ jsxs(DrawerContent, { display: "flex", flexDirection: "column", height: "100%", children: [
            /* @__PURE__ */ jsx$1(ModalHeader, { pt: 2, pb: 1, px: 2, textAlign: "right", children: /* @__PURE__ */ jsx$1(
              IconButton,
              {
                onClick: onClose,
                borderRadius: "full",
                fontSize: "xl",
                icon: /* @__PURE__ */ jsx$1(FiX, {}),
                "aria-label": "Close"
              }
            ) }),
            /* @__PURE__ */ jsx$1(ModalBody, { py: 0, pb: 2, children: /* @__PURE__ */ jsxs(Box, { textAlign: "center", children: [
              /* @__PURE__ */ jsx$1(PageView, { postId: "12238", mt: 0, pt: 0 }),
              /* @__PURE__ */ jsxs(
                Button,
                {
                  as: Link,
                  href: "https://risetheatre.org",
                  isExternal: true,
                  colorScheme: "yellow",
                  size: "lg",
                  mt: 6,
                  mb: 24,
                  children: [
                    "Learn about RISE Theatre",
                    " ",
                    /* @__PURE__ */ jsx$1(Icon, { as: FiExternalLink, "aria-label": "external link", pl: 1 })
                  ]
                }
              )
            ] }) })
          ] })
        ]
      }
    )
  ] });
}
function Login() {
  const navigate = useNavigate();
  const [params] = useSearchParams();
  const alert = params.get("alert");
  const alertStatus = params.get("alertStatus");
  const [{ loggedInId }] = useViewer();
  useEffect(() => {
    if (loggedInId) {
      navigate("/");
    }
  });
  return /* @__PURE__ */ jsx$1(Shell, { title: "Sign in to RISE", children: /* @__PURE__ */ jsx$1(LoginView$1, { alert: alert ? alert : "", alertStatus: alertStatus ? alertStatus : "" }) });
}
const MUTATE_SEND_PASSWORD_RESET = gql`
	mutation SendPasswordResetEmailMutation(
		$input: SendPasswordResetEmailWithReCaptchaInput = { reCaptchaToken: "", username: "" }
	) {
		sendPasswordResetEmailWithReCaptcha(input: $input) {
			clientMutationId
			success
		}
	}
`;
const useSendPasswordResetEmail = () => {
  const [mutation, results2] = useMutation(MUTATE_SEND_PASSWORD_RESET);
  const sendPasswordResetEmailMutation = ({
    username,
    reCaptchaToken
  }) => {
    return mutation({
      variables: {
        input: {
          clientMutationId: "sendPasswordResetEmailMutation",
          username,
          reCaptchaToken
        }
      }
    });
  };
  return { sendPasswordResetEmailMutation, results: results2 };
};
function LoginView() {
  const [username, setUsername] = useState("");
  const [errorCode, setErrorCode] = useState("");
  const { executeRecaptcha } = g();
  const {
    sendPasswordResetEmailMutation,
    results: { loading: submitLoading }
  } = useSendPasswordResetEmail();
  const handleInputChange = (e) => {
    setUsername(e.target.value);
  };
  const toast = useToast();
  const navigate = useNavigate();
  const errorMessage = useErrorMessage(errorCode);
  const handleSubmit = (e) => {
    e.preventDefault();
    handleReCaptchaVerify({ label: "resetPassword", executeRecaptcha }).then((token2) => {
      if (!token2) {
        setErrorCode("recaptcha_error");
        return;
      }
      sendPasswordResetEmailMutation({ username, reCaptchaToken: token2 }).then(() => {
        toast({
          title: "Email sent",
          description: "Please check your inbox for reset instructions.",
          status: "success",
          duration: 3e3,
          isClosable: true,
          position: "bottom"
        });
      }).then(() => {
        navigate("/");
      }).catch((err) => {
        setErrorCode(err.message);
      });
    });
  };
  return /* @__PURE__ */ jsxs(Container, { maxW: "2xl", mt: 6, children: [
    /* @__PURE__ */ jsx$1(Heading, { as: "h2", size: "xl", mb: 4, children: "Lost password" }),
    /* @__PURE__ */ jsx$1(Text, { fontSize: "md", children: "Please enter your email address, and we'll send you a link to reset your password." }),
    /* @__PURE__ */ jsx$1(Box, { my: 4, children: /* @__PURE__ */ jsx$1(chakra.form, { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxs(Flex, { gap: 2, children: [
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          value: username,
          name: "username",
          label: "Email",
          isRequired: true,
          onChange: handleInputChange,
          inputProps: {
            autoComplete: "username"
          },
          error: errorMessage
        }
      ),
      /* @__PURE__ */ jsx$1(Button, { type: "submit", colorScheme: "blue", px: 6, isLoading: !!submitLoading, children: "Submit" })
    ] }) }) })
  ] });
}
function LostPassword() {
  return /* @__PURE__ */ jsx$1(Shell, { children: /* @__PURE__ */ jsx$1(LoginView, {}) });
}
const MUTATE_RESET_USER_PASSWORD = gql`
	mutation ResetUserPassword($key: String!, $password: String!, $login: String!) {
		resetUserPassword(
			input: { key: $key, password: $password, login: $login, clientMutationId: "" }
		) {
			clientMutationId
			user {
				id
			}
		}
	}
`;
const useResetUserPassword = () => {
  const [mutation, results2] = useMutation(MUTATE_RESET_USER_PASSWORD);
  const resetUserPasswordMutation = (key, login, password) => {
    return mutation({
      variables: {
        clientMutationId: "resetUserPasswordMutation",
        key,
        login,
        password
      }
    });
  };
  return { resetUserPasswordMutation, results: results2 };
};
function ResetPasswordView({ token: token2, login }) {
  const [userFields, setUserFields] = useState({
    newPassword: "",
    confirmPassword: ""
  });
  const { newPassword, confirmPassword } = userFields;
  const [passwordsMatch, setPasswordsMatch] = useState(true);
  const [passwordStrongEnough, setPasswordStrongEnough] = useState(false);
  const [formIsValid, setFormIsValid] = useState(false);
  const [errorCode, setErrorCode] = useState("");
  const {
    resetUserPasswordMutation,
    results: { loading: submitLoading }
  } = useResetUserPassword();
  const toast = useToast();
  const navigate = useNavigate();
  const errorMessage = useErrorMessage(errorCode);
  const newPasswordStrength = useValidatePassword(newPassword);
  useEffect(() => {
    setFormIsValid(false);
    if (!passwordsMatch)
      return setErrorCode("password_mismatch");
    else if (newPassword.length && !passwordStrongEnough)
      return setErrorCode("password_too_weak");
    else
      setFormIsValid(true);
    setErrorCode("");
  }, [passwordsMatch, newPassword, confirmPassword, passwordStrongEnough]);
  useEffect(() => {
    const timer = setTimeout(() => {
      setPasswordsMatch(newPassword === confirmPassword);
      setPasswordStrongEnough(newPasswordStrength === "strong");
    }, 500);
    return () => clearTimeout(timer);
  }, [newPassword, confirmPassword]);
  const handleInputChange = (e) => {
    setUserFields({
      ...userFields,
      [e.target.name]: e.target.value
    });
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!token2 || !login || !newPassword || !passwordsMatch)
      return;
    resetUserPasswordMutation(token2, login, newPassword).then(() => {
      toast({
        title: "Success!",
        description: "Please login with your new password.",
        status: "success",
        duration: 3e3,
        isClosable: true,
        position: "bottom"
      });
    }).then(() => {
      navigate("/login");
    }).catch((errors) => setErrorCode(errors.message));
  };
  return /* @__PURE__ */ jsxs(Container, { bg: "whiteAlpha.500", borderRadius: "lg", w: "full", children: [
    /* @__PURE__ */ jsx$1(Heading, { as: "h3", size: "lg", children: "Choose your new password." }),
    /* @__PURE__ */ jsx$1(Box, { mt: 2, children: /* @__PURE__ */ jsxs(chakra.form, { onSubmit: handleSubmit, children: [
      /* @__PURE__ */ jsxs(Stack, { direction: "row", spacing: 6, children: [
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: newPassword,
            name: "newPassword",
            id: "newPassword",
            variant: "filled",
            label: "Passwords must have at least one lowercase letter, one uppercase letter, one number, and one special character.",
            error: errorCode,
            isRequired: true,
            onChange: handleInputChange,
            inputProps: {
              type: "password",
              autoComplete: "new-password"
            }
          }
        ),
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: confirmPassword,
            name: "confirmPassword",
            id: "confirmPassword",
            type: "password",
            variant: "filled",
            label: "Confirm your password",
            isRequired: true,
            onChange: handleInputChange,
            inputProps: {
              type: "password",
              autoComplete: "new-password"
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(Box, { mt: 4, children: [
        /* @__PURE__ */ jsx$1(
          Button,
          {
            type: "submit",
            colorScheme: "orange",
            isDisabled: !formIsValid || submitLoading,
            isLoading: !!submitLoading,
            children: "Reset password"
          }
        ),
        /* @__PURE__ */ jsx$1(FormErrorMessage, { mt: 0, children: errorMessage })
      ] })
    ] }) })
  ] });
}
function ResetPassword() {
  const [params] = useSearchParams();
  const key = params.get("key");
  const login = params.get("login");
  return /* @__PURE__ */ jsx$1(Shell, { children: key && login ? /* @__PURE__ */ jsx$1(ResetPasswordView, { token: key, login }) : /* @__PURE__ */ jsx$1(Text, { size: "md", children: "Invalid password reset link." }) });
}
const MUTATE_REGISTER_USER = gql`
	mutation RegisterUserMutation(
		$input: RegisterUserWithReCaptchaInput = { reCaptchaToken: "", username: "" }
	) {
		registerUserWithReCaptcha(input: $input) {
			user {
				databaseId
			}
			clientMutationId
		}
	}
`;
const useRegisterUser = () => {
  const [mutation, results2] = useMutation(MUTATE_REGISTER_USER);
  const registerUserMutation = (user) => {
    const { email, firstName, lastName, password, confirmPassword, reCaptchaToken } = user;
    if (password !== confirmPassword) {
      throw new Error("Passwords do not match");
    }
    return mutation({
      variables: {
        input: {
          username: email,
          email,
          lastName,
          firstName,
          password,
          reCaptchaToken
        }
      }
    });
  };
  return { registerUserMutation, results: results2 };
};
function LoginLink({ ...props }) {
  return /* @__PURE__ */ jsxs(Flex, { alignItems: "center", textAlign: "right", flexWrap: "wrap", ...props, children: [
    /* @__PURE__ */ jsxs(Heading, { size: "sm", mr: 2, mb: 0, children: [
      "Already have ",
      /* @__PURE__ */ jsx$1("br", {}),
      "an account?"
    ] }),
    /* @__PURE__ */ jsx$1(Button, { as: Link$1, to: "/login", colorScheme: "blue", tabIndex: 9, children: "Back To Login" })
  ] });
}
const RequiredAsterisk = ({ ...props }) => {
  return /* @__PURE__ */ jsx$1(chakra.span, { color: "red.300", ml: 1, ...props, children: "*" });
};
function RegisterView() {
  const [userFields, setUserFields] = useState({
    email: "",
    firstName: "",
    lastName: "",
    password: "",
    confirmPassword: "",
    reCaptchaToken: ""
  });
  const { email, firstName, lastName, password, confirmPassword } = userFields;
  const [termsAccepted, setTermsAccepted] = useState(false);
  const [ofAge, setOfAge] = useState(false);
  const [passwordsMatch, setPasswordsMatch] = useState(true);
  const [passwordStrongEnough, setPasswordStrongEnough] = useState(false);
  const [formIsValid, setFormIsValid] = useState(false);
  const [errorCode, setErrorCode] = useState("");
  const [page, { pageLoading, pageError }] = usePageById(576);
  const passwordStrength2 = useValidatePassword(password);
  const { executeRecaptcha } = g();
  const [isLargerThanMd] = useMediaQuery("(min-width: 48rem)");
  const {
    registerUserMutation,
    results: { loading: submitLoading }
  } = useRegisterUser();
  useEffect(() => {
    if (!passwordsMatch)
      return setErrorCode("password_mismatch");
    else if (password.length && !passwordStrongEnough)
      return setErrorCode("password_too_weak");
    else
      setFormIsValid(
        email.length > 0 && firstName.length > 0 && lastName.length > 0 && password.length > 0 && confirmPassword.length > 0 && passwordStrongEnough && passwordsMatch && ofAge && termsAccepted
      );
    setErrorCode("");
  }, [
    email,
    firstName,
    lastName,
    password,
    confirmPassword,
    passwordStrongEnough,
    passwordsMatch,
    ofAge,
    termsAccepted
  ]);
  useEffect(() => {
    const timer = setTimeout(() => {
      setPasswordStrongEnough(passwordStrength2 === "strong");
      setPasswordsMatch(password === confirmPassword);
    }, 500);
    return () => clearTimeout(timer);
  }, [password, confirmPassword]);
  const handleInputChange = (e) => {
    setUserFields({
      ...userFields,
      [e.target.name]: e.target.value
    });
  };
  const navigate = useNavigate();
  const toast = useToast();
  const errorMessage = useErrorMessage(errorCode);
  const handleSubmit = (e) => {
    e.preventDefault();
    handleReCaptchaVerify({ label: "registerUser", executeRecaptcha }).then((token2) => {
      if (!token2) {
        setErrorCode("recaptcha_error");
        return;
      }
      registerUserMutation({ ...userFields, reCaptchaToken: token2 }).then(() => {
        toast({
          title: "Account created!",
          description: "Please check your inbox for confirmation.",
          status: "success",
          duration: 3e3,
          isClosable: true,
          position: "bottom"
        });
      }).then(() => {
        navigate("/login");
      }).catch((errors) => setErrorCode(errors.message));
    });
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    pageLoading ? /* @__PURE__ */ jsx$1(Spinner, {}) : pageError ? "Error loading content" : page ? /* @__PURE__ */ jsx$1(Box, { my: 4, children: page.content }) : false,
    /* @__PURE__ */ jsx$1(Divider, { my: 6 }),
    /* @__PURE__ */ jsx$1(Heading, { as: "h2", variant: "contentTitle", children: "Create an account" }),
    /* @__PURE__ */ jsxs(chakra.form, { onSubmit: handleSubmit, children: [
      /* @__PURE__ */ jsxs(Stack, { direction: "row", spacing: 6, children: [
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: firstName,
            name: "firstName",
            isRequired: true,
            onChange: handleInputChange,
            flex: "1",
            label: "First name",
            inputProps: {
              size: "xl",
              autoComplete: "given-name",
              tabIndex: 1
            }
          }
        ),
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: lastName,
            name: "lastName",
            isRequired: true,
            onChange: handleInputChange,
            flex: "1",
            label: "Last name",
            inputProps: {
              size: "xl",
              autoComplete: "family-name",
              tabIndex: 2
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          value: email,
          name: "email",
          id: "email",
          type: "email",
          variant: "filled",
          label: "Email address",
          error: errorCode !== "password_too_weak" && errorCode !== "password_mismatch" && errorCode ? errorMessage : "",
          isRequired: true,
          onChange: handleInputChange,
          inputProps: {
            size: "xl",
            autoComplete: "email",
            tabIndex: 3
          }
        }
      ),
      /* @__PURE__ */ jsxs(Stack, { direction: "row", spacing: 6, flexWrap: "wrap", children: [
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: password,
            name: "password",
            id: "password",
            type: "password",
            variant: "filled",
            label: "Password",
            helperText: "Passwords must have at least one lowercase letter, one uppercase letter, one number, and one special character.",
            flex: 1,
            isRequired: true,
            error: errorCode && errorCode === "password_too_weak" ? errorMessage : "",
            onChange: handleInputChange,
            inputProps: {
              size: "xl",
              type: "password",
              autoComplete: "new-password",
              tabIndex: 4
            }
          }
        ),
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: confirmPassword,
            name: "confirmPassword",
            id: "confirmPassword",
            type: "password",
            variant: "filled",
            label: "Confirm your password",
            flex: 1,
            isRequired: true,
            error: errorCode && errorCode === "password_mismatch" ? errorMessage : "",
            onChange: handleInputChange,
            inputProps: {
              size: "xl",
              type: "password",
              autoComplete: "new-password",
              tabIndex: 5
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(
        Flex,
        {
          justifyContent: "space-between",
          alignItems: "flex-end",
          mt: 2,
          flex: "0 0 auto",
          flexWrap: "wrap",
          gap: 8,
          children: [
            /* @__PURE__ */ jsxs(Box, { mt: 4, pr: 8, children: [
              /* @__PURE__ */ jsx$1(FormControl, { children: /* @__PURE__ */ jsxs(
                Checkbox,
                {
                  size: "sm",
                  w: "full",
                  isRequired: true,
                  onChange: () => setOfAge(!ofAge),
                  tabIndex: 6,
                  children: [
                    "I am over 18 years of age.",
                    /* @__PURE__ */ jsx$1(RequiredAsterisk, {})
                  ]
                }
              ) }),
              /* @__PURE__ */ jsx$1(FormControl, { children: /* @__PURE__ */ jsxs(
                Checkbox,
                {
                  size: "sm",
                  w: "full",
                  isRequired: true,
                  onChange: () => setTermsAccepted(!termsAccepted),
                  tabIndex: 7,
                  children: [
                    "I have read and accept the RISE Theatre Directory",
                    " ",
                    /* @__PURE__ */ jsx$1(Link, { as: Link$1, to: "http://risetheatre.org/terms-conditions", isExternal: true, children: "Terms and Conditions" }),
                    " ",
                    "and",
                    " ",
                    /* @__PURE__ */ jsx$1(Link, { as: Link$1, to: "http://risetheatre.org/privacy-policy", isExternal: true, children: "Privacy Policy" }),
                    ".",
                    /* @__PURE__ */ jsx$1(RequiredAsterisk, {})
                  ]
                }
              ) }),
              /* @__PURE__ */ jsx$1(
                Button,
                {
                  type: "submit",
                  colorScheme: "orange",
                  isDisabled: !formIsValid || submitLoading,
                  mt: 4,
                  tabIndex: 8,
                  isLoading: !!submitLoading,
                  children: "Create account"
                }
              )
            ] }),
            !isLargerThanMd && /* @__PURE__ */ jsx$1(LoginLink, { width: "full", justifyContent: "flex-end" })
          ]
        }
      )
    ] })
  ] });
}
function Register() {
  const [isLargerThanMd] = useMediaQuery("(min-width: 48rem)");
  const Button2 = () => isLargerThanMd ? /* @__PURE__ */ jsx$1(LoginLink, {}) : /* @__PURE__ */ jsx$1(Fragment, {});
  return /* @__PURE__ */ jsx$1(Shell, { title: "Join the Directory", actions: /* @__PURE__ */ jsx$1(Button2, {}), children: /* @__PURE__ */ jsx$1(RegisterView, {}) });
}
const QUERY_USER_ID = gql`
	query QueryUserIdBySlug($slug: String!) {
		userIdBySlug(slug: $slug)
	}
`;
const useUserIdBySlug = (slug) => {
  const result = useQuery(QUERY_USER_ID, {
    variables: {
      slug
    }
  });
  const { userIdBySlug: userId } = result.data || {};
  return [userId, omit$1(result, ["data"])];
};
const QUERY_RESUME_PREVIEW = gql`
	query MediaItemQuery($id: ID!) {
		mediaItem(id: $id, idType: SOURCE_URL) {
			sizes(size: THUMBNAIL)
			sourceUrl
		}
	}
`;
const useResumePreview = (resumeUrl) => {
  const result = useQuery(QUERY_RESUME_PREVIEW, {
    variables: {
      id: resumeUrl
    }
  });
  const { mediaItem } = result.data || {};
  return { mediaItem, result: omit$1(result, ["data"]) };
};
function WrapWithIcon({
  icon,
  iconProps,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs(chakra.div, { display: "flex", my: 2, alignItems: "center", ...props, children: [
    icon ? /* @__PURE__ */ jsx$1(Icon, { as: icon, mr: 2, ...iconProps }) : null,
    children
  ] });
}
function HeadingCenterline({
  lineColor,
  children,
  headingAs,
  headingProps,
  ...props
}) {
  return /* @__PURE__ */ jsxs(
    Flex,
    {
      alignItems: "center",
      w: "full",
      h: "max-content",
      pos: "relative",
      textAlign: "left",
      ...props,
      children: [
        /* @__PURE__ */ jsx$1(Box, { h: "6px", top: "38%", bgColor: lineColor, pos: "absolute", w: "full", zIndex: "1" }),
        /* @__PURE__ */ jsx$1(Heading, { as: headingAs ? headingAs : "h3", variant: "centerline", ...headingProps, children })
      ]
    }
  );
}
function ProfileStackItem({
  title,
  centerlineColor,
  children,
  ...props
}) {
  const SectionTitle = () => {
    return centerlineColor ? /* @__PURE__ */ jsx$1(HeadingCenterline, { lineColor: centerlineColor, mb: 1, children: title }) : /* @__PURE__ */ jsx$1(Heading, { as: "h3", variant: "pageSubtitle", children: title });
  };
  return /* @__PURE__ */ jsxs(Box, { mb: 2, ...props, children: [
    title ? /* @__PURE__ */ jsx$1(SectionTitle, {}) : false,
    children
  ] });
}
function ResumePreviewModal({
  resumePreview,
  resumeLink,
  previewIcon = true,
  ...props
}) {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const { colorMode } = useColorMode();
  return resumePreview && resumeLink ? /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Box, { pos: "relative", ...props, children: [
      previewIcon ? /* @__PURE__ */ jsx$1(
        Flex,
        {
          bg: "blackAlpha.300",
          pos: "absolute",
          w: "full",
          h: "full",
          alignItems: "center",
          justifyContent: "center",
          onClick: onOpen,
          cursor: "pointer",
          transition: "all 200ms ease",
          color: "whiteAlpha.800",
          _hover: {
            bg: "blackAlpha.50",
            color: "blackAlpha.800"
          },
          children: /* @__PURE__ */ jsx$1(Icon, { as: FiZoomIn, boxSize: 10 })
        }
      ) : false,
      /* @__PURE__ */ jsx$1(
        Image$1,
        {
          src: resumePreview,
          alt: "Resume preview",
          w: "full",
          h: "auto",
          loading: "eager",
          fit: "cover",
          onClick: previewIcon ? void 0 : onOpen,
          cursor: previewIcon ? void 0 : "pointer",
          borderRadius: "md"
        }
      )
    ] }),
    /* @__PURE__ */ jsxs(Modal, { isOpen, onClose, children: [
      /* @__PURE__ */ jsx$1(ModalOverlay, {}),
      /* @__PURE__ */ jsxs(ModalContent, { children: [
        /* @__PURE__ */ jsx$1(ModalHeader, { children: "Resume Preview" }),
        /* @__PURE__ */ jsx$1(ModalCloseButton, {}),
        /* @__PURE__ */ jsxs(ModalBody, { bgColor: colorMode === "dark" ? "gray" : "blackAlpha.200", pt: 4, children: [
          /* @__PURE__ */ jsx$1(
            Image$1,
            {
              src: resumePreview,
              alt: `Profile picture`,
              loading: "eager",
              fit: "cover",
              borderRadius: "md",
              w: "full"
            }
          ),
          /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", children: "Previewing the first page only." })
        ] }),
        /* @__PURE__ */ jsx$1(ModalFooter, { children: /* @__PURE__ */ jsx$1(
          Button,
          {
            leftIcon: /* @__PURE__ */ jsx$1(FiDownload, {}),
            colorScheme: "green",
            as: Link,
            href: resumeLink,
            my: 0,
            download: true,
            children: "Save"
          }
        ) })
      ] })
    ] })
  ] }) : null;
}
function WPItemBadgeListItem({
  children,
  colorScheme,
  ...props
}) {
  return /* @__PURE__ */ jsx$1(Tag, { colorScheme, ...props, children: /* @__PURE__ */ jsx$1(TagLabel, { children }) });
}
function CreditsTagLegend({ ...props }) {
  return /* @__PURE__ */ jsxs(Wrap, { ...props, children: [
    /* @__PURE__ */ jsx$1(WPItemBadgeListItem, { colorScheme: "orange", fontSize: "xs", children: "Departments" }),
    /* @__PURE__ */ jsx$1(WPItemBadgeListItem, { colorScheme: "blue", fontSize: "xs", children: "Jobs" }),
    /* @__PURE__ */ jsx$1(WPItemBadgeListItem, { colorScheme: "green", fontSize: "xs", children: "Skills" })
  ] });
}
function SocialIcon({ label, name: name2, value, icon }) {
  return /* @__PURE__ */ jsx$1(Link, { href: socialLink(name2, value), isExternal: true, display: "block", my: 0, children: /* @__PURE__ */ jsx$1(
    IconButton,
    {
      colorScheme: "blue",
      borderRadius: "full",
      boxSize: 12,
      "aria-label": label,
      icon
    }
  ) });
}
const XIcon = createIcon({
  displayName: "XIcon",
  viewBox: "0 0 1200 1227",
  d: "M714.163 519.284L1160.89 0H1055.03L667.137 450.887L357.328 0H0L468.492 681.821L0 1226.37H105.866L515.491 750.218L842.672 1226.37H1200L714.137 519.284H714.163ZM569.165 687.828L521.697 619.934L144.011 79.6944H306.615L611.412 515.685L658.88 583.579L1055.08 1150.3H892.476L569.165 687.854V687.828Z"
});
function PersonalIconLinks({ socials, ...props }) {
  const { facebook, twitter, instagram, linkedin } = socials;
  return /* @__PURE__ */ jsxs(Flex, { gap: 4, ...props, children: [
    linkedin && /* @__PURE__ */ jsx$1(SocialIcon, { label: "LinkedIn", name: "linkedin", value: linkedin, icon: /* @__PURE__ */ jsx$1(FiLinkedin, {}) }),
    facebook && /* @__PURE__ */ jsx$1(SocialIcon, { label: "Facebook", name: "facebook", value: facebook, icon: /* @__PURE__ */ jsx$1(FiFacebook, {}) }),
    twitter && /* @__PURE__ */ jsx$1(SocialIcon, { label: "X/Twitter", name: "twitter", value: twitter, icon: /* @__PURE__ */ jsx$1(XIcon, {}) }),
    instagram && /* @__PURE__ */ jsx$1(
      SocialIcon,
      {
        label: "Instagram",
        name: "instagram",
        value: instagram,
        icon: /* @__PURE__ */ jsx$1(FiInstagram, {})
      }
    )
  ] });
}
function WPItemBadgeList({
  items,
  colorScheme,
  ...props
}) {
  return /* @__PURE__ */ jsx$1(Wrap, { spacing: 2, justify: { base: "left", md: "right" }, ...props, children: items == null ? void 0 : items.map((item) => /* @__PURE__ */ jsx$1(WPItemBadgeListItem, { id: item.id.toString(), colorScheme, children: decodeString(item.name) }, item.id)) });
}
function CreditItem({
  credit,
  isEditable,
  onClick,
  ...props
}) {
  const {
    title,
    jobTitle,
    jobLocation,
    positions: { departments: departmentIds, jobs: jobIds } = { departments: [], jobs: [] },
    skills: skillIds,
    venue,
    workStart,
    workEnd,
    workCurrent,
    intern,
    fellow
  } = credit || {};
  const [termList, setTermList] = useState([]);
  const memoizedTermList = useMemo(() => termList, [termList]);
  const [departments] = useTaxonomyTerms(departmentIds ? departmentIds : []);
  const [jobs, setJobs] = useState([]);
  const [skills, setSkills] = useState([]);
  const [getTerms, { data: termData, loading: termsLoading }] = useLazyTaxonomyTerms();
  useEffect(() => {
    if (!jobIds && !skillIds)
      return;
    const joinedTermList = jobIds.concat(skillIds);
    setTermList(joinedTermList);
  }, [jobIds, skillIds]);
  useEffect(() => {
    if (!sortAndCompareArrays(termList, memoizedTermList) || termList.length === 0)
      return;
    getTerms({
      variables: {
        include: termList
      }
    });
  }, [termList, memoizedTermList]);
  useEffect(() => {
    if (!termData)
      return;
    const {
      terms: { nodes }
    } = termData;
    const jobTerms = jobIds ? nodes.filter((node) => jobIds.includes(node.id)) : [];
    const skillTerms = skillIds ? nodes.filter((node) => skillIds.includes(node.id)) : [];
    setJobs(jobTerms);
    setSkills(skillTerms);
  }, [termData, jobIds, skillIds]);
  const handleCreditKeyDown = (e) => {
    if (onClick === void 0)
      return;
    if (e.key === "Enter" || e.key === " ") {
      onClick();
    }
  };
  const yearString = () => {
    if (workStart && workEnd && workStart === workEnd) {
      return workStart;
    } else if (workStart && workEnd && !workCurrent) {
      return `${workStart} - ${workEnd}`;
    } else if (workStart && workCurrent) {
      return `${workStart} - Present`;
    } else if (workStart && !workEnd && !workCurrent) {
      return `${workStart}`;
    } else {
      return "";
    }
  };
  return /* @__PURE__ */ jsx$1(Box, { onClick, ...props, children: /* @__PURE__ */ jsx$1(
    Card,
    {
      cursor: isEditable ? "pointer" : "default",
      tabIndex: 0,
      onKeyDown: handleCreditKeyDown,
      borderWidth: isEditable ? "3px" : "0",
      borderStyle: "dashed",
      borderColor: "gray.300",
      _hover: isEditable ? { borderColor: "gray.500" } : {},
      children: /* @__PURE__ */ jsx$1(Skeleton, { isLoaded: !termsLoading, children: /* @__PURE__ */ jsxs(
        Flex,
        {
          alignItems: "flex-start",
          justifyContent: "space-between",
          flexWrap: { base: "wrap", md: "nowrap" },
          children: [
            /* @__PURE__ */ jsxs(Box, { flex: "1", children: [
              /* @__PURE__ */ jsxs(Flex, { alignItems: "center", gap: 2, flexWrap: "wrap", mb: 2, children: [
                /* @__PURE__ */ jsx$1(Heading, { as: "h3", fontWeight: "bold", fontSize: "xl", my: 0, children: title }),
                /* @__PURE__ */ jsx$1(
                  Badge,
                  {
                    flex: "0 0 auto",
                    fontSize: "md",
                    fontWeight: "bold",
                    textTransform: "none",
                    px: 2,
                    py: 1,
                    children: ` ${yearString()}`
                  }
                )
              ] }),
              /* @__PURE__ */ jsxs(Flex, { my: 0, alignItems: "center", flexWrap: "wrap", gap: 2, children: [
                venue ? /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiStar, mr: 1, children: decodeString(venue) }) : false,
                jobLocation ? /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiMapPin, mr: 1, children: decodeString(`${jobLocation}`) }) : false,
                /* @__PURE__ */ jsxs(Flex, { my: 0, alignItems: "center", flexWrap: "wrap", gap: 2, children: [
                  jobTitle && /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiBriefcase, children: jobTitle }),
                  intern || fellow ? /* @__PURE__ */ jsxs(Flex, { color: "brand.yellow", gap: 1, ml: 2, children: [
                    intern ? /* @__PURE__ */ jsx$1(
                      Text,
                      {
                        flex: "0 0 auto",
                        fontSize: "sm",
                        fontWeight: "bold",
                        textTransform: "none",
                        py: 1,
                        children: "Internship"
                      }
                    ) : "",
                    intern && fellow ? /* @__PURE__ */ jsx$1(Text, { fontSize: "2xl", mx: 0, my: 1, children: "·" }) : "",
                    fellow ? /* @__PURE__ */ jsx$1(
                      Text,
                      {
                        flex: "0 0 auto",
                        fontSize: "sm",
                        fontWeight: "bold",
                        textTransform: "none",
                        py: 1,
                        colorScheme: "yellow",
                        children: "Fellowship"
                      }
                    ) : ""
                  ] }) : false
                ] })
              ] })
            ] }),
            /* @__PURE__ */ jsx$1(Box, { flex: { base: "0 0 100%", md: "0 50%" }, children: /* @__PURE__ */ jsx$1(Stack, { direction: "column", mt: { base: 4, md: 0 }, children: (departmentIds == null ? void 0 : departmentIds.length) || (jobs == null ? void 0 : jobs.length) || (skills == null ? void 0 : skills.length) ? /* @__PURE__ */ jsxs(Stack, { direction: "column", children: [
              /* @__PURE__ */ jsx$1(WPItemBadgeList, { items: departments, colorScheme: "orange" }),
              /* @__PURE__ */ jsx$1(WPItemBadgeList, { items: jobs, colorScheme: "blue" }),
              /* @__PURE__ */ jsx$1(WPItemBadgeList, { items: skills, colorScheme: "green" })
            ] }) : isEditable ? /* @__PURE__ */ jsx$1(Wrap, { justify: "right", children: /* @__PURE__ */ jsx$1(
              Text,
              {
                textAlign: { base: "left", md: "right" },
                maxWidth: "250px",
                fontSize: "sm",
                lineHeight: "short",
                children: "This credit won't be active and searchable until you add at least one department and a job."
              }
            ) }) : false }) })
          ]
        }
      ) })
    }
  ) });
}
function ConflictDateRanges({
  conflictRanges,
  ...props
}) {
  if (isEmpty$1(conflictRanges)) {
    return /* @__PURE__ */ jsx$1(Fragment, {});
  }
  const {
    search: {
      filters: {
        filterSet: { jobDates }
      }
    }
  } = useContext(SearchContext);
  const sortedDateRanges = useMemo(() => {
    return conflictRanges.slice().sort(
      (a, b) => a.startDate && b.startDate ? a.startDate.getTime() - b.startDate.getTime() : 0
    );
  }, [conflictRanges]);
  const Legend = () => /* @__PURE__ */ jsxs(Flex, { fontSize: "sm", flexWrap: "wrap", gap: 1, children: [
    /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiCheckCircle, iconProps: { color: "brand.blue" }, my: 0, mr: 1, children: "Available" }),
    /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiAlertCircle, iconProps: { color: "red.300" }, my: 0, children: "Possible conflict" })
  ] });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    jobDates && jobDates.startDate ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(Legend, {}),
      /* @__PURE__ */ jsx$1(Divider, {})
    ] }) : false,
    /* @__PURE__ */ jsx$1(List, { spacing: 2, ...props, children: sortedDateRanges.map((conflictRange, index) => {
      let icon, color2, title;
      const _jobDates = jobDates ? jobDates : new DateRange();
      switch (true) {
        case !_jobDates.startDate:
          icon = FiCalendar;
          color2 = "";
          title = "";
          break;
        case dateRangesOverlap(_jobDates, conflictRange):
          icon = FiAlertCircle;
          color2 = "red.300";
          title = "Possible scheduling conflict";
          break;
        default:
          icon = FiCheckCircle;
          color2 = "brand.blue";
          title = "Available";
      }
      return /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(
        WrapWithIcon,
        {
          icon,
          iconProps: {
            color: color2,
            title
          },
          children: conflictRange.toString("long")
        }
      ) }, index);
    }) })
  ] });
}
function ProfileView({ profile, allowStar = true }) {
  const params = useParams();
  const slug = params.slug ? params.slug : "";
  const isLargerThanMd = useBreakpointValue(
    {
      base: false,
      md: true
    },
    { ssr: false }
  );
  const profileUrl = useProfileUrl(slug);
  const {
    id: id2,
    image,
    pronouns,
    selfTitle,
    homebase,
    locations,
    website,
    languages,
    socials,
    unions,
    partnerDirectories,
    willTravel,
    willTour,
    email,
    phone,
    resume,
    description,
    mediaVideo1,
    mediaVideo2,
    mediaImage1,
    mediaImage2,
    mediaImage3,
    mediaImage4,
    mediaImage5,
    mediaImage6,
    education,
    conflictRanges,
    credits
  } = profile || {};
  const mediaVideos = Array.from(new Set([mediaVideo1, mediaVideo2].filter(Boolean)));
  const mediaImages = [
    mediaImage1,
    mediaImage2,
    mediaImage3,
    mediaImage4,
    mediaImage5,
    mediaImage6
  ].filter((image2) => !!image2);
  const creditsSorted = credits ? credits.sort((a, b) => a.index > b.index ? 1 : -1) : [];
  const [
    { locations: locationTerms, unions: unionTerms, partnerDirectories: partnerDirectoryTerms }
  ] = useUserTaxonomies();
  const { sourceUrl: resumePreview } = useResumePreview(resume ? resume : "").mediaItem || {};
  const SelectedTerms = ({ ids, terms }) => {
    const items = getWPItemsFromIds(ids, terms);
    return items ? /* @__PURE__ */ jsx$1(Flex, { gap: 1, flexWrap: "wrap", children: items.map((item) => /* @__PURE__ */ jsx$1(Tag, { children: item.name }, item.id)) }) : null;
  };
  function selectedLinkableTerms({
    ids,
    terms
  }) {
    return getWPItemsFromIds(ids, terms).map((term) => {
      if (term.externalUrl) {
        return /* @__PURE__ */ jsx$1(
          Button,
          {
            as: Link,
            href: term.externalUrl,
            isExternal: true,
            size: "sm",
            m: 0,
            colorScheme: "orange",
            leftIcon: /* @__PURE__ */ jsx$1(FiLink, {}),
            children: term.name
          },
          term.id
        );
      }
      return null;
    });
  }
  const ShareStarButtons = ({ ...props }) => /* @__PURE__ */ jsxs(
    Flex,
    {
      bg: { base: "transparent !important" },
      position: { base: "absolute", md: "relative" },
      top: { base: 0, md: "initial" },
      right: { base: 0, md: "initial" },
      w: { base: "100%", md: "auto" },
      p: 2,
      justifyContent: { base: "space-between", md: "flex-end" },
      display: "flex",
      gap: { base: 0, md: 2 },
      ...props,
      children: [
        /* @__PURE__ */ jsx$1(ShareButton, { url: profileUrl, borderRadius: "full" }),
        id2 && allowStar ? /* @__PURE__ */ jsx$1(StarToggleIcon, { id: id2, mx: { base: 0 }, borderRadius: "full" }) : false
      ]
    }
  );
  const ProfileSubtitle = ({ ...props }) => {
    const SelfTitle = () => {
      return /* @__PURE__ */ jsx$1(Text, { as: "span", textDecoration: "underline", children: selfTitle });
    };
    const HomeBase = () => {
      return /* @__PURE__ */ jsx$1(Text, { as: "span", textDecoration: "underline", children: homebase });
    };
    return /* @__PURE__ */ jsx$1(Heading, { as: "h2", size: "md", mt: 2, fontWeight: "medium", ...props, children: selfTitle && homebase ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(SelfTitle, {}),
      " based in ",
      /* @__PURE__ */ jsx$1(HomeBase, {})
    ] }) : selfTitle || /* @__PURE__ */ jsx$1(HomeBase, {}) });
  };
  return profile ? /* @__PURE__ */ jsx$1(Fragment, { children: /* @__PURE__ */ jsxs(Stack, { direction: "column", flexWrap: "nowrap", gap: 6, children: [
    /* @__PURE__ */ jsx$1(ProfileStackItem, { as: Card, p: 4, children: /* @__PURE__ */ jsxs(Fragment, { children: [
      !isLargerThanMd ? /* @__PURE__ */ jsx$1(ShareStarButtons, {}) : false,
      /* @__PURE__ */ jsxs(
        Flex,
        {
          gap: 6,
          flexWrap: { base: "wrap", md: "nowrap" },
          justifyContent: { base: "center", md: "flex-start" },
          children: [
            isLargerThanMd ? /* @__PURE__ */ jsxs(Stack, { direction: "column", w: "40%", minW: "160px", maxW: "400px", children: [
              image ? /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsx$1(
                Image$1,
                {
                  src: image,
                  alt: `${profile.fullName()}'s picture`,
                  borderRadius: "md",
                  loading: "eager",
                  fit: "cover",
                  w: "full"
                }
              ) }) : /* @__PURE__ */ jsx$1(Avatar, { size: "2xl", name: profile.fullName(), mx: 2 }),
              conflictRanges.length ? /* @__PURE__ */ jsx$1(Card, { pb: 0, _dark: { bg: "gray.600" }, _light: { bg: "gray.200" }, children: /* @__PURE__ */ jsxs(Box, { children: [
                /* @__PURE__ */ jsx$1(Heading, { as: "h3", variant: "contentTitle", children: "Scheduling Conflicts" }),
                /* @__PURE__ */ jsx$1(ConflictDateRanges, { my: 4, conflictRanges })
              ] }) }) : null
            ] }) : /* @__PURE__ */ jsx$1(Avatar, { size: "superLg", src: image, name: profile.fullName() }),
            /* @__PURE__ */ jsxs(
              Stack,
              {
                direction: "column",
                justifyContent: "space-evenly",
                gap: 4,
                width: "100%",
                lineHeight: 1,
                children: [
                  /* @__PURE__ */ jsxs(Box, { display: "flex", flexWrap: "wrap", children: [
                    /* @__PURE__ */ jsxs(
                      Flex,
                      {
                        justifyContent: { base: "center", md: "space-between" },
                        w: "full",
                        flexWrap: "wrap",
                        alignItems: "center",
                        children: [
                          /* @__PURE__ */ jsx$1(
                            Heading,
                            {
                              as: "h1",
                              size: "xl",
                              mr: 2,
                              mt: 0,
                              mb: 1,
                              fontWeight: "bold",
                              lineHeight: "none",
                              children: profile.fullName()
                            }
                          ),
                          pronouns ? /* @__PURE__ */ jsx$1(Tag, { colorScheme: "blue", size: "md", mt: { base: 2, md: "initial" }, children: pronouns }) : null,
                          /* @__PURE__ */ jsx$1(Spacer, { flex: 1 }),
                          isLargerThanMd ? /* @__PURE__ */ jsx$1(ShareStarButtons, { p: 0 }) : null
                        ]
                      }
                    ),
                    /* @__PURE__ */ jsx$1(ProfileSubtitle, { flex: "0 0 100%", w: "full" })
                  ] }),
                  locations && locations.length > 0 ? /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Works in", children: /* @__PURE__ */ jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiMapPin, mr: 2, children: locationTerms ? SelectedTerms({ ids: locations, terms: locationTerms }) : null }),
                    /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiMap, mr: 2, children: /* @__PURE__ */ jsxs(Wrap, { children: [
                      willTravel !== void 0 && /* @__PURE__ */ jsx$1(Tag, { size: "md", colorScheme: willTravel ? "green" : "orange", children: willTravel ? "Will Travel" : "Local Only" }),
                      willTour !== void 0 && /* @__PURE__ */ jsx$1(Tag, { size: "md", colorScheme: willTour ? "green" : "orange", children: willTour ? "Will Tour" : "No Tours" })
                    ] }) })
                  ] }) }) : null,
                  unions && unions.length > 0 && unionTerms ? /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Unions/Guilds/Memberships", children: /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiUser, children: SelectedTerms({ ids: unions, terms: unionTerms }) }) }) : null,
                  partnerDirectories && partnerDirectories.length > 0 && partnerDirectoryTerms ? /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "RISE Network Partner Directories", children: /* @__PURE__ */ jsxs(
                    Flex,
                    {
                      alignItems: "center",
                      flexWrap: "nowrap",
                      justifyContent: "space-between",
                      children: [
                        /* @__PURE__ */ jsx$1(Icon, { as: FiStar, boxSize: 4, flex: "0 0 auto" }),
                        /* @__PURE__ */ jsx$1(Wrap, { flex: "1", pl: 2, spacing: 2, children: selectedLinkableTerms({
                          ids: partnerDirectories,
                          terms: partnerDirectoryTerms
                        }) })
                      ]
                    }
                  ) }) : null,
                  email || phone || website ? /* @__PURE__ */ jsxs(Box, { my: 1, children: [
                    /* @__PURE__ */ jsx$1(Heading, { as: "h3", variant: "contentTitle", children: "Contact" }),
                    /* @__PURE__ */ jsxs(List, { m: 0, spacing: 1, children: [
                      email ? /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(LinkWithIcon, { href: `mailto:${email}`, icon: FiMail, children: email }) }) : null,
                      phone ? /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(LinkWithIcon, { href: `tel:${phone}`, icon: FiPhone, children: phone }) }) : null,
                      website ? /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(LinkWithIcon, { href: website, target: "_blank", icon: FiExternalLink, children: "Visit Website" }) }) : null
                    ] })
                  ] }) : null,
                  conflictRanges.length && !isLargerThanMd ? /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Conflicts", children: /* @__PURE__ */ jsx$1(ConflictDateRanges, { my: 4, conflictRanges }) }) : null,
                  languages ? /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Additional Languages", my: 2, children: /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiGlobe, m: 0, children: /* @__PURE__ */ jsx$1(Text, { m: 0, children: languages }) }) }) : null,
                  !socials.isEmpty() ? /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Social", children: /* @__PURE__ */ jsx$1(PersonalIconLinks, { socials }) }) : null,
                  resume ? /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Resume", children: /* @__PURE__ */ jsxs(Flex, { gap: 2, children: [
                    /* @__PURE__ */ jsx$1(
                      ResumePreviewModal,
                      {
                        resumePreview,
                        resumeLink: resume,
                        previewIcon: false,
                        maxW: "250px"
                      }
                    ),
                    /* @__PURE__ */ jsx$1(
                      TooltipIconButton,
                      {
                        icon: /* @__PURE__ */ jsx$1(FiDownload, {}),
                        as: Link,
                        label: "Download resume",
                        href: resume,
                        colorScheme: "green",
                        my: 0
                      }
                    )
                  ] }) }) : null
                ]
              }
            )
          ]
        }
      )
    ] }) }),
    credits && credits.length > 0 && /* @__PURE__ */ jsx$1(ProfileStackItem, { centerlineColor: "brand.blue", title: "Credits", children: /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(Flex, { justifyContent: "flex-end", children: /* @__PURE__ */ jsx$1(CreditsTagLegend, { mr: 4 }) }),
      /* @__PURE__ */ jsx$1(List, { m: 0, children: creditsSorted.map((credit) => /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(CreditItem, { credit }) }, credit.id)) })
    ] }) }),
    description && /* @__PURE__ */ jsx$1(ProfileStackItem, { centerlineColor: "brand.orange", title: "About", children: /* @__PURE__ */ jsx$1(Text, { whiteSpace: "pre-wrap", borderRadius: "md", children: description.trim() }) }),
    education && /* @__PURE__ */ jsx$1(ProfileStackItem, { centerlineColor: "brand.green", title: "Education + Training", children: /* @__PURE__ */ jsx$1(Text, { whiteSpace: "pre-wrap", borderRadius: "md", children: education.trim() }) }),
    mediaVideos.length > 0 || mediaImages.length > 0 ? /* @__PURE__ */ jsx$1(ProfileStackItem, { centerlineColor: "brand.blue", title: "Media", children: /* @__PURE__ */ jsxs(Fragment, { children: [
      mediaVideos.length > 0 ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Heading, { as: "h3", variant: "contentTitle", size: "md", children: "Video" }),
        /* @__PURE__ */ jsx$1(SimpleGrid, { columns: [1, 2], mt: 4, spacing: 4, children: mediaVideos.map((video) => {
          if (!video)
            return false;
          return (
            // Videos are unique, so we can just use the string as the key.
            /* @__PURE__ */ jsx$1(Box, { position: "relative", paddingBottom: "56.25%", children: /* @__PURE__ */ jsx$1(
              Box,
              {
                position: "absolute",
                top: 0,
                left: 0,
                width: "100%",
                height: "100%",
                children: /* @__PURE__ */ jsx$1(ReactPlayer, { url: video, controls: true, width: "100%", height: "100%" })
              }
            ) }, video)
          );
        }) })
      ] }) : null,
      mediaImages.length > 0 ? /* @__PURE__ */ jsxs(Box, { mt: 6, children: [
        /* @__PURE__ */ jsx$1(Heading, { as: "h3", variant: "contentTitle", size: "md", children: "Images" }),
        /* @__PURE__ */ jsx$1(Box, { w: "full", sx: { columnCount: [1, 2, 3], columnGap: "8px" }, children: mediaImages.map((image2, index) => /* @__PURE__ */ jsx$1(
          Image$1,
          {
            src: image2,
            borderRadius: "md",
            fit: "cover",
            mb: 2,
            alt: `${profile.fullName()}'s image`
          },
          index
        )) })
      ] }) : null
    ] }) }) : null
  ] }) }) : null;
}
function Profile() {
  const [{ loggedInId, loggedInSlug }] = useViewer();
  const params = useParams();
  const slug = params.slug ? params.slug : "";
  const [userId] = useUserIdBySlug(slug);
  const profileIsLoggedInUser = loggedInSlug === slug;
  const [profile, { loading }] = useUserProfile(userId);
  const PageActions = () => /* @__PURE__ */ jsx$1(ButtonGroup, { size: "md", alignItems: "center", children: profileIsLoggedInUser && /* @__PURE__ */ jsx$1(
    TooltipIconButton,
    {
      label: "Edit profile",
      icon: /* @__PURE__ */ jsx$1(FiEdit3, {}),
      as: Link$1,
      to: "/profile/edit",
      colorScheme: "green"
    }
  ) });
  return /* @__PURE__ */ jsx$1(
    Shell,
    {
      title: profileIsLoggedInUser ? "My Profile" : "",
      actions: /* @__PURE__ */ jsx$1(PageActions, {}),
      loading,
      pb: 8,
      children: profile ? /* @__PURE__ */ jsx$1(ProfileView, { profile, allowStar: loggedInId !== userId }) : false
    }
  );
}
const EditProfileContext = createContext({
  editProfile: new UserProfile(),
  editProfileDispatch: ({}) => {
  }
});
function editProfileContextReducer(state2, action) {
  switch (action.type) {
    case "UPDATE_INPUT": {
      if (!action.payload.name)
        return state2;
      const current = cloneInstance(state2);
      current.set(action.payload.name, action.payload.value);
      return current;
    }
    case "UPDATE_BOOLEAN_INPUT": {
      if (!action.payload.name || [void 0, null].includes(action.payload.value))
        return state2;
      const current = cloneInstance(state2);
      current.set(action.payload.name, sanitizeBoolean(action.payload.value));
      return current;
    }
    case "UPDATE_PERSONAL_LINKS_INPUT": {
      if (!action.payload.name)
        return state2;
      const current = cloneInstance(state2);
      current.set(
        "socials",
        new PersonalLinks({ ...current.socials, [action.payload.name]: action.payload.value })
      );
      return current;
    }
    case "ADD_NEW_CREDIT": {
      return {
        ...state2,
        credits: [
          ...state2.credits,
          new Credit({
            id: generateRandomString(8),
            isNew: true,
            index: state2.credits.length,
            positions: { departments: [], jobs: [] }
          })
        ]
      };
    }
    case "INIT":
    case "RESET": {
      return action.payload.profile;
    }
    case "DEBOUNCED_UPDATE_INPUT": {
      if (!action.payload.name)
        return state2;
      const current = cloneInstance(state2);
      current.set(action.payload.name, action.payload.value);
      return current;
    }
    default:
      return state2;
  }
}
const EditProfileContextProvider = ({ initialState: initialState2, children }) => {
  const [editProfile, dispatch] = useReducer(editProfileContextReducer, initialState2);
  const debouncedDispatch = useCallback(
    debounce((action) => {
      dispatch(action);
    }, 300),
    []
  );
  const editProfileDispatch = useCallback(
    (action) => {
      if (action.type === "UPDATE_INPUT") {
        debouncedDispatch({ ...action, type: "DEBOUNCED_UPDATE_INPUT" });
      } else {
        dispatch(action);
      }
    },
    [debouncedDispatch]
  );
  return /* @__PURE__ */ jsx$1(EditProfileContext.Provider, { value: { editProfile, editProfileDispatch }, children });
};
const MUTATE_UPDATE_USER = gql`
	mutation UpdateProfile($input: UpdateProfileInput = {}) {
		updateProfile(input: $input) {
			clientMutationId
			result
		}
	}
`;
const useUpdateProfile = () => {
  const [mutation, results2] = useMutation(MUTATE_UPDATE_USER);
  const updateProfileMutation = (profile) => {
    return mutation({
      variables: {
        input: {
          clientMutationId: "updateProfileMutation",
          profile: prepareUserProfileForGQL(profile)
        }
      },
      refetchQueries: [{ query: QUERY_PROFILE, variables: { id: profile.id, author: profile.id } }]
    });
  };
  return { updateProfileMutation, results: results2 };
};
const MUTATE_DELETE_CREDIT = gql`
	mutation DeleteCredit($input: DeleteOwnCreditInput!) {
		deleteOwnCredit(input: $input) {
			result
			clientMutationId
		}
	}
`;
const useDeleteCredit = () => {
  const [mutation, results2] = useMutation(MUTATE_DELETE_CREDIT);
  const deleteCreditMutation = (id2, userId) => {
    return mutation({
      variables: {
        input: {
          clientMutationId: "deleteCreditMutation",
          id: id2,
          userId
        }
      },
      refetchQueries: [{ query: QUERY_PROFILE, variables: { id: userId, author: userId } }]
    });
  };
  return { deleteCreditMutation, results: results2 };
};
const UPLOAD_FILE_MUTATION = gql`
	mutation UploadFileMutation($file: Upload!, $name: String!, $userId: ID!) {
		uploadFile(input: { file: $file, name: $name, userId: $userId }) {
			fileUrl
		}
	}
`;
const useFileUpload = () => {
  const [mutation, results2] = useMutation(UPLOAD_FILE_MUTATION);
  const uploadFileMutation = (file, name2, userId) => {
    return mutation({
      variables: {
        file,
        name: name2,
        userId
      },
      refetchQueries: [
        {
          query: QUERY_PROFILE,
          variables: { id: userId, author: userId },
          fetchPolicy: "network-only"
        }
      ]
    });
  };
  return { uploadFileMutation, results: results2 };
};
const MUTATE_CLEAR_FIELD = gql`
	mutation clearProfileFieldMutation($fieldName: String!, $userId: Int!) {
		clearProfileField(input: { fieldName: $fieldName, userId: $userId }) {
			result
		}
	}
`;
const useClearProfileField = () => {
  const [mutation, results2] = useMutation(MUTATE_CLEAR_FIELD);
  const clearProfileFieldMutation = (userId, fieldName) => {
    return mutation({
      variables: {
        clientMutationId: "clearProfileFieldMutation",
        userId,
        fieldName
      },
      refetchQueries: [{ query: QUERY_PROFILE, variables: { id: userId, author: userId } }]
    });
  };
  return { clearProfileFieldMutation, results: results2 };
};
const MUTATE_UPDATE_CREDIT_ORDER = gql`
	mutation UpdateCreditOrderMutation(
		$input: UpdateCreditOrderInput = { creditIds: "", clientMutationId: "" }
	) {
		updateCreditOrder(input: $input) {
			creditIds
		}
	}
`;
const useUpdateCreditOrder = () => {
  const [mutation, results2] = useMutation(MUTATE_UPDATE_CREDIT_ORDER);
  const updateCreditOrderMutation = (creditIds) => {
    return mutation({
      variables: {
        input: {
          clientMutationId: "updateCreditOrderMutation",
          creditIds
        }
      }
    });
  };
  return { updateCreditOrderMutation, results: results2 };
};
function ProfileRadioGroup({
  name: name2,
  label,
  items,
  groupButtons,
  defaultValue,
  handleChange,
  ...props
}) {
  const handleToggleItem = (value) => {
    handleChange(name2)(value);
  };
  return items ? /* @__PURE__ */ jsxs(chakra.div, { ...props, children: [
    /* @__PURE__ */ jsx$1(RadioGroup, { value: defaultValue, onChange: handleToggleItem, children: /* @__PURE__ */ jsx$1(Wrap, { spacing: 1, children: items.map((item) => {
      return /* @__PURE__ */ jsx$1(RadioButton, { value: item.value, children: item.label }, `${item.label}:${item.value}`);
    }) }) }),
    label ? /* @__PURE__ */ jsx$1(FormLabel, { fontSize: "sm", children: label }) : false
  ] }) : null;
}
function TextareaInput({
  label,
  labelHidden,
  helperText,
  placeholder,
  value,
  name: name2,
  onChange,
  inputProps,
  debounceTime,
  onDebounceStart,
  onDebounceEnd,
  ...props
}) {
  const [localValue, setLocalValue] = useState(value);
  const isDebouncing = useRef(false);
  const handleDebouncedChange = (value2) => {
    onChange({ target: { name: name2, value: value2 } });
    isDebouncing.current = false;
    onDebounceEnd == null ? void 0 : onDebounceEnd();
  };
  const debouncedOnChange = useCallback(debounce(handleDebouncedChange, debounceTime), [
    onChange,
    name2,
    debounceTime,
    onDebounceEnd
  ]);
  const handleChange = (e) => {
    const newValue = e.target.value;
    setLocalValue(newValue);
    if (debounceTime) {
      if (!isDebouncing.current) {
        isDebouncing.current = true;
        onDebounceStart == null ? void 0 : onDebounceStart();
      }
      handleDebouncedChange(newValue);
    } else {
      onChange(e);
    }
  };
  useEffect(() => {
    return () => {
      debouncedOnChange.cancel();
    };
  }, [debouncedOnChange]);
  return /* @__PURE__ */ jsxs(FormControl, { ...props, children: [
    /* @__PURE__ */ jsx$1(
      Textarea,
      {
        variant: "filled",
        placeholder,
        focusBorderColor: "blue.200",
        value: localValue ? localValue : "",
        name: name2,
        resize: "vertical",
        onChange: handleChange,
        isDisabled: props.isDisabled,
        ...inputProps
      }
    ),
    label ? /* @__PURE__ */ jsx$1(
      FormLabel,
      {
        ml: 2,
        sx: {
          visibility: labelHidden ? "hidden" : "visible",
          position: labelHidden ? "absolute" : "initial"
        },
        children: label
      }
    ) : false,
    helperText ? /* @__PURE__ */ jsx$1(FormHelperText, { children: helperText }) : false
  ] });
}
function FileUploadButton({
  fieldName,
  icon,
  accept,
  onChange,
  loading,
  children,
  ...props
}) {
  const fileInputRef = useRef(null);
  const handleButtonClick = () => {
    if (fileInputRef.current) {
      fileInputRef.current.click();
    }
  };
  return /* @__PURE__ */ jsxs(
    Button,
    {
      tabIndex: 0,
      leftIcon: icon ? icon : void 0,
      size: "md",
      w: "full",
      colorScheme: "green",
      opacity: loading ? 0.5 : 1,
      cursor: loading ? "progress" : "pointer",
      isDisabled: loading,
      onClick: handleButtonClick,
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsx$1(VisuallyHidden, { children: /* @__PURE__ */ jsx$1(
          chakra.input,
          {
            ref: fileInputRef,
            type: "file",
            name: fieldName,
            accept,
            onChange,
            tabIndex: -1
          }
        ) })
      ]
    }
  );
}
const useLazyPositions = () => {
  return useLazyQuery(QUERY_POSITION_TERMS);
};
const useLazyRelatedSkills = () => {
  return useLazyQuery(QUERY_RELATED_SKILLS);
};
const MUTATE_UPDATE_CREDIT = gql`
	mutation UpdateCreditMutation($input: UpdateOrCreateCreditInput = {}) {
		updateOrCreateCredit(input: $input) {
			updatedCredit {
				id: databaseId
				index
				title
				jobTitle
				jobLocation
				venue
				workStart
				workEnd
				workCurrent
				intern
				fellow
				departments
				jobs
				skills
			}
		}
	}
`;
const useUpdateCredit = () => {
  const [mutation, results2] = useMutation(MUTATE_UPDATE_CREDIT);
  const updateCreditMutation = (credit, userId) => {
    return mutation({
      variables: {
        input: {
          credit
        }
      },
      refetchQueries: [
        {
          query: QUERY_PROFILE,
          variables: { id: userId, author: userId, lastCredits: 5 }
        }
      ]
    });
  };
  return { updateCreditMutation, results: results2 };
};
function editCreditReducer(state2, action) {
  switch (action.type) {
    case "UPDATE_INPUT":
      return {
        ...state2,
        [action.payload.name]: action.payload.value
      };
    case "UPDATE_DEPARTMENTS":
      return {
        ...state2,
        positions: {
          ...state2.positions,
          departments: action.payload.value.map((item) => item)
        }
      };
    case "UPDATE_JOBS":
      return {
        ...state2,
        positions: {
          ...state2.positions,
          jobs: action.payload.value.map((item) => item)
        }
      };
    case "UPDATE_SKILLS":
      return {
        ...state2,
        skills: action.payload.value.map((item) => item)
      };
    case "INIT":
    case "RESET":
      return action.payload;
    default:
      return state2;
  }
}
function EditCreditView({ creditId, onClose: closeModal }) {
  var _a;
  const [{ loggedInId }] = useViewer();
  const { editProfile } = useContext(EditProfileContext);
  const credit = (_a = editProfile.credits) == null ? void 0 : _a.find((credit2) => credit2.id === creditId);
  const [editCredit, editCreditDispatch] = useReducer(editCreditReducer, credit);
  const toast = useToast();
  const {
    updateCreditMutation,
    results: { loading: updateCreditLoading }
  } = useUpdateCredit();
  const {
    title,
    jobTitle,
    jobLocation,
    venue,
    workStart,
    workEnd,
    workCurrent,
    intern,
    fellow,
    positions: { departments: selectedDepartmentIds = [], jobs: selectedJobIds = [] },
    skills: selectedSkills
  } = editCredit;
  const [allDepartments] = usePositions();
  const [getJobs, { loading: jobsLoading }] = useLazyPositions();
  const [jobs, setJobs] = useState([]);
  const [getRelatedSkills, { loading: relatedSkillsLoading }] = useLazyRelatedSkills();
  const [skills, setSkills] = useState([]);
  const [requirementsMet, setRequirementsMet] = useState(false);
  const requiredFields = ["title", "jobTitle", "jobLocation", "venue", "workStart"];
  useEffect(() => {
    refetchAndSetJobs(selectedDepartmentIds);
    refetchAndSetSkills(selectedJobIds);
  }, []);
  useEffect(() => {
    let allFilled = requiredFields.every((field) => {
      if (!!editCredit[field])
        return true;
      return false;
    });
    allFilled = allFilled && selectedDepartmentIds.length > 0;
    allFilled = allFilled && selectedJobIds.length > 0;
    setRequirementsMet(allFilled);
  }, [editCredit]);
  const refetchAndSetJobs = async (departmentIds) => {
    var _a2;
    if (departmentIds.length === 0) {
      setJobs([]);
      return [];
    }
    const jobData = await getJobs({
      variables: { departments: departmentIds }
    });
    const jobsByDept = (_a2 = jobData == null ? void 0 : jobData.data) == null ? void 0 : _a2.jobsByDepartments;
    if (jobsByDept) {
      setJobs(jobsByDept.map((item) => new WPItem(item)).sort(sortWPItemsByName));
      const jobsByDeptIds = jobsByDept.map((j2) => Number(j2.id));
      return jobsByDeptIds;
    } else {
      setJobs([]);
      return [];
    }
  };
  const refetchAndSetSkills = async (jobIds) => {
    var _a2;
    if (jobIds.length === 0) {
      setSkills([]);
      return [];
    }
    const skillData = await getRelatedSkills({
      variables: { jobs: jobIds }
    });
    const relatedSkills = (_a2 = skillData == null ? void 0 : skillData.data) == null ? void 0 : _a2.jobSkills;
    if (relatedSkills) {
      setSkills(relatedSkills.map((item) => new WPItem(item)).sort(sortWPItemsByName));
      const relatedSkillIds = relatedSkills.map((s) => Number(s.id));
      return relatedSkillIds;
    } else {
      setSkills([]);
      return [];
    }
  };
  const handleInputChange = (event) => {
    const { name: name2, value } = event.target;
    editCreditDispatch({
      type: "UPDATE_INPUT",
      payload: {
        name: name2,
        value
      }
    });
  };
  const dispatchCheckboxTermChange = (name2, terms) => {
    editCreditDispatch({
      type: `UPDATE_${name2.toUpperCase()}`,
      payload: {
        value: terms
      }
    });
  };
  const handleDepartmentsChange = (name2) => async (terms) => {
    const termsAsNums = terms.map((i) => Number(i));
    dispatchCheckboxTermChange(name2, termsAsNums);
    const visibleJobs = await refetchAndSetJobs(termsAsNums);
    const filteredSelectedJobIds = selectedJobIds.filter((id2) => visibleJobs.includes(id2));
    dispatchCheckboxTermChange("jobs", filteredSelectedJobIds);
    const visibleSkills = await refetchAndSetSkills(filteredSelectedJobIds);
    const filteredSelectedSkillIds = selectedSkills.filter(
      (id2) => visibleSkills.includes(id2)
    );
    dispatchCheckboxTermChange("skills", filteredSelectedSkillIds);
  };
  const handleJobsChange = (name2) => async (terms) => {
    const termsAsNums = terms.map((i) => Number(i));
    dispatchCheckboxTermChange(name2, termsAsNums);
    const visibleSkills = await refetchAndSetSkills(termsAsNums);
    const filteredSelectedSkillIds = selectedSkills.filter(
      (id2) => visibleSkills.includes(id2)
    );
    dispatchCheckboxTermChange("skills", filteredSelectedSkillIds);
  };
  const handleSkillsChange = (name2) => (terms) => {
    const termsAsNums = terms.map((i) => Number(i));
    dispatchCheckboxTermChange(name2, termsAsNums);
  };
  const handleRadioInputChange = (name2) => (value) => {
    editCreditDispatch({
      type: "UPDATE_INPUT",
      payload: {
        name: name2,
        value: value === "true" ? true : false
      }
    });
  };
  const handleSubmit = () => {
    const creditToUpdate = new Credit(editCredit).prepareCreditForGraphQL();
    updateCreditMutation(creditToUpdate, loggedInId).then(() => {
      closeModal();
      toast({
        title: "Saved!",
        description: "Your credit has been saved.",
        status: "success",
        duration: 3e3,
        isClosable: true,
        position: "bottom"
      });
    }).catch((err) => {
      toast({
        title: "Oops!",
        description: "There was an error saving this credit." + err,
        status: "error",
        duration: 3e3,
        isClosable: true,
        position: "bottom"
      });
      console.error(err);
    });
  };
  const handleCancel = () => {
    closeModal();
    editCreditDispatch({
      type: "RESET",
      payload: credit
    });
  };
  const EditCreditButtons = memo(() => {
    return /* @__PURE__ */ jsxs(ButtonGroup, { size: "md", children: [
      /* @__PURE__ */ jsx$1(
        TooltipIconButton,
        {
          type: "submit",
          isLoading: updateCreditLoading,
          onClick: handleSubmit,
          icon: /* @__PURE__ */ jsx$1(FiCheck, {}),
          label: "Save",
          colorScheme: "green",
          isDisabled: !requirementsMet || updateCreditLoading
        }
      ),
      /* @__PURE__ */ jsx$1(
        TooltipIconButton,
        {
          icon: /* @__PURE__ */ jsx$1(FiX, {}),
          label: "Cancel changes",
          colorScheme: "red",
          onClick: handleCancel,
          isDisabled: updateCreditLoading
        }
      )
    ] });
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Flex, { flex: "1", justifyContent: "space-between", py: 2, mb: 2, children: [
      /* @__PURE__ */ jsx$1(Heading, { as: "h3", size: "lg", lineHeight: "base", children: "Edit Credit" }),
      /* @__PURE__ */ jsx$1(EditCreditButtons, {})
    ] }),
    /* @__PURE__ */ jsxs(Flex, { gap: 4, children: [
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          name: "title",
          label: "Company/Production Name",
          value: title,
          isRequired: true,
          onChange: handleInputChange,
          debounceTime: 300
        }
      ),
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          name: "jobTitle",
          label: "Job/Position Title",
          isRequired: true,
          value: jobTitle,
          onChange: handleInputChange,
          debounceTime: 300
        }
      )
    ] }),
    /* @__PURE__ */ jsxs(Flex, { justifyContent: "space-between", w: "full", gap: 4, flexWrap: "wrap", mt: 1, children: [
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          name: "workStart",
          label: "Start year",
          isRequired: true,
          value: workStart,
          onChange: handleInputChange,
          flex: "1",
          debounceTime: 300
        }
      ),
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          name: "workEnd",
          label: "End year",
          value: !workCurrent ? workEnd : "",
          isDisabled: workCurrent,
          onChange: handleInputChange,
          flex: "1",
          debounceTime: 300
        }
      ),
      /* @__PURE__ */ jsx$1(
        ProfileRadioGroup,
        {
          defaultValue: workCurrent ? "true" : "false",
          name: "workCurrent",
          label: "Currently working here",
          items: [
            { label: "Yes", value: "true" },
            { label: "No", value: "false" }
          ],
          handleChange: handleRadioInputChange
        }
      )
    ] }),
    /* @__PURE__ */ jsxs(Flex, { justifyContent: "space-between", w: "full", gap: 4, flexWrap: "wrap", mt: 1, children: [
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          name: "venue",
          label: "Venue",
          value: venue,
          onChange: handleInputChange,
          isRequired: true,
          flex: "1",
          debounceTime: 300
        }
      ),
      /* @__PURE__ */ jsx$1(
        TextInput,
        {
          name: "jobLocation",
          label: "Job Location",
          value: jobLocation,
          isRequired: true,
          onChange: handleInputChange,
          flex: "1",
          debounceTime: 300
        }
      )
    ] }),
    /* @__PURE__ */ jsxs(Flex, { justifyContent: "flex-start", w: "full", gap: 4, flexWrap: "wrap", mt: 1, children: [
      /* @__PURE__ */ jsx$1(
        ProfileRadioGroup,
        {
          defaultValue: intern ? "true" : "false",
          name: "intern",
          label: `This ${workCurrent ? "is" : "was"} an internship`,
          items: [
            { label: "Yes", value: "true" },
            { label: "No", value: "false" }
          ],
          handleChange: handleRadioInputChange
        }
      ),
      /* @__PURE__ */ jsx$1(
        ProfileRadioGroup,
        {
          defaultValue: fellow ? "true" : "false",
          name: "fellow",
          label: `This ${workCurrent ? "is" : "was"} a fellowship`,
          items: [
            { label: "Yes", value: "true" },
            { label: "No", value: "false" }
          ],
          handleChange: handleRadioInputChange
        }
      )
    ] }),
    /* @__PURE__ */ jsx$1(Divider, {}),
    /* @__PURE__ */ jsxs(Stack, { direction: "column", spacing: 6, fontSize: "md", children: [
      /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsxs(Heading, { as: "h4", variant: "contentTitle", children: [
          "Department",
          /* @__PURE__ */ jsx$1(RequiredAsterisk, { fontSize: "md", position: "relative", top: -1 })
        ] }),
        /* @__PURE__ */ jsx$1(Text, { children: "Select all department(s) you worked under." }),
        /* @__PURE__ */ jsx$1(
          ProfileCheckboxGroup,
          {
            name: "departments",
            items: allDepartments,
            checked: selectedDepartmentIds ? selectedDepartmentIds.map((item) => item.toString()) : [],
            handleChange: handleDepartmentsChange
          }
        )
      ] }),
      selectedDepartmentIds.length && !jobsLoading ? /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsxs(Heading, { as: "h4", variant: "contentTitle", children: [
          "Position",
          /* @__PURE__ */ jsx$1(RequiredAsterisk, { fontSize: "md", position: "relative", top: -1 })
        ] }),
        /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(Text, { children: "Select all jobs you held on this project." }),
          /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "jobs",
              items: jobs,
              checked: selectedJobIds ? selectedJobIds.map((item) => item.toString()) : [],
              handleChange: handleJobsChange
            }
          )
        ] })
      ] }) : jobsLoading ? /* @__PURE__ */ jsx$1(Spinner, {}) : null,
      selectedJobIds.length && !relatedSkillsLoading ? /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsx$1(Heading, { as: "h4", variant: "contentTitle", children: "Skills" }),
        /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(Text, { children: "Select any skills used on this job." }),
          /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "skills",
              items: skills,
              checked: selectedSkills ? selectedSkills.map((item) => item.toString()) : [],
              handleChange: handleSkillsChange
            }
          )
        ] })
      ] }) : relatedSkillsLoading ? /* @__PURE__ */ jsx$1(Spinner, {}) : null
    ] }),
    /* @__PURE__ */ jsx$1(Flex, { justifyContent: "flex-end", mt: 4, mb: 0, children: /* @__PURE__ */ jsx$1(EditCreditButtons, {}) })
  ] });
}
function EditCreditModal({ isOpen, onClose, creditId }) {
  return /* @__PURE__ */ jsxs(Modal, { isOpen, onClose, scrollBehavior: "outside", size: "3xl", children: [
    /* @__PURE__ */ jsx$1(ModalOverlay, {}),
    "F",
    /* @__PURE__ */ jsx$1(ModalContent, { children: /* @__PURE__ */ jsx$1(ModalBody, { px: 8, pb: 4, children: creditId ? /* @__PURE__ */ jsx$1(EditCreditView, { creditId, onClose }) : "No credit found." }) })
  ] });
}
function DeleteCreditButton({ handleDeleteCredit, id: id2 }) {
  const { isOpen, onOpen, onClose } = useDisclosure();
  const handleDelete = () => {
    handleDeleteCredit(id2);
    onClose();
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx$1(
      TooltipIconButton,
      {
        colorScheme: "red",
        icon: /* @__PURE__ */ jsx$1(FiTrash2, {}),
        label: "Delete Credit",
        onClick: onOpen
      }
    ),
    /* @__PURE__ */ jsx$1(
      ConfirmActionDialog,
      {
        isOpen,
        onClose,
        confirmAction: handleDelete,
        headerText: "Delete Credit",
        buttonsText: { confirm: "Delete" },
        children: "Are you sure you want to permanently delete this credit?"
      }
    )
  ] });
}
const MUTATE_TOGGLE_DISABLE_PROFILE = gql`
	mutation ToggleDisableProfile($userId: Int!) {
		toggleDisableProfile(input: { userId: $userId }) {
			updatedDisableProfile
			clientMutationId
		}
	}
`;
const useToggleDisableProfile = () => {
  const [mutation, result] = useMutation(MUTATE_TOGGLE_DISABLE_PROFILE);
  const toggleDisableProfileMutation = (userId) => {
    return mutation({
      variables: {
        clientMutationId: "toggleDisableProfileMutation",
        userId
      },
      refetchQueries: [{ query: QUERY_VIEWER }]
    });
  };
  return { toggleDisableProfileMutation, result };
};
function DisableProfileToggle({
  size = "md",
  showLabel,
  showHelperText,
  ...props
}) {
  const [{ loggedInId, disableProfile }] = useViewer();
  const {
    toggleDisableProfileMutation,
    result: { data, loading }
  } = useToggleDisableProfile();
  const noticeLabel = "profile_notice_profile_disabled_dismissed";
  const toast = useToast();
  useEffect(() => {
    if ((data == null ? void 0 : data.toggleDisableProfile.updatedDisableProfile) !== void 0 && !loading) {
      const {
        toggleDisableProfile: { updatedDisableProfile }
      } = data || {};
      toast({
        title: "Updated!",
        description: `Your profile is now ${updatedDisableProfile ? "private" : "public"}.`,
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    }
  }, [data, loading]);
  const handleToggleDisableProfile = () => {
    toggleDisableProfileMutation(loggedInId);
    if (disableProfile === true)
      setCookie(noticeLabel, 1, 30);
    else
      deleteCookie(noticeLabel);
  };
  return /* @__PURE__ */ jsx$1(
    ToggleOptionSwitch,
    {
      id: "disableProfile",
      checked: !!disableProfile,
      callback: handleToggleDisableProfile,
      label: `Privacy ${disableProfile ? "On" : "Off"}`,
      iconRight: FiEyeOff,
      iconLeft: FiEye,
      size,
      loading,
      showLabel,
      ...props,
      children: /* @__PURE__ */ jsx$1(Fragment, { children: showHelperText ? /* @__PURE__ */ jsx$1(Description, { disableProfile: !!disableProfile }) : /* @__PURE__ */ jsx$1(Fragment, {}) })
    }
  );
}
const Description = ({ disableProfile }) => {
  return disableProfile ? /* @__PURE__ */ jsx$1(Text, { as: "span", lineHeight: "shorter", children: /* @__PURE__ */ jsx$1(Highlight, { query: ["private", "hidden"], styles: { bg: "brand.yellow", px: 1, mx: 0 }, children: "Your profile is private and you won't appear in searches." }) }) : /* @__PURE__ */ jsx$1(Text, { as: "span", lineHeight: "shorter", children: /* @__PURE__ */ jsx$1(Highlight, { query: ["public"], styles: { bg: "brand.yellow", px: 1, mx: 0 }, children: "Your profile is public and you'll appear in searches." }) });
};
const MUTATE_DELETE_UNAVAIL_RANGE = gql`
	mutation DeleteOwnSavedSearch($input: DeleteOwnConflictRangeInput!) {
		deleteOwnConflictRange(input: $input) {
			result
			clientMutationId
		}
	}
`;
const useDeleteOwnConflictRange = () => {
  const [mutation, results2] = useMutation(MUTATE_DELETE_UNAVAIL_RANGE);
  const deleteOwnConflictRangeMutation = (id2, userId) => {
    return mutation({
      variables: {
        input: {
          clientMutationId: "deleteOwnConflictRangeMutation",
          id: id2.toString(),
          userId
        }
      },
      refetchQueries: [{ query: QUERY_PROFILE, variables: { id: userId, author: userId } }]
    });
  };
  return { deleteOwnConflictRangeMutation, results: results2 };
};
const MUTATE_UPDATE_UNAVAIL_RANGE = gql`
	mutation updateConflictRangeMutation($input: UpdateOrCreateConflictRangeInput = {}) {
		updateOrCreateConflictRange(input: $input) {
			id
		}
	}
`;
const useUpdateConflictRange = () => {
  const [mutation, results2] = useMutation(MUTATE_UPDATE_UNAVAIL_RANGE);
  const updateConflictRangeMutation = (id2 = 0, userId, startDate, endDate) => {
    return mutation({
      variables: {
        input: {
          id: id2,
          userId,
          startDate: startDate.toISOString(),
          endDate: endDate.toISOString()
        }
      },
      refetchQueries: [
        {
          query: QUERY_PROFILE,
          variables: { id: userId, author: userId, lastCredits: 5 }
        }
      ]
    });
  };
  return { updateConflictRangeMutation, results: results2 };
};
function DateRangePicker({
  startDate,
  endDate,
  saveCallback,
  handleSelect,
  error
}) {
  const [newStartDate, setNewStartDate] = useState(startDate || void 0);
  const [newEndDate, setNewEndDate] = useState(endDate || void 0);
  const onChange = (dates) => {
    const [start, end] = dates;
    setNewStartDate(start || void 0);
    setNewEndDate(end || void 0);
  };
  const handleSave = () => {
    if (!newStartDate || !newEndDate || saveCallback === void 0) {
      return;
    }
    saveCallback(newStartDate, newEndDate);
  };
  const dateRangeString = () => {
    const newRange = new DateRange({ startDate: newStartDate, endDate: newEndDate });
    return newRange.toString("long");
  };
  return /* @__PURE__ */ jsxs(Flex, { gap: 2, children: [
    /* @__PURE__ */ jsx$1(
      DatePicker,
      {
        onChange,
        onSelect: handleSelect ? handleSelect : void 0,
        selected: newStartDate,
        startDate: newStartDate,
        endDate: newEndDate,
        minDate: /* @__PURE__ */ new Date(),
        selectsRange: true,
        inline: true
      }
    ),
    /* @__PURE__ */ jsxs(Stack, { direction: "column", children: [
      newStartDate && newEndDate ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Spacer, {}),
        /* @__PURE__ */ jsxs(Box, { children: [
          /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", children: "Selected:" }),
          /* @__PURE__ */ jsx$1(Text, { fontSize: "lg", children: dateRangeString() }),
          error ? /* @__PURE__ */ jsx$1(Text, { variant: "notice", fontSize: "sm", children: error }) : false
        ] }),
        /* @__PURE__ */ jsx$1(Spacer, {})
      ] }) : false,
      /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Spacer, {}),
        /* @__PURE__ */ jsx$1(
          Button,
          {
            onClick: handleSave,
            colorScheme: "blue",
            isDisabled: !newStartDate || !newEndDate,
            children: "Save"
          }
        )
      ] })
    ] })
  ] });
}
function EditConflictDateRangeModal({
  conflictRange = new DateRange(),
  allDateRanges,
  isOpen,
  onClose
}) {
  const [{ loggedInId }] = useViewer();
  const [errorCode, setErrorCode] = useState("");
  const errorMessage = useErrorMessage(errorCode);
  const {
    updateConflictRangeMutation,
    results: { data, loading }
  } = useUpdateConflictRange();
  const { id: id2, startDate, endDate } = conflictRange;
  const toast = useToast();
  useEffect(() => {
    var _a;
    if (((_a = data == null ? void 0 : data.updateOrCreateConflictRange) == null ? void 0 : _a.id) && !loading) {
      onClose();
      toast({
        title: "Success!",
        description: "Conflict range updated.",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    }
    return () => {
      setErrorCode("");
    };
  }, [data, loading]);
  const handleSelect = () => {
    setErrorCode("");
  };
  const saveDateRangeCallback = (newStartDate, newEndDate) => {
    const overlappingRange = allDateRanges == null ? void 0 : allDateRanges.find(
      ({ id: existingRangeId, startDate: existingStartDate, endDate: existingEndDate }) => {
        return (
          // Check if the new dates overlap with any other range
          existingRangeId !== id2 && existingStartDate && existingEndDate && !(newEndDate < existingStartDate || newStartDate > existingEndDate)
        );
      }
    );
    if (overlappingRange) {
      setErrorCode("conflict_range_overlap");
      return;
    }
    updateConflictRangeMutation(id2, loggedInId, newStartDate, newEndDate);
  };
  return /* @__PURE__ */ jsxs(Modal, { isOpen, onClose, scrollBehavior: "outside", children: [
    /* @__PURE__ */ jsx$1(ModalOverlay, {}),
    /* @__PURE__ */ jsxs(ModalContent, { children: [
      /* @__PURE__ */ jsx$1(ModalCloseButton, {}),
      /* @__PURE__ */ jsx$1(ModalBody, { px: 4, pb: 4, children: /* @__PURE__ */ jsx$1(
        DateRangePicker,
        {
          startDate,
          endDate: endDate ? endDate : void 0,
          error: errorCode ? errorMessage : "",
          handleSelect,
          saveCallback: saveDateRangeCallback
        }
      ) })
    ] })
  ] });
}
function EditConflictDateRanges() {
  const [{ loggedInId }] = useViewer();
  const {
    editProfile: { conflictRanges }
  } = useContext(EditProfileContext);
  const {
    deleteOwnConflictRangeMutation,
    results: { data: deleteData, loading: deleteLoading }
  } = useDeleteOwnConflictRange();
  const sortedDateRanges = useMemo(() => {
    return conflictRanges.slice().sort(
      (a, b) => a.startDate && b.startDate ? a.startDate.getTime() - b.startDate.getTime() : 0
    );
  }, [conflictRanges]);
  const [conflictRangeModalIsOpen, setConflictRangeModalIsOpen] = useState(false);
  const [conflictRange, setDateRange] = useState(new DateRange());
  const toast = useToast();
  useEffect(() => {
    var _a;
    if (((_a = deleteData == null ? void 0 : deleteData.deleeOwnConflictRange) == null ? void 0 : _a.result) === true && !deleteLoading) {
      toast({
        title: "Success!",
        description: "Dates deleted.",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    }
  }, [deleteData, deleteLoading]);
  const handleEditDateRange = (conflictRange2) => {
    setConflictRangeModalIsOpen(true);
    setDateRange(conflictRange2 || new DateRange());
  };
  const handleCloseEditDateRangeModal = () => {
    setConflictRangeModalIsOpen(false);
  };
  const handleDeleteDateRange = ({ id: id2 }) => {
    if (!id2)
      return;
    deleteOwnConflictRangeMutation(id2, loggedInId);
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx$1(Heading, { variant: "contentTitle", children: "Scheduling Conflicts" }),
    /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", my: 0, children: "Add your conflict dates here. These will appear on your profile, but will not affect your appearance in search results." }),
    /* @__PURE__ */ jsx$1(Divider, {}),
    /* @__PURE__ */ jsx$1(Spacer, {}),
    /* @__PURE__ */ jsxs(List, { flexDirection: "column", spacing: 0, children: [
      sortedDateRanges && sortedDateRanges.length ? /* @__PURE__ */ jsx$1(AnimatePresence, { children: sortedDateRanges.map((conflictRange2) => /* @__PURE__ */ jsx$1(
        ListItem,
        {
          as: motion.div,
          initial: { opacity: 1 },
          animate: { opacity: 1 },
          exit: { opacity: 0 },
          children: /* @__PURE__ */ jsxs(Flex, { alignItems: "center", justifyContent: "flex-start", gap: 2, children: [
            /* @__PURE__ */ jsx$1(
              Link,
              {
                href: "#",
                variant: "dotted",
                lineHeight: "normal",
                px: 0,
                flex: "auto",
                maxW: "full",
                bg: "none",
                height: "auto",
                w: "100%",
                borderRadius: "none",
                onClick: () => handleEditDateRange(conflictRange2),
                children: conflictRange2.toString("long")
              }
            ),
            /* @__PURE__ */ jsx$1(Spacer, {}),
            /* @__PURE__ */ jsx$1(
              TooltipIconButton,
              {
                icon: /* @__PURE__ */ jsx$1(FiDelete, {}),
                size: "sm",
                label: "Remove date range",
                onClick: () => handleDeleteDateRange(conflictRange2),
                colorScheme: "red"
              }
            )
          ] })
        },
        conflictRange2.toString()
      )) }) : false,
      /* @__PURE__ */ jsx$1(Button, { onClick: () => handleEditDateRange(), leftIcon: /* @__PURE__ */ jsx$1(FiPlus, {}), size: "sm", mt: 2, children: "Add Dates" }),
      /* @__PURE__ */ jsx$1(
        EditConflictDateRangeModal,
        {
          conflictRange,
          allDateRanges: sortedDateRanges,
          isOpen: conflictRangeModalIsOpen,
          onClose: handleCloseEditDateRangeModal
        }
      )
    ] })
  ] });
}
function EditProfileView({ profile }) {
  const { editProfile, editProfileDispatch } = useContext(EditProfileContext);
  const [{ loggedInId, loggedInSlug }] = useViewer();
  const { colorMode } = useColorMode();
  const {
    firstName,
    lastName,
    pronouns,
    selfTitle,
    email,
    resume,
    image,
    description,
    homebase,
    website,
    multilingual,
    languages,
    socials,
    locations,
    education,
    willTravel,
    willTour,
    phone,
    unions,
    partnerDirectories,
    experienceLevels,
    genderIdentities,
    racialIdentities,
    personalIdentities,
    mediaVideo1,
    mediaVideo2,
    mediaImage1,
    mediaImage2,
    mediaImage3,
    mediaImage4,
    mediaImage5,
    mediaImage6,
    credits
  } = editProfile || {};
  const originalProfile = useRef(null);
  const [hasEditedProfile, setHasEditedProfile] = useState(false);
  const [fieldCurrentlyUploading, setFieldCurrentlyUploading] = useState("");
  const [fieldCurrentlyClearing, setFieldCurrentlyClearing] = useState("");
  const [resumePreview, setResumePreview] = useState("");
  const [editCredit, setEditCredit] = useState("");
  const editCreditId = useRef("");
  const [creditsSorted, setCreditsSorted] = useState([]);
  const [hasEditedCreditOrder, setHasEditedCreditOrder] = useState(false);
  const [isLargerThanMd] = useMediaQuery("(min-width: 48rem)");
  const {
    uploadFileMutation,
    results: {
      data: { uploadFile: { fileUrl: uploadedResumePreview = "" } = {} } = {},
      loading: uploadFileMutationLoading
    } = {}
  } = useFileUpload();
  const {
    clearProfileFieldMutation,
    results: { loading: clearProfileFieldMutationLoading }
  } = useClearProfileField();
  const { updateCreditOrderMutation } = useUpdateCreditOrder();
  const {
    deleteCreditMutation,
    results: { loading: deleteCreditLoading }
  } = useDeleteCredit();
  const [errorCode, setErrorCode] = useState("");
  const errorMessage = useErrorMessage(errorCode);
  const [isAnyInputDebouncing, setIsAnyInputDebouncing] = useState(false);
  const debouncingInputs = useRef(/* @__PURE__ */ new Set());
  const handleDebounceStart = (inputName) => {
    debouncingInputs.current.add(inputName);
    setIsAnyInputDebouncing(true);
  };
  const handleDebounceEnd = (inputName) => {
    debouncingInputs.current.delete(inputName);
    if (debouncingInputs.current.size === 0) {
      setIsAnyInputDebouncing(false);
    }
  };
  useEffect(() => {
    if (!originalProfile.current)
      return;
    setHasEditedProfile(hasProfileChanged(editProfile, originalProfile.current));
    return () => setHasEditedProfile(false);
  }, [editProfile, originalProfile.current]);
  useEffect(() => {
    if (multilingual && !languages) {
      setErrorCode("multilingual_no_languages");
    }
    return () => setErrorCode("");
  });
  const {
    isOpen: creditModalIsOpen,
    onOpen: creditModalOnOpen,
    onClose: creditModalOnClose
  } = useDisclosure();
  const { mediaItem } = useResumePreview(resume ? resume : "");
  const { sourceUrl: retrievedResumePreview } = mediaItem || "";
  useEffect(() => {
    if (!resume) {
      setResumePreview("");
      return;
    }
    if (retrievedResumePreview) {
      setResumePreview(retrievedResumePreview);
    } else if (uploadedResumePreview) {
      setResumePreview(uploadedResumePreview);
    }
  }, [resume, retrievedResumePreview]);
  useEffect(() => {
    if (!editProfile || !!originalProfile.current)
      return;
    originalProfile.current = editProfile;
  }, [editProfile]);
  useEffect(() => {
    if (!hasEditedCreditOrder)
      return;
    const timeout = setTimeout(() => {
      updateCreditOrderMutation(creditsSorted.map((credit) => credit.id)).then((result) => {
        const newOrder = result.data.updateCreditOrder.creditIds.map(
          (id2) => creditsSorted.find((credit) => credit.id === id2)
        );
        setCreditsSorted(newOrder);
        setHasEditedCreditOrder(false);
      }).catch((err) => console.error(err));
    }, 500);
    return () => {
      clearTimeout(timeout);
      setHasEditedCreditOrder(false);
    };
  }, [hasEditedCreditOrder]);
  useEffect(() => {
    if (!credits || !credits.length)
      return;
    const newCredit = credits.find((credit) => credit.isNew);
    if (newCredit && newCredit.id !== editCreditId.current) {
      setEditCredit(newCredit.id);
      creditModalOnOpen();
    }
    return () => {
      setEditCredit("");
    };
  }, [credits]);
  useEffect(() => {
    if (!credits)
      return;
    if (credits.length > 0) {
      const existingCredits = credits.filter((credit) => !credit.isNew);
      setCreditsSorted(sortCreditsByIndex(existingCredits));
    } else if (credits.length === 0) {
      setCreditsSorted([]);
    }
    return () => {
      setCreditsSorted([]);
    };
  }, [credits]);
  const handleCreditMoveUp = (index) => {
    if (index === 0)
      return;
    const newOrder = [...creditsSorted];
    const temp = newOrder[index - 1];
    newOrder[index - 1] = newOrder[index];
    newOrder[index] = temp;
    setCreditsSorted(newOrder);
    setHasEditedCreditOrder(true);
  };
  const handleCreditMoveDown = (index) => {
    if (index === creditsSorted.length - 1)
      return;
    const newOrder = [...creditsSorted];
    const temp = newOrder[index + 1];
    newOrder[index + 1] = newOrder[index];
    newOrder[index] = temp;
    setCreditsSorted(newOrder);
    setHasEditedCreditOrder(true);
  };
  const [
    {
      locations: locationTerms,
      unions: unionTerms,
      partnerDirectories: partnerDirectoryTerms,
      experienceLevels: experienceLevelTerms,
      genderIdentities: genderIdentityTerms,
      personalIdentities: personalIdentityTerms,
      racialIdentities: racialIdentityTerms
    }
  ] = useUserTaxonomies();
  const {
    updateProfileMutation,
    results: { loading: saveLoading }
  } = useUpdateProfile();
  const toast = useToast();
  const navigate = useNavigate();
  useEffect(() => {
    if (profile) {
      editProfileDispatch({ type: "INIT", payload: { profile } });
    }
  }, [profile]);
  const handleCheckboxGroupChange = (name2) => (newValue) => {
    editProfileDispatch({
      type: "UPDATE_INPUT",
      payload: {
        name: name2,
        value: newValue
      }
    });
  };
  const handleInputChange = (event) => {
    if (!("target" in event) || !("name" in event.target) || !("value" in event.target))
      return;
    const { name: name2, value } = event.target;
    editProfileDispatch({
      type: "UPDATE_INPUT",
      payload: {
        name: name2,
        value
      }
    });
  };
  const handleSocialInputChange = (event) => {
    const { name: name2, value } = event.target;
    const field = name2.split(".")[1];
    editProfileDispatch({
      type: "UPDATE_PERSONAL_LINKS_INPUT",
      payload: {
        name: field,
        value
      }
    });
  };
  const handleCheckboxChange = (event) => {
    const { name: name2, checked } = event.target;
    editProfileDispatch({
      type: "UPDATE_BOOLEAN_INPUT",
      payload: {
        name: name2,
        value: checked
      }
    });
  };
  const handleRadioGroupInputChange = (name2) => (newValue) => {
    editProfileDispatch({
      type: "UPDATE_BOOLEAN_INPUT",
      payload: {
        name: name2,
        value: newValue
      }
    });
  };
  const handleFileInputChange = (event) => {
    if (!("files" in event.target))
      return;
    const target = event.target;
    if (!target.files)
      return;
    const { name: name2, files, accept } = target;
    const file = files[0];
    const maxSize = 2 * 1024 * 1024;
    if (accept && !accept.includes(file.type)) {
      toast({
        title: "Invalid file type.",
        position: "bottom",
        description: "Please upload a valid file type.",
        status: "error",
        duration: 3e3,
        isClosable: true
      });
      return;
    }
    if (maxSize < file.size) {
      toast({
        title: "File too large.",
        position: "bottom",
        description: "Please upload a file smaller than 2MB.",
        status: "error",
        duration: 3e3,
        isClosable: true
      });
      return;
    }
    setFieldCurrentlyUploading(name2);
    uploadFileMutation(file, name2, loggedInId).then((result) => {
      editProfileDispatch({
        type: "UPDATE_INPUT",
        payload: {
          name: name2,
          value: result.data.uploadFile.fileUrl
        }
      });
      setFieldCurrentlyUploading("");
      toast({
        title: "Image uploaded!",
        position: "bottom",
        description: "Your image has been saved.",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    }).catch((err) => {
      console.error(err);
    });
  };
  const handleFileUpload = (file, name2) => {
    if (!file)
      return;
    const maxSize = 2 * 1024 * 1024;
    if (maxSize < file.size) {
      toast({
        title: "File too large.",
        position: "bottom",
        description: "Please upload a file smaller than 2MB.",
        status: "error",
        duration: 3e3,
        isClosable: true
      });
      return;
    }
    setFieldCurrentlyUploading(name2);
    uploadFileMutation(file, name2, loggedInId).then((result) => {
      editProfileDispatch({
        type: "UPDATE_INPUT",
        payload: {
          name: name2,
          value: result.data.uploadFile.fileUrl
        }
      });
      setFieldCurrentlyUploading("");
      toast({
        title: "Image uploaded!",
        position: "bottom",
        description: "Your image has been saved.",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
    }).catch((err) => {
      console.error(err);
    });
  };
  const handleFileInputClear = (event) => {
    const {
      dataset: { field: fieldName }
    } = event.currentTarget;
    if (!fieldName)
      return;
    setFieldCurrentlyClearing(fieldName);
    clearProfileFieldMutation(loggedInId, fieldName).then((result) => {
      const imageInputs = [
        image,
        mediaImage1,
        mediaImage2,
        mediaImage3,
        mediaImage4,
        mediaImage5,
        mediaImage6
      ];
      const description2 = imageInputs.includes(fieldName) ? "The image has been removed." : "The file has been removed.";
      toast({
        title: "Success!",
        position: "bottom",
        description: description2,
        status: "success",
        duration: 3e3,
        isClosable: true
      });
      editProfileDispatch({
        type: "UPDATE_INPUT",
        payload: {
          name: fieldName,
          value: ""
        }
      });
      setFieldCurrentlyClearing("");
    });
  };
  const handleNewCredit = () => {
    editProfileDispatch({
      type: "ADD_NEW_CREDIT",
      payload: {}
    });
  };
  const handleDeleteCredit = (creditId) => {
    if (creditId !== "") {
      deleteCreditMutation(creditId, loggedInId).then(() => {
        toast({
          title: "Credit deleted.",
          // description: 'Your credit has been deleted.',
          status: "success",
          duration: 3e3,
          isClosable: true,
          position: "bottom"
        });
      }).catch((err) => {
        console.error(err);
      });
    }
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    const submitForm = () => {
      if (isAnyInputDebouncing) {
        setTimeout(submitForm, 50);
        return;
      }
      if (!Boolean(locations.length)) {
        toast({
          title: "Missing required field.",
          description: "Please select at least one work location.",
          status: "error",
          duration: 3e3,
          isClosable: true,
          position: "bottom"
        });
        return;
      }
      updateProfileMutation(editProfile).then(() => {
        navigate(`/profile/${loggedInSlug}`);
      }).then(() => {
        toast({
          title: "Updated!",
          description: "Your changes have been saved.",
          status: "success",
          duration: 3e3,
          isClosable: true,
          position: "bottom"
        });
      }).catch((err) => {
        toast({
          title: "Oops!",
          description: "There was an error saving your profile: " + err,
          status: "error",
          duration: 3e3,
          isClosable: true,
          position: "bottom"
        });
      });
    };
    submitForm();
  };
  const handleEditCredit = (creditId) => {
    setEditCredit(creditId);
    creditModalOnOpen();
  };
  const handleCloseEditCredit = () => {
    editCreditId.current = "";
    if (editCredit && credits) {
      const credit = credits.find((credit2) => credit2.id === editCredit);
      if (credit && credit.isNew) {
        editProfileDispatch({
          type: "DELETE_CREDIT",
          payload: {
            creditId: editCredit
          }
        });
      }
    }
    creditModalOnClose();
  };
  const ClearFieldButton = ({
    field,
    icon = /* @__PURE__ */ jsx$1(FiTrash2, {}),
    label,
    children,
    ...props
  }) => {
    if (!field)
      return null;
    return /* @__PURE__ */ jsx$1(
      Button,
      {
        leftIcon: icon ? icon : void 0,
        size: "md",
        colorScheme: "orange",
        onClick: handleFileInputClear,
        "aria-label": label,
        "data-field": field,
        isLoading: clearProfileFieldMutationLoading && fieldCurrentlyClearing === field,
        ...props,
        children
      }
    );
  };
  const ProgressSpinner = () => /* @__PURE__ */ jsx$1(Spinner, { thickness: "5px", speed: ".8s", color: "blue.500", size: "xl" });
  const Sidebar = ({ ...props }) => /* @__PURE__ */ jsxs(Box, { ...props, children: [
    /* @__PURE__ */ jsxs(Box, { children: [
      /* @__PURE__ */ jsx$1(Heading, { variant: "pageSubtitle", my: 0, children: "Profile image" }),
      /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", m: 0, children: "Portrait orientation works best. Max 2MB." }),
      /* @__PURE__ */ jsx$1(Box, { maxW: "300px", children: uploadFileMutationLoading && fieldCurrentlyUploading === "image" ? (
        // Uploading
        /* @__PURE__ */ jsx$1(Flex, { alignItems: "center", justifyContent: "center", h: "200px", children: /* @__PURE__ */ jsx$1(ProgressSpinner, {}) })
      ) : image ? (
        // Image set
        /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(
            Image$1,
            {
              src: image,
              alt: `Profile picture`,
              loading: "eager",
              fit: "cover",
              borderRadius: "md"
            }
          ),
          /* @__PURE__ */ jsx$1(ClearFieldButton, { field: "image", label: "Remove image", mt: 2, children: "Remove" })
        ] })
      ) : /* @__PURE__ */ jsx$1(
        FileDropzone,
        {
          fieldName: "image",
          text: "Profile image",
          icon: FiUser,
          h: "full",
          iconProps: { mb: 2, boxSize: "80px" }
        }
      ) })
    ] }),
    /* @__PURE__ */ jsx$1(Card, { children: /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsx$1(EditConflictDateRanges, {}) }) })
  ] });
  const FileDropzone = ({
    fieldName,
    text,
    icon = FiUpload,
    allowPdf = false,
    iconProps,
    ...props
  }) => {
    const [dragActive, setDragActive] = useState(false);
    const onDragOver = () => setDragActive(true);
    const onDragEnter = () => setDragActive(true);
    const onDragLeave = () => setDragActive(false);
    const onDrop = (acceptedFiles) => {
      setDragActive(false);
      handleFileUpload(acceptedFiles[0], fieldName);
    };
    const accept = {
      "image/jpeg": [],
      "image/png": [],
      "image/gif": [],
      "image/webp": []
    };
    if (allowPdf) {
      accept["application/pdf"] = [];
    }
    const { getRootProps, getInputProps } = useDropzone({
      accept,
      onDrop,
      onDragLeave,
      onDragOver,
      onDragEnter
    });
    const acceptString = allowPdf ? "JPG, PNG, GIF, WEBP, or PDF up to 2MB" : "JPG, PNG, GIF, or WEBP up to 2MB";
    const imageData = {
      image,
      resume,
      mediaImage1,
      mediaImage2,
      mediaImage3,
      mediaImage4,
      mediaImage5,
      mediaImage6
    };
    const currentImage = imageData[fieldName];
    return /* @__PURE__ */ jsx$1(Box, { maxW: "100%", p: 0, borderRadius: "md", ...props, children: currentImage ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(
        Image$1,
        {
          src: currentImage,
          alt: text,
          loading: "eager",
          fit: "cover",
          w: "full",
          borderRadius: "md",
          mb: 1
        }
      ),
      /* @__PURE__ */ jsxs(
        Flex,
        {
          gap: 2,
          flexWrap: { base: "wrap", sm: "nowrap" },
          justifyContent: "space-between",
          children: [
            /* @__PURE__ */ jsx$1(
              FileUploadButton,
              {
                fieldName,
                icon: /* @__PURE__ */ jsx$1(FiImage, {}),
                accept: "image/jpeg,image/png,image/gif,image/webp",
                onChange: handleFileInputChange,
                loading: uploadFileMutationLoading || clearProfileFieldMutationLoading,
                flex: "1 0 48%",
                children: /* @__PURE__ */ jsx$1(Text, { children: "Replace" })
              }
            ),
            /* @__PURE__ */ jsx$1(ClearFieldButton, { field: fieldName, label: "Delete image", flex: "1 0 48%", children: "Delete" })
          ]
        }
      )
    ] }) : uploadFileMutationLoading && fieldCurrentlyUploading === fieldName ? /* @__PURE__ */ jsx$1(Flex, { alignItems: "center", justifyContent: "center", padding: 50, children: /* @__PURE__ */ jsx$1(ProgressSpinner, {}) }) : /* @__PURE__ */ jsxs(
      Flex,
      {
        ...getRootProps({ width: "100%" }),
        h: "100%",
        w: "100%",
        padding: 5,
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        transition: "background-color 50ms ease",
        cursor: "pointer",
        borderWidth: "2px",
        borderRadius: "md",
        borderStyle: "dashed",
        _light: {
          backgroundColor: dragActive ? "blackAlpha.200" : "blackAlpha.50",
          borderColor: "blackAlpha.700"
        },
        _dark: {
          backgroundColor: dragActive ? "whiteAlpha.600" : "blackAlpha.400",
          borderColor: "text.light"
        },
        children: [
          /* @__PURE__ */ jsx$1(Input, { ...getInputProps({ type: "file" }) }),
          icon ? /* @__PURE__ */ jsx$1(Icon, { as: icon, boxSize: 10, ...iconProps }) : false,
          /* @__PURE__ */ jsx$1(Text, { textAlign: "center", children: "Drag a file to upload, or click to choose." }),
          /* @__PURE__ */ jsx$1(Text, { fontSize: "xs", children: acceptString })
        ]
      }
    ) });
  };
  const NewCreditButton = () => {
    var _a;
    const newCredit = credits.find((credit) => credit.isNew);
    const max = 5;
    const limit = newCredit ? max + 1 : max;
    return /* @__PURE__ */ jsx$1(
      Button,
      {
        "aria-label": "Add a new credit",
        leftIcon: /* @__PURE__ */ jsx$1(FiPlus, {}),
        onClick: handleNewCredit,
        isDisabled: ((_a = editProfile.credits) == null ? void 0 : _a.length) === limit,
        children: "New Credit"
      }
    );
  };
  return editProfile ? /* @__PURE__ */ jsxs(chakra.form, { id: "edit-profile", onSubmit: handleSubmit, children: [
    /* @__PURE__ */ jsxs(Stack, { direction: "column", flexWrap: "nowrap", gap: 4, position: "relative", children: [
      /* @__PURE__ */ jsx$1(ProfileStackItem, { mt: 4, mb: 0, children: /* @__PURE__ */ jsx$1(Accordion, { allowToggle: true, children: /* @__PURE__ */ jsxs(AccordionItem, { children: [
        /* @__PURE__ */ jsx$1(Heading, { as: "h3", m: 0, children: /* @__PURE__ */ jsxs(AccordionButton, { children: [
          /* @__PURE__ */ jsx$1(Box, { as: "span", fontWeight: "normal", children: "Options" }),
          /* @__PURE__ */ jsx$1(AccordionIcon, {})
        ] }) }),
        /* @__PURE__ */ jsx$1(AccordionPanel, { children: /* @__PURE__ */ jsx$1(Flex, { justifyContent: "flex-start", gap: 4, children: /* @__PURE__ */ jsx$1(Card, { py: 2, my: 0, children: /* @__PURE__ */ jsx$1(DisableProfileToggle, { showHelperText: true, showLabel: true }) }) }) })
      ] }) }) }),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { children: /* @__PURE__ */ jsxs(Flex, { alignItems: "flex-start", flexWrap: "wrap", mt: 2, children: [
        isLargerThanMd ? /* @__PURE__ */ jsx$1(Sidebar, { mb: 2, width: "30%", minWidth: "300px", mr: 4 }) : false,
        /* @__PURE__ */ jsxs(Stack, { flex: "1", px: { base: 0, md: 4 }, w: "full", children: [
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Name", children: /* @__PURE__ */ jsxs(Flex, { alignItems: "flex-end", gap: 2, flexWrap: "wrap", w: "full", children: [
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                placeholder: "First",
                value: firstName,
                name: "firstName",
                isRequired: true,
                onChange: handleInputChange,
                flex: "1",
                label: "First name",
                minW: "200px",
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("firstName"),
                onDebounceEnd: () => handleDebounceEnd("firstName")
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                placeholder: "Last",
                value: lastName,
                name: "lastName",
                isRequired: true,
                onChange: handleInputChange,
                flex: "1",
                minW: "200px",
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("lastName"),
                onDebounceEnd: () => handleDebounceEnd("lastName")
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: pronouns,
                name: "pronouns",
                label: "Pronouns",
                onChange: handleInputChange,
                maxW: "150px",
                inputProps: {
                  size: "md",
                  tabIndex: 0
                },
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("pronouns"),
                onDebounceEnd: () => handleDebounceEnd("pronouns")
              }
            )
          ] }) }),
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Profession", children: /* @__PURE__ */ jsxs(Flex, { alignItems: "flex-start", gap: 2, flexWrap: "wrap", w: "full", mt: 4, children: [
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: selfTitle,
                name: "selfTitle",
                placeholder: "Title",
                label: "Title/Trade/Profession",
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiStar }),
                onChange: handleInputChange,
                maxLength: 50,
                flex: "1 0 48%",
                inputProps: {
                  tabIndex: 0
                },
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("selfTitle"),
                onDebounceEnd: () => handleDebounceEnd("selfTitle")
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                placeholder: "Home base",
                value: homebase,
                name: "homebase",
                label: "Where do you currently live?",
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiHome }),
                onChange: handleInputChange,
                maxLength: 25,
                flex: "1 0 48%",
                inputProps: {
                  tabIndex: 0
                },
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("homebase"),
                onDebounceEnd: () => handleDebounceEnd("homebase")
              }
            )
          ] }) }),
          !isLargerThanMd ? /* @__PURE__ */ jsx$1(ProfileStackItem, { display: "flex", flexWrap: "wrap", gap: 4, children: /* @__PURE__ */ jsx$1(Sidebar, {}) }) : false,
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Contact", children: /* @__PURE__ */ jsxs(Stack, { direction: "column", children: [
            /* @__PURE__ */ jsx$1(
              Box,
              {
                as: TextInput,
                value: email,
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiMail }),
                placeholder: "me@somewhere.com",
                label: "Contact Email",
                name: "email",
                onChange: handleInputChange,
                inputProps: {
                  tabIndex: 0
                },
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("email"),
                onDebounceEnd: () => handleDebounceEnd("email")
              }
            ),
            /* @__PURE__ */ jsx$1(
              Box,
              {
                as: TextInput,
                value: phone,
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiPhone }),
                placeholder: "(888) 888-8888",
                label: "Phone",
                name: "phone",
                onChange: handleInputChange,
                inputProps: {
                  tabIndex: 0
                },
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("phone"),
                onDebounceEnd: () => handleDebounceEnd("phone")
              }
            ),
            /* @__PURE__ */ jsx$1(
              Box,
              {
                as: TextInput,
                value: website,
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiLink }),
                label: "Website",
                name: "website",
                onChange: handleInputChange,
                inputProps: {
                  tabIndex: 0
                },
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("website"),
                onDebounceEnd: () => handleDebounceEnd("website")
              }
            )
          ] }) }),
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Additional Languages", w: "full", maxW: "3xl", mt: 4, children: /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx$1(
              Checkbox,
              {
                name: "multilingual",
                isChecked: multilingual,
                onChange: handleCheckboxChange,
                variant: "buttonStyle",
                position: "relative",
                children: "I speak more than one language"
              }
            ),
            /* @__PURE__ */ jsx$1(Collapse, { in: multilingual, children: /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: languages,
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiGlobe }),
                label: "What languages other than English do you speak?",
                placeholder: "Spanish, Italian, Esperanto...",
                name: "languages",
                error: errorMessage,
                onChange: handleInputChange,
                mt: 2,
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("languages"),
                onDebounceEnd: () => handleDebounceEnd("languages")
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Social", w: "full", maxW: "3xl", mt: 4, children: /* @__PURE__ */ jsxs(SimpleGrid, { columns: [1, 2], spacing: 4, children: [
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: socials == null ? void 0 : socials.linkedin,
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiLinkedin }),
                label: "LinkedIn URL",
                placeholder: "https://linkedin/in/yourprofile",
                name: "socials.linkedin",
                onChange: handleSocialInputChange,
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("socials.linkedin"),
                onDebounceEnd: () => handleDebounceEnd("socials.linkedin")
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: socials == null ? void 0 : socials.facebook,
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiFacebook }),
                label: "Facebook URL",
                placeholder: "https://facebook.com/yourname",
                name: "socials.facebook",
                onChange: handleSocialInputChange,
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("socials.facebook"),
                onDebounceEnd: () => handleDebounceEnd("socials.facebook")
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: socials == null ? void 0 : socials.instagram,
                leftElement: /* @__PURE__ */ jsx$1(Icon, { as: FiInstagram }),
                label: "Instagram @handle",
                placeholder: "@handle",
                name: "socials.instagram",
                onChange: handleSocialInputChange,
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("socials.instagram"),
                onDebounceEnd: () => handleDebounceEnd("socials.instagram")
              }
            ),
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: socials == null ? void 0 : socials.twitter,
                leftElement: /* @__PURE__ */ jsx$1(XIcon, {}),
                label: "X/Twitter @handle",
                placeholder: "@handle",
                name: "socials.twitter",
                onChange: handleSocialInputChange,
                debounceTime: 300,
                onDebounceStart: () => handleDebounceStart("socials.twitter"),
                onDebounceEnd: () => handleDebounceEnd("socials.twitter")
              }
            )
          ] }) })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Work Locations", fontSize: "sm", children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "Select any areas in which you're a local hire." }),
        /* @__PURE__ */ jsx$1(
          ProfileCheckboxGroup,
          {
            name: "locations",
            isRequired: true,
            requiredMessage: "Please select at least one location.",
            items: locationTerms,
            checked: locations ? locations.map((item) => item.toString()) : [],
            handleChange: handleCheckboxGroupChange
          }
        )
      ] }) }),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { py: 4, display: "flex", gap: 10, children: /* @__PURE__ */ jsxs(Flex, { flexWrap: "wrap", gap: 8, justifyContent: "space-between", children: [
        /* @__PURE__ */ jsxs(Box, { children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentTitle", children: "Travel" }),
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "Would you work away from home?" }),
          /* @__PURE__ */ jsx$1(
            ProfileRadioGroup,
            {
              defaultValue: willTravel ? "true" : "false",
              name: "willTravel",
              items: [
                { label: "Yes", value: "true" },
                { label: "No", value: "false" }
              ],
              handleChange: handleRadioGroupInputChange
            }
          )
        ] }),
        /* @__PURE__ */ jsxs(Box, { children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentTitle", children: "Tour" }),
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "Would you go on tour?" }),
          /* @__PURE__ */ jsx$1(
            ProfileRadioGroup,
            {
              defaultValue: willTour ? "true" : "false",
              name: "willTour",
              items: [
                { label: "Yes", value: "true" },
                { label: "No", value: "false" }
              ],
              handleChange: handleRadioGroupInputChange
            }
          )
        ] }),
        /* @__PURE__ */ jsxs(Box, { children: [
          /* @__PURE__ */ jsx$1(
            Heading,
            {
              variant: "contentTitle",
              flex: "0 0 100%",
              textAlign: "left",
              alignItems: "center",
              display: "flex",
              children: "Resume"
            }
          ),
          !resume && /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "PDF or image" }),
          resume && resumePreview ? /* @__PURE__ */ jsxs(Flex, { flexWrap: "wrap", children: [
            /* @__PURE__ */ jsx$1(
              ResumePreviewModal,
              {
                resumePreview,
                resumeLink: resume,
                w: "100%",
                maxW: "300px",
                mr: { base: 0, sm: 1 },
                mb: { base: 1, sm: 0 }
              }
            ),
            /* @__PURE__ */ jsx$1(ClearFieldButton, { field: "resume", label: "Delete resume", children: "Clear" })
          ] }) : /* @__PURE__ */ jsx$1(FileDropzone, { fieldName: "resume", text: "Resume", allowPdf: true })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { children: /* @__PURE__ */ jsxs(Stack, { display: "flex", gap: 4, children: [
        /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Unions/Guilds/Memberships", children: /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "What unions or guilds are you a member of?" }),
          /* @__PURE__ */ jsx$1(Box, { fontSize: "sm", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "unions",
              items: unionTerms,
              checked: unions ? unions.map((item) => item.toString()) : [],
              handleChange: handleCheckboxGroupChange
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Experience Levels", children: /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "At what levels have you worked?" }),
          /* @__PURE__ */ jsx$1(Box, { fontSize: "sm", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "experienceLevels",
              items: experienceLevelTerms,
              checked: experienceLevels ? experienceLevels.map((item) => item.toString()) : [],
              handleChange: handleCheckboxGroupChange
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Partner Directories", children: /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "Are you a member of one of our partner organizations?" }),
          /* @__PURE__ */ jsx$1(Box, { fontSize: "sm", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "partnerDirectories",
              items: partnerDirectoryTerms,
              checked: partnerDirectories ? partnerDirectories.map((item) => item.toString()) : [],
              handleChange: handleCheckboxGroupChange
            }
          ) })
        ] }) })
      ] }) }),
      /* @__PURE__ */ jsx$1(
        ProfileStackItem,
        {
          title: "Credits",
          centerlineColor: "brand.blue",
          pos: "relative",
          id: "credits",
          children: /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsxs(Text, { fontSize: "lg", children: [
              "Add your 5 best credits here.",
              " ",
              /* @__PURE__ */ jsx$1(Text, { as: "span", fontStyle: "italic", children: "You must have at least one credit to be listed in searches!" })
            ] }),
            /* @__PURE__ */ jsx$1(NewCreditButton, {}),
            deleteCreditLoading ? /* @__PURE__ */ jsx$1(Spinner, { size: "sm", colorScheme: "green" }) : creditsSorted.map((credit, index) => /* @__PURE__ */ jsxs(Stack, { direction: "row", alignItems: "center", children: [
              /* @__PURE__ */ jsx$1(
                CreditItem,
                {
                  credit,
                  onClick: () => handleEditCredit(credit.id),
                  isEditable: true,
                  width: "full"
                },
                index
              ),
              /* @__PURE__ */ jsxs(
                Stack,
                {
                  as: isLargerThanMd ? ButtonGroup : void 0,
                  gap: { base: 2, md: 0 },
                  direction: { base: "column", md: "row" },
                  children: [
                    /* @__PURE__ */ jsx$1(
                      TooltipIconButton,
                      {
                        colorScheme: "gray",
                        icon: /* @__PURE__ */ jsx$1(FiArrowUpCircle, {}),
                        label: "Move Credit up",
                        isDisabled: index === 0,
                        id: credit.id,
                        onClick: () => {
                          handleCreditMoveUp(index);
                        }
                      }
                    ),
                    /* @__PURE__ */ jsx$1(
                      TooltipIconButton,
                      {
                        colorScheme: "gray",
                        icon: /* @__PURE__ */ jsx$1(FiArrowDownCircle, {}),
                        label: "Move Credit down",
                        isDisabled: index === creditsSorted.length - 1,
                        id: credit.id,
                        onClick: () => {
                          handleCreditMoveDown(index);
                        }
                      }
                    ),
                    /* @__PURE__ */ jsx$1(DeleteCreditButton, { handleDeleteCredit, id: credit.id })
                  ]
                }
              )
            ] }, credit.id)),
            /* @__PURE__ */ jsx$1(
              EditCreditModal,
              {
                isOpen: creditModalIsOpen,
                onClose: handleCloseEditCredit,
                creditId: editCredit
              }
            )
          ] })
        }
      ),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "About", centerlineColor: "brand.orange", children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Heading, { variant: "contentTitle", children: "Bio" }),
        /* @__PURE__ */ jsx$1(Text, { my: 2, fontSize: "lg", children: "Write a little. Write a lot. It's up to you!" }),
        /* @__PURE__ */ jsx$1(
          TextareaInput,
          {
            value: description,
            name: "description",
            label: "Bio",
            labelHidden: true,
            mt: 2,
            mb: 4,
            onChange: handleInputChange,
            inputProps: {
              rows: 10
            },
            debounceTime: 300,
            onDebounceStart: () => handleDebounceStart("description"),
            onDebounceEnd: () => handleDebounceEnd("description")
          }
        )
      ] }) }),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Identity", centerlineColor: "brand.yellow", children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsxs(Text, { fontSize: "lg", children: [
          "The following optional fields will be ",
          /* @__PURE__ */ jsx$1("strong", { children: "searchable" }),
          ", but",
          " ",
          /* @__PURE__ */ jsx$1("em", { children: "will not appear" }),
          " on your public profile. Select any that apply."
        ] }),
        /* @__PURE__ */ jsxs(Stack, { direction: "row", mt: 4, gap: 2, flexWrap: "wrap", children: [
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Gender", flex: "1 0 33%", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "genderIdentities",
              items: genderIdentityTerms,
              checked: genderIdentities ? genderIdentities.map((item) => item.toString()) : [],
              handleChange: handleCheckboxGroupChange
            }
          ) }),
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Race/Ethnicity", flex: "1 0 33%", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "racialIdentities",
              items: racialIdentityTerms,
              checked: racialIdentities ? racialIdentities.map((item) => item.toString()) : [],
              handleChange: handleCheckboxGroupChange
            }
          ) }),
          /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Additional", flex: "1 0 33%", children: /* @__PURE__ */ jsx$1(
            ProfileCheckboxGroup,
            {
              name: "personalIdentities",
              items: personalIdentityTerms,
              checked: personalIdentities ? personalIdentities.map((item) => item.toString()) : [],
              handleChange: handleCheckboxGroupChange
            }
          ) })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Education + Training", centerlineColor: "brand.green", children: /* @__PURE__ */ jsx$1(
        TextareaInput,
        {
          value: education,
          name: "education",
          variant: "outline",
          label: "Education and training",
          labelHidden: true,
          onChange: handleInputChange,
          inputProps: {
            rows: 4
          },
          debounceTime: 300,
          onDebounceStart: () => handleDebounceStart("education"),
          onDebounceEnd: () => handleDebounceEnd("education")
        }
      ) }),
      /* @__PURE__ */ jsx$1(ProfileStackItem, { title: "Media", centerlineColor: "brand.blue", children: /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "Showcase your work with images and videos." }),
        /* @__PURE__ */ jsxs(Box, { children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentTitle", children: "Videos" }),
          /* @__PURE__ */ jsxs(SimpleGrid, { columns: [1, 2], spacing: 8, children: [
            /* @__PURE__ */ jsxs(Box, { children: [
              /* @__PURE__ */ jsx$1(
                TextInput,
                {
                  value: mediaVideo1,
                  name: "mediaVideo1",
                  label: "Video embed 1",
                  placeholder: "https://www.youtube.com/watch?v=M67E9mpwBpM",
                  leftElement: /* @__PURE__ */ jsx$1(FiVideo, {}),
                  onChange: handleInputChange,
                  debounceTime: 300,
                  onDebounceStart: () => handleDebounceStart("mediaVideo1"),
                  onDebounceEnd: () => handleDebounceEnd("mediaVideo1")
                }
              ),
              mediaVideo1 ? /* @__PURE__ */ jsx$1(Box, { position: "relative", paddingBottom: "56.25%", w: "full", children: /* @__PURE__ */ jsx$1(Box, { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", children: /* @__PURE__ */ jsx$1(ReactPlayer, { url: mediaVideo1, controls: true, width: "100%", height: "100%" }) }) }) : false
            ] }),
            /* @__PURE__ */ jsxs(Box, { children: [
              /* @__PURE__ */ jsx$1(
                TextInput,
                {
                  value: mediaVideo2,
                  name: "mediaVideo2",
                  label: "Video embed 2",
                  placeholder: "https://www.youtube.com/watch?v=eR8YUj3C9lI",
                  leftElement: /* @__PURE__ */ jsx$1(FiVideo, {}),
                  onChange: handleInputChange,
                  debounceTime: 300,
                  onDebounceStart: () => handleDebounceStart("mediaVideo2"),
                  onDebounceEnd: () => handleDebounceEnd("mediaVideo2")
                }
              ),
              mediaVideo2 ? /* @__PURE__ */ jsx$1(Box, { position: "relative", paddingBottom: "56.25%", w: "full", children: /* @__PURE__ */ jsx$1(Box, { position: "absolute", top: 0, left: 0, width: "100%", height: "100%", children: /* @__PURE__ */ jsx$1(ReactPlayer, { url: mediaVideo2, controls: true, width: "100%", height: "100%" }) }) }) : false
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxs(Box, { mt: 6, children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentTitle", children: "Images" }),
          /* @__PURE__ */ jsx$1(Text, { fontSize: "lg", mb: 0, children: "Allowed formats: jpg, png, gif, heic, or webp. 2MB or less, please." }),
          /* @__PURE__ */ jsx$1(Text, { variant: "notice", fontSize: "sm", fontStyle: "italic", mb: 4, children: "* By uploading images to your RISE profile, you acknowledge that you own the rights or are authorized to use these images as work samples." }),
          /* @__PURE__ */ jsxs(SimpleGrid, { columns: [1, 2, 3], spacing: 8, children: [
            /* @__PURE__ */ jsx$1(FileDropzone, { fieldName: "mediaImage1", text: "Image 1" }),
            /* @__PURE__ */ jsx$1(FileDropzone, { fieldName: "mediaImage2", text: "Image 2" }),
            /* @__PURE__ */ jsx$1(FileDropzone, { fieldName: "mediaImage3", text: "Image 3" }),
            /* @__PURE__ */ jsx$1(FileDropzone, { fieldName: "mediaImage4", text: "Image 4" }),
            /* @__PURE__ */ jsx$1(FileDropzone, { fieldName: "mediaImage5", text: "Image 5" }),
            /* @__PURE__ */ jsx$1(FileDropzone, { fieldName: "mediaImage6", text: "Image 6" })
          ] })
        ] })
      ] }) })
    ] }),
    /* @__PURE__ */ jsx$1(
      Slide,
      {
        in: hasEditedProfile === true,
        direction: "bottom",
        style: {
          position: "fixed",
          bottom: 0,
          left: 0,
          width: "full",
          backgroundColor: colorMode === "dark" ? "white" : "#222",
          borderTopWidth: "1px",
          borderTopColor: "gray.100",
          textAlign: "right",
          zIndex: 3
        },
        children: /* @__PURE__ */ jsx$1(
          Button,
          {
            type: "submit",
            form: "edit-profile",
            leftIcon: saveLoading ? void 0 : /* @__PURE__ */ jsx$1(FiSave, {}),
            "aria-label": "Save changes",
            colorScheme: "green",
            isDisabled: saveLoading || !!errorMessage,
            isLoading: !!saveLoading,
            size: "lg",
            mr: 4,
            my: 2,
            children: "Save Changes"
          }
        )
      }
    )
  ] }) : null;
}
const JumpToCreditsButton = forwardRef$1((props, ref) => {
  const handleClick = () => {
    const creditsElement = document.getElementById("credits");
    if (creditsElement) {
      creditsElement.scrollIntoView({ behavior: "smooth", block: "center", inline: "nearest" });
    }
  };
  return /* @__PURE__ */ jsx$1(
    Button,
    {
      onClick: handleClick,
      leftIcon: /* @__PURE__ */ jsx$1(FiArrowDown, {}),
      ref,
      title: "Scroll to Credits",
      textDecoration: "none",
      colorScheme: "blue",
      children: "Jump to Credits"
    }
  );
});
function EditProfile() {
  const [{ loggedInId }] = useViewer();
  const [profile, { loading, error }] = useUserProfile(loggedInId);
  const ref = useRef(null);
  const PageActions = () => /* @__PURE__ */ jsx$1(JumpToCreditsButton, { ref });
  return /* @__PURE__ */ jsx$1(Shell, { title: "Update Profile", actions: /* @__PURE__ */ jsx$1(PageActions, {}), children: /* @__PURE__ */ jsx$1(EditProfileContextProvider, { initialState: profile, children: profile && !loading && !error ? /* @__PURE__ */ jsx$1(EditProfileView, { profile }) : loading ? /* @__PURE__ */ jsx$1(Spinner, { alignSelf: "center" }) : error ? /* @__PURE__ */ jsx$1(ErrorAlert, { message: error.message }) : "" }) });
}
function TextCenterline({ children, ...props }) {
  return /* @__PURE__ */ jsxs(Box, { position: "relative", py: 2, ...props, children: [
    /* @__PURE__ */ jsx$1(Divider, {}),
    /* @__PURE__ */ jsx$1(
      Box,
      {
        position: "absolute",
        top: "50%",
        transform: "translateY(-50%)",
        left: 12,
        _dark: { bgColor: "gray.900" },
        _light: { bgColor: "gray.50" },
        px: "2",
        children
      }
    )
  ] });
}
function CandidateList({ userIds, inOrder }) {
  const [preparedCandidates, { loading, error }] = useCandidates(userIds);
  return /* @__PURE__ */ jsx$1(Fragment, { children: loading ? /* @__PURE__ */ jsx$1(Spinner, {}) : error ? /* @__PURE__ */ jsx$1(ErrorAlert, { message: error.message }) : /* @__PURE__ */ jsx$1(List, { alignItems: "left", h: "auto", w: "full", spacing: 4, children: inOrder ? userIds.map((id2) => {
    const candidate = preparedCandidates.find((candidate2) => candidate2.id === id2);
    return candidate ? /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(CandidateItem, { candidate }) }, id2) : null;
  }) : preparedCandidates.map((candidate) => /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(CandidateItem, { candidate }) }, candidate.id)) }) });
}
function SearchResultsView() {
  const {
    search: {
      filters: { filterSet },
      results: results2,
      savedSearch: { id: savedSearchId },
      searchWizardActive
    }
  } = useContext(SearchContext);
  const { jobDates } = filterSet;
  const [resultsCount, setResultsCount] = useState(results2.length);
  const [savedSearches] = useSavedSearches(savedSearchId ? [savedSearchId] : []);
  const [savedSearchTitle, setSavedSearchTitle] = useState("");
  useEffect(() => {
    setResultsCount(results2.length);
  }, [results2.length]);
  useEffect(() => {
    var _a;
    const title = (_a = savedSearches == null ? void 0 : savedSearches.find((search) => search.id === savedSearchId)) == null ? void 0 : _a.title;
    setSavedSearchTitle(title ? title : "");
    return () => {
      setSavedSearchTitle("");
    };
  }, [savedSearches, savedSearchId]);
  const resultsString = () => {
    return resultsCount === 0 ? "No results" : resultsCount === 1 ? "1 result" : `${resultsCount} results`;
  };
  const orderedResults = useMemo(() => {
    if (!resultsCount)
      return [];
    const resultsForSort = [...results2];
    const sortedResults = resultsForSort.sort((a, b) => {
      const { score: aScore } = a;
      const { score: bScore } = b;
      return aScore - bScore;
    });
    return sortedResults.map((item) => Number(item.id));
  }, [resultsCount, results2]);
  const ConflictDateLegend = () => {
    return jobDates && jobDates.startDate ? /* @__PURE__ */ jsx$1(Flex, { justifyContent: "flex-start", alignItems: "center", gap: 1, mb: 4, mt: 0, ml: 12, children: /* @__PURE__ */ jsx$1(
      InlineIconText,
      {
        text: "badge = Possible scheduling conflict",
        icon: /* @__PURE__ */ jsx$1(FiCalendar, {}),
        query: "badge",
        description: "Scheduling conflict"
      }
    ) }) : /* @__PURE__ */ jsx$1(Fragment, {});
  };
  const SavedSearchItemMemo = memo(SavedSearchItem);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    results2.length > 0 ? /* @__PURE__ */ jsxs(Box, { w: "auto", display: "inline-block", mt: 4, maxW: "600px", children: [
      /* @__PURE__ */ jsx$1(
        SavedSearchItemMemo,
        {
          searchTerms: filterSet,
          id: savedSearchId ? savedSearchId : 0,
          title: savedSearchTitle || void 0,
          showControls: false,
          showSaveButton: true,
          mb: 1,
          width: "100%"
        }
      ),
      /* @__PURE__ */ jsx$1(Text, { variant: "helperText", fontSize: "2xs", m: 0, children: /* @__PURE__ */ jsx$1(Link, { as: Link$1, to: "/searches", m: 0, children: "Manage your saved searches" }) })
    ] }) : false,
    resultsCount > 0 ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx$1(TextCenterline, { fontSize: "xl", children: resultsString() }),
      jobDates && jobDates.startDate ? /* @__PURE__ */ jsx$1(ConflictDateLegend, {}) : false
    ] }) : resultsCount === 0 && searchWizardActive ? /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", children: "No results." }) : /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", children: "Your search results will appear here after you Search." }),
    /* @__PURE__ */ jsx$1(CandidateList, { userIds: orderedResults, inOrder: true }),
    resultsCount > 100 ? /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", mt: 6, ml: 16, pl: 2, color: "gray.500", children: "Only showing the first 100 results. Try refining your search!" }) : null
  ] });
}
function Search() {
  return /* @__PURE__ */ jsx$1(Shell, { title: "Search Results", children: /* @__PURE__ */ jsx$1(SearchResultsView, {}) });
}
function StarredProfilesView() {
  return /* @__PURE__ */ jsx$1(StarredProfileList, { my: 8 });
}
function StarredProfiles() {
  const Description2 = () => /* @__PURE__ */ jsx$1(
    InlineIconText,
    {
      icon: /* @__PURE__ */ jsx$1(FiStar, {}),
      text: "Click the star button next to a profile to pin or unpin it.",
      query: "star",
      description: "star"
    }
  );
  return /* @__PURE__ */ jsx$1(Shell, { title: "Starred Profiles", description: /* @__PURE__ */ jsx$1(Description2, {}), children: /* @__PURE__ */ jsx$1(StarredProfilesView, {}) });
}
const MUTATE_CHANGE_PROFILE_SLUG = gql`
	mutation ChangeProfileSlug($userId: Int!, $newSlug: String!) {
		changeProfileSlug(input: { userId: $userId, newSlug: $newSlug }) {
			clientMutationId
			success
			slug
		}
	}
`;
const useChangeProfileSlug = () => {
  const [mutation, results2] = useMutation(MUTATE_CHANGE_PROFILE_SLUG);
  const changeProfileSlugMutation = (userId, newSlug) => {
    return mutation({
      variables: {
        clientMutationId: "changeProfileSlugMutation",
        userId,
        newSlug
      },
      refetchQueries: [{ query: QUERY_VIEWER, fetchPolicy: "network-only" }]
    });
  };
  return { changeProfileSlugMutation, results: results2 };
};
function ChangeProfileUrlView() {
  const [{ loggedInId: userId, loggedInSlug }] = useViewer();
  const [slug, setSlug] = useState(loggedInSlug);
  const [formIsValid, setFormIsValid] = useState(false);
  const [errorCode, setErrorCode] = useState("");
  const { onCopy, setValue: setCopyValue, hasCopied } = useClipboard("");
  const profileUrl = useProfileUrl(loggedInSlug);
  const toast = useToast();
  const {
    changeProfileSlugMutation,
    results: { loading: submitLoading }
  } = useChangeProfileSlug();
  const newSlugIsClean = useValidateProfileSlug(slug);
  const errorMessage = useErrorMessage(errorCode);
  const hasEditedSlug = slug !== loggedInSlug;
  useEffect(() => {
    setSlug(loggedInSlug);
  }, [loggedInSlug]);
  useEffect(() => {
    if (!slug)
      return;
    if (!newSlugIsClean) {
      setErrorCode("user_slug_invalid");
      setFormIsValid(false);
      return;
    }
    setFormIsValid(true);
    setErrorCode("");
    return () => {
      setFormIsValid(false);
    };
  }, [slug]);
  useEffect(() => {
    setCopyValue(profileUrl);
  }, [profileUrl]);
  const handleInputChange = (e) => {
    setSlug(e.target.value);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!loggedInSlug || !slug)
      return;
    changeProfileSlugMutation(userId, slug).then((res) => {
      setSlug(res.data.changeProfileSlug.slug);
      toast({
        title: "Updated!",
        position: "bottom",
        description: "Your handle has been updated.",
        status: "success",
        duration: 3e3,
        isClosable: true
      });
      setErrorCode("");
    }).catch((errors) => setErrorCode(errors.message));
  };
  return /* @__PURE__ */ jsx$1(Box, { borderRadius: "lg", w: "full", children: /* @__PURE__ */ jsxs(
    Flex,
    {
      gap: { base: 0, md: 4 },
      alignItems: "center",
      flexWrap: "wrap",
      justifyContent: "space-between",
      children: [
        /* @__PURE__ */ jsx$1(Box, { children: /* @__PURE__ */ jsxs(chakra.form, { onSubmit: handleSubmit, children: [
          /* @__PURE__ */ jsx$1(Heading, { variant: "contentSubtitle", children: "Profile handle" }),
          /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", lineHeight: "shorter", children: "Give yourself a memorable handle to make sharing your profile easy." }),
          /* @__PURE__ */ jsxs(Flex, { gap: 2, flexWrap: "wrap", w: "100%", alignItems: "flex-start", children: [
            /* @__PURE__ */ jsx$1(
              TextInput,
              {
                value: slug,
                name: "slug",
                id: "slug",
                maxW: "300px",
                mt: 0,
                label: "New profile tag",
                labelHidden: true,
                helperText: "Letters, numbers, dashes, and underscores.",
                error: errorMessage,
                isRequired: true,
                maxLength: 20,
                onChange: handleInputChange,
                inputProps: {
                  pl: 2
                },
                flex: "1"
              }
            ),
            /* @__PURE__ */ jsx$1(
              Button,
              {
                type: "submit",
                colorScheme: "green",
                isDisabled: !formIsValid || submitLoading || !hasEditedSlug,
                isLoading: submitLoading,
                children: "Save"
              }
            )
          ] })
        ] }) }),
        /* @__PURE__ */ jsx$1(Box, { flex: "auto", fontSize: "sm", children: /* @__PURE__ */ jsx$1(Box, { opacity: hasEditedSlug ? 0.8 : 1, children: /* @__PURE__ */ jsx$1(
          Button,
          {
            leftIcon: hasCopied ? /* @__PURE__ */ jsx$1(FiCheck, {}) : /* @__PURE__ */ jsx$1(FiCopy, {}),
            title: "Copy",
            onClick: onCopy,
            size: "sm",
            "aria-label": "Copy profile URL",
            isDisabled: !!hasEditedSlug,
            maxW: "100%",
            overflow: "hidden",
            colorScheme: "yellow",
            children: profileUrl
          }
        ) }) })
      ]
    }
  ) });
}
const MUTATE_CHANGE_USER_PASSWORD = gql`
	mutation ChangePassword(
		$currentPassword: String!
		$newPassword: String! = ""
		$username: String!
	) {
		changePassword(
			input: { currentPassword: $currentPassword, newPassword: $newPassword, username: $username }
		) {
			clientMutationId
			success
		}
	}
`;
const useChangeUserPassword = () => {
  const [mutation, results2] = useMutation(MUTATE_CHANGE_USER_PASSWORD);
  const changeUserPasswordMutation = (username, currentPassword, newPassword) => {
    return mutation({
      variables: {
        clientMutationId: "changeUserPasswordMutation",
        username,
        currentPassword,
        newPassword
      }
    });
  };
  return { changeUserPasswordMutation, results: results2 };
};
function ChangePasswordView() {
  const [{ email: username }] = useViewer();
  const [userFields, setUserFields] = useState({
    currentPassword: "",
    newPassword: "",
    confirmPassword: ""
  });
  const { currentPassword, newPassword, confirmPassword } = userFields;
  const [passwordsMatch, setPasswordsMatch] = useState(true);
  const [passwordStrongEnough, setPasswordStrongEnough] = useState(false);
  const [formIsValid, setFormIsValid] = useState(false);
  const [errorCode, setErrorCode] = useState("");
  const {
    changeUserPasswordMutation,
    results: { loading: submitLoading }
  } = useChangeUserPassword();
  const errorMessage = useErrorMessage(errorCode);
  const { logoutMutation } = useLogout();
  const newPasswordStrength = useValidatePassword(newPassword);
  useEffect(() => {
    setFormIsValid(false);
    if (!passwordsMatch)
      return setErrorCode("password_mismatch");
    else if (newPassword.length && !passwordStrongEnough)
      return setErrorCode("password_too_weak");
    else
      setFormIsValid(true);
    setErrorCode("");
  }, [passwordsMatch, newPassword, confirmPassword, passwordStrongEnough]);
  useEffect(() => {
    const timer = setTimeout(() => {
      setPasswordStrongEnough(newPasswordStrength === "strong");
      setPasswordsMatch(newPassword === confirmPassword);
    }, 500);
    return () => clearTimeout(timer);
  }, [newPassword, confirmPassword]);
  const handleInputChange = (e) => {
    setUserFields({
      ...userFields,
      [e.target.name]: e.target.value
    });
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!currentPassword || !newPassword || !passwordsMatch)
      return;
    changeUserPasswordMutation(username, currentPassword, newPassword).then(() => {
      setUserFields({
        currentPassword: "",
        newPassword: "",
        confirmPassword: ""
      });
      setErrorCode("");
      logoutMutation().then(() => {
        window.location.href = "/login?alert=Success! Please log in with your new password.&alertStatus=success";
      });
    }).catch((errors) => setErrorCode(errors.message));
  };
  return /* @__PURE__ */ jsxs(chakra.form, { onSubmit: handleSubmit, mt: 3, w: "full", children: [
    /* @__PURE__ */ jsx$1(Box, { my: 4, children: /* @__PURE__ */ jsx$1(
      TextInput,
      {
        value: currentPassword,
        name: "currentPassword",
        id: "currentPassword",
        variant: "filled",
        label: "Current password",
        isRequired: true,
        onChange: handleInputChange,
        error: errorCode === "incorrect_password" ? errorMessage : "",
        inputProps: {
          type: "password",
          autoComplete: "current-password"
        }
      }
    ) }),
    /* @__PURE__ */ jsxs(Card, { _dark: { bgColor: "gray.800" }, my: 8, gap: 6, children: [
      /* @__PURE__ */ jsxs(Flex, { alignItems: "center", mx: "auto", gap: 6, lineHeight: "normal", fontSize: "xs", pt: 1, children: [
        /* @__PURE__ */ jsx$1(Text, { m: 0, fontStyle: "italic", children: "Passwords must have at least:" }),
        /* @__PURE__ */ jsxs(List, { listStyleType: "disc", children: [
          /* @__PURE__ */ jsx$1(ListItem, { children: "one lowercase letter" }),
          /* @__PURE__ */ jsx$1(ListItem, { children: "one uppercase letter" }),
          /* @__PURE__ */ jsx$1(ListItem, { children: "one one number" }),
          /* @__PURE__ */ jsx$1(ListItem, { children: "one special character." })
        ] })
      ] }),
      /* @__PURE__ */ jsxs(Flex, { gap: 6, flexWrap: "wrap", children: [
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: newPassword,
            name: "newPassword",
            id: "newPassword",
            variant: "filled",
            label: "New password",
            isRequired: true,
            onChange: handleInputChange,
            error: errorCode && errorCode !== "incorrect_password" && errorCode !== "password_mismatch" ? errorMessage : "",
            flex: "1",
            inputProps: {
              type: "password",
              autoComplete: "new-password"
            }
          }
        ),
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: confirmPassword,
            name: "confirmPassword",
            id: "confirmPassword",
            type: "password",
            variant: "filled",
            label: "Confirm your new password",
            isRequired: true,
            error: errorCode && errorCode === "password_mismatch" && confirmPassword ? errorMessage : "",
            onChange: handleInputChange,
            flex: { base: "auto", md: "1" },
            inputProps: {
              type: "password",
              autoComplete: "new-password"
            }
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsx$1(Box, { mt: 4, children: /* @__PURE__ */ jsx$1(
      Button,
      {
        type: "submit",
        colorScheme: "orange",
        isDisabled: !formIsValid || submitLoading,
        isLoading: !!submitLoading,
        children: "Change password"
      }
    ) })
  ] });
}
const MUTATE_CHANGE_USER_EMAIL = gql`
	mutation ChangeEmail($newEmail: String!, $password: String!, $username: String!) {
		changeEmail(input: { newEmail: $newEmail, password: $password, username: $username }) {
			clientMutationId
			success
		}
	}
`;
const useChangeUserEmail = () => {
  const [mutation, results2] = useMutation(MUTATE_CHANGE_USER_EMAIL);
  const changeUserEmailMutation = (username, newEmail, password) => {
    return mutation({
      variables: {
        clientMutationId: "changeUserEmailMutation",
        username,
        newEmail,
        password
      },
      refetchQueries: [{ query: QUERY_VIEWER, fetchPolicy: "network-only" }]
    });
  };
  return { changeUserEmailMutation, results: results2 };
};
function ChangeEmailView({ onSubmitCallback }) {
  const [{ username, email: userEmail }] = useViewer();
  const [newEmail, setNewEmail] = useState("");
  const [password, setPassword] = useState("");
  const [emailIsValid, setEmailIsValid] = useState(false);
  const [submitLoading, setSubmitLoading] = useState(false);
  const [errorCode, setErrorCode] = useState("");
  const { changeUserEmailMutation } = useChangeUserEmail();
  const toast = useToast();
  const validateEmail = (email) => {
    const errorCode2 = [];
    if (email.toLocaleLowerCase() === userEmail.toLocaleLowerCase()) {
      errorCode2.push("This is your current email address.");
    }
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (re.test(String(email).toLowerCase()) === false) {
      errorCode2.push("Please enter a valid email address.");
    }
    setErrorCode(errorCode2.join("; "));
    return errorCode2.length === 0 ? true : false;
  };
  const handleEmailInputChange = (e) => {
    const email = e.target.value;
    setNewEmail(email);
    setEmailIsValid(validateEmail(email));
  };
  const handlePasswordInputChange = (e) => {
    const password2 = e.target.value;
    setPassword(password2);
  };
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!emailIsValid || !password)
      return;
    setSubmitLoading(true);
    changeUserEmailMutation(username, newEmail, password).then(() => {
      setNewEmail("");
      setErrorCode("");
      toast({
        title: "Updated!",
        position: "bottom",
        description: "Your new email address has been set.",
        status: "success",
        duration: 1500,
        isClosable: true
      });
    }).then(() => {
      if (onSubmitCallback !== void 0) {
        onSubmitCallback();
      }
    }).catch((error) => {
      setErrorCode(error.message);
    }).finally(() => {
      setSubmitLoading(false);
    });
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(Text, { mb: 4, fontSize: "md", lineHeight: "normal", children: [
      "Your account email is ",
      /* @__PURE__ */ jsx$1("em", { children: "not" }),
      " your profile's contact email. You can use a different email address to show on your Profile page without changing your account email.",
      " ",
      /* @__PURE__ */ jsxs(Link, { as: Link$1, to: "/profile/edit", color: "brand.blue", children: [
        "Edit your profile",
        " "
      ] }),
      " ",
      "to set a new contact email."
    ] }),
    /* @__PURE__ */ jsx$1(Divider, {}),
    /* @__PURE__ */ jsxs(chakra.form, { onSubmit: handleSubmit, mt: 3, w: "full", children: [
      /* @__PURE__ */ jsxs(Flex, { gap: 6, flexWrap: "wrap", children: [
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: newEmail,
            name: "newEmail",
            id: "newEmail",
            variant: "filled",
            label: "New email address",
            placeholder: obscureEmail(userEmail),
            isRequired: true,
            flex: "1",
            onChange: handleEmailInputChange,
            error: errorCode ? errorCode : "",
            inputProps: {
              type: "email",
              autoComplete: "email"
            }
          }
        ),
        /* @__PURE__ */ jsx$1(
          TextInput,
          {
            value: password,
            name: "password",
            id: "password",
            variant: "filled",
            label: "Your password",
            isRequired: true,
            flex: "1",
            onChange: handlePasswordInputChange,
            inputProps: {
              type: "password"
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsx$1(Box, { mt: 2, children: /* @__PURE__ */ jsx$1(
        Button,
        {
          type: "submit",
          colorScheme: "orange",
          isDisabled: !emailIsValid || !password || submitLoading,
          isLoading: submitLoading,
          children: "Update Email"
        }
      ) })
    ] })
  ] });
}
const MUTATE_DELETE_OWN_ACCOUNT = gql`
	mutation DeleteOwnAccount($userId: ID!) {
		deleteOwnAccount(input: { userId: $userId }) {
			result
		}
	}
`;
const useDeleteOwnAccount = () => {
  const [mutation, result] = useMutation(MUTATE_DELETE_OWN_ACCOUNT);
  const deleteOwnAccountMutation = (userId) => {
    return mutation({
      variables: {
        clientMutationId: "deleteOwnAccountMutation",
        userId
      }
    });
  };
  return { deleteOwnAccountMutation, result };
};
function DeleteAccountView({ onClose }) {
  const [{ loggedInId }] = useViewer();
  const { logoutMutation } = useLogout();
  const { deleteOwnAccountMutation, result: deleteOwnAccountResult } = useDeleteOwnAccount();
  const handleDeleteOwnAccount = () => {
    deleteOwnAccountMutation(loggedInId);
  };
  useEffect(() => {
    if (deleteOwnAccountResult.data) {
      onClose();
      toast({
        title: "Account deleted",
        description: "Your account and data have been permanently deleted. You can re-register at any time.",
        status: "success",
        duration: 2e3
      });
      setTimeout(() => {
        logoutMutation().then(() => {
          window.location.href = "/";
        });
      }, 2e3);
    }
  }, [deleteOwnAccountResult.data]);
  const toast = useToast();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx$1(Card, { variant: "important", children: /* @__PURE__ */ jsx$1(Text, { fontSize: "sm", lineHeight: "tall", m: 0, children: "To completely delete your account, click the 'Delete my account' button. Otherwise, click cancel. Your account and all data will be permanently deleted. You can re-register at any time." }) }),
    /* @__PURE__ */ jsxs(ButtonGroup, { mt: 4, children: [
      /* @__PURE__ */ jsx$1(Button, { colorScheme: "red", onClick: handleDeleteOwnAccount, children: "Delete my account" }),
      /* @__PURE__ */ jsx$1(Button, { colorScheme: "gray", onClick: onClose, children: "Cancel" })
    ] })
  ] });
}
function SettingsSection({
  title,
  children,
  ...props
}) {
  return /* @__PURE__ */ jsxs(Box, { mt: 4, mb: 8, mx: 0, flex: { base: "0 0 100%", md: "0 0 48%" }, ...props, children: [
    title ? /* @__PURE__ */ jsx$1(Heading, { as: "h3", variant: "pageSubtitle", fontSize: "2xl", children: title }) : false,
    /* @__PURE__ */ jsx$1(Card, { my: 4, pl: 4, children })
  ] });
}
const SettingsModal = ({ title, isOpen, onClose, children }) => {
  return /* @__PURE__ */ jsxs(Modal, { isOpen, onClose, scrollBehavior: "outside", size: "2xl", children: [
    /* @__PURE__ */ jsx$1(ModalOverlay, {}),
    /* @__PURE__ */ jsxs(ModalContent, { p: 6, children: [
      title ? /* @__PURE__ */ jsx$1(ModalHeader, { pb: 0, children: title }) : false,
      /* @__PURE__ */ jsx$1(ModalBody, { children }),
      /* @__PURE__ */ jsx$1(ModalCloseButton, {})
    ] })
  ] });
};
function SettingsView() {
  const {
    isOpen: isOpenPassword,
    onOpen: onOpenPassword,
    onClose: onClosePassword
  } = useDisclosure();
  const {
    isOpen: isOpenDeleteAccount,
    onOpen: onOpenDeleteAccount,
    onClose: onCloseDeleteAccount
  } = useDisclosure();
  const { isOpen: isOpenEmail, onOpen: onOpenEmail, onClose: onCloseEmail } = useDisclosure();
  const handlePasswordClick = () => {
    onOpenPassword();
  };
  const handleEmailClick = () => {
    onOpenEmail();
  };
  const handleEmailClose = () => {
    onCloseEmail();
  };
  return /* @__PURE__ */ jsxs(Container, { maxW: "4xl", pl: 0, mx: 0, children: [
    /* @__PURE__ */ jsx$1(SettingsSection, { title: "Account", children: /* @__PURE__ */ jsxs(Flex, { gap: 2, children: [
      /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsx$1(Button, { onClick: handleEmailClick, colorScheme: "gray", children: "Change your email address" }),
        /* @__PURE__ */ jsx$1(
          SettingsModal,
          {
            title: "Change your account email",
            isOpen: isOpenEmail,
            onClose: handleEmailClose,
            children: /* @__PURE__ */ jsx$1(ChangeEmailView, { onSubmitCallback: handleEmailClose })
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsx$1(Button, { onClick: handlePasswordClick, colorScheme: "gray", children: "Change your password" }),
        /* @__PURE__ */ jsx$1(
          SettingsModal,
          {
            title: "Change your password",
            isOpen: isOpenPassword,
            onClose: onClosePassword,
            children: /* @__PURE__ */ jsx$1(ChangePasswordView, {})
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsx$1(SettingsSection, { title: "Profile", children: /* @__PURE__ */ jsx$1(ChangeProfileUrlView, {}) }),
    /* @__PURE__ */ jsxs(SettingsSection, { title: "Options", children: [
      /* @__PURE__ */ jsx$1(DisableProfileToggle, { showHelperText: true, size: "lg" }),
      /* @__PURE__ */ jsx$1(DarkModeToggle, { showHelperText: true, size: "lg" })
    ] }),
    /* @__PURE__ */ jsxs(SettingsSection, { title: "Close your account", children: [
      /* @__PURE__ */ jsx$1(Text, { m: 0, children: "If you'd like to remove your account entirely, please use the button below. You can always re-register at any time." }),
      /* @__PURE__ */ jsx$1(ButtonGroup, { children: /* @__PURE__ */ jsx$1(Button, { colorScheme: "red", onClick: onOpenDeleteAccount, children: "Delete account" }) }),
      /* @__PURE__ */ jsx$1(
        SettingsModal,
        {
          title: "Delete your account",
          isOpen: isOpenDeleteAccount,
          onClose: onCloseDeleteAccount,
          children: /* @__PURE__ */ jsx$1(DeleteAccountView, { onClose: onCloseDeleteAccount })
        }
      )
    ] })
  ] });
}
function Settings() {
  return /* @__PURE__ */ jsx$1(Shell, { title: "Settings", children: /* @__PURE__ */ jsx$1(SettingsView, {}) });
}
function Help() {
  const EmailButton = () => /* @__PURE__ */ jsx$1(
    Button,
    {
      as: Link,
      href: "mailto:support@risetheatre.org",
      colorScheme: "red",
      leftIcon: /* @__PURE__ */ jsx$1(FiFlag, {}),
      size: "sm",
      children: "Contact Support"
    }
  );
  return /* @__PURE__ */ jsx$1(Shell, { title: "Help", actions: /* @__PURE__ */ jsx$1(EmailButton, {}), children: /* @__PURE__ */ jsx$1(PageView, { postId: "959" }) });
}
function LoggedIn({ hideOnly, children }) {
  const [{ loggedInId }, { loading }] = useViewer();
  const { pathname } = useLocation();
  const publicEndpoints = ["/register", "/login", "/lost-password", "/reset-password"];
  const showContent = !hideOnly && !loggedInId && publicEndpoints.includes(pathname) || loggedInId;
  return loading ? /* @__PURE__ */ jsx$1(Spinner, {}) : showContent ? /* @__PURE__ */ jsx$1(Fragment, { children }) : /* @__PURE__ */ jsx$1(Container, { p: 0, mt: 8, maxW: "4xl", children: /* @__PURE__ */ jsx$1(LoginView$1, { signInTitle: true }) });
}
function Notfound() {
  return /* @__PURE__ */ jsxs(Shell, { children: [
    /* @__PURE__ */ jsx$1(Heading, { variant: "pageTitle", as: "h2", children: "404, friend." }),
    /* @__PURE__ */ jsxs(Box, { children: [
      /* @__PURE__ */ jsx$1(Heading, { variant: "contentTitle", children: "We couldn't find that page." }),
      /* @__PURE__ */ jsx$1(LoggedIn, { hideOnly: true, children: /* @__PURE__ */ jsx$1(DashboardView__Widgets, {}) })
    ] })
  ] });
}
function SavedSearchesView() {
  return /* @__PURE__ */ jsx$1(SavedSearchItemList, { mt: 4 });
}
function SavedSearches() {
  return /* @__PURE__ */ jsx$1(
    Shell,
    {
      title: "Your Searches",
      description: 'Save your searches to easily repeat them. To save one, click the "Save" button at the top of\n				the Search Results page.',
      children: /* @__PURE__ */ jsx$1(SavedSearchesView, {})
    }
  );
}
function JobsList({ jobs, ...props }) {
  return /* @__PURE__ */ jsx$1(List, { ...props, children: jobs.map((job) => {
    const { id: id2, title, companyName, isInternship, isPaid, isUnion, compensation } = job;
    const datesString = job.endDate ? `${job.startDate} - ${job.endDate}` : `Starts ${job.startDate}`;
    return /* @__PURE__ */ jsx$1(ListItem, { children: /* @__PURE__ */ jsx$1(Card, { variant: "listItem", as: Link$1, to: `/job/${job.id}`, children: /* @__PURE__ */ jsxs(Stack, { gap: 2, children: [
      /* @__PURE__ */ jsxs(Heading, { as: "h3", fontSize: "3xl", my: 0, children: [
        /* @__PURE__ */ jsx$1(Text, { as: "span", mr: 4, children: title }),
        /* @__PURE__ */ jsx$1(Text, { as: "span", fontSize: "xl", children: companyName })
      ] }),
      /* @__PURE__ */ jsxs(Wrap, { children: [
        isInternship && /* @__PURE__ */ jsx$1(Tag, { colorScheme: "yellow", size: "sm", children: "Internship" }),
        isPaid && /* @__PURE__ */ jsx$1(Tag, { colorScheme: "green", size: "sm", children: "Paid" }),
        isUnion && /* @__PURE__ */ jsx$1(Tag, { colorScheme: "red", size: "sm", children: "Union" })
      ] }),
      compensation ? /* @__PURE__ */ jsx$1(Text, { children: compensation }) : "",
      /* @__PURE__ */ jsx$1(Text, { my: 0, children: datesString })
    ] }) }) }, id2);
  }) });
}
function JobsView({ jobs }) {
  return /* @__PURE__ */ jsxs(Stack, { spacing: 4, py: 4, children: [
    /* @__PURE__ */ jsx$1(
      Flex,
      {
        w: "full",
        border: "1px solid gray",
        bg: "gray.500",
        h: "70px",
        textAlign: "center",
        alignItems: "center",
        justifyContent: "center",
        children: "~~ Search/Filter ~~"
      }
    ),
    /* @__PURE__ */ jsx$1(JobsList, { jobs, mt: 2 })
  ] });
}
const QUERY_JOBS = gql`
	query JobsQuery($id: Int = 0) {
		jobs(where: { id: $id }) {
			nodes {
				id: databaseId
				companyName(format: RAW)
				companyAddress(format: RAW)
				contactEmail(format: RAW)
				contactName(format: RAW)
				contactPhone(format: RAW)
				startDate
				description: content
				compensation
				isInternship
				isPaid
				isUnion
				endDate
				instructions(format: RAW)
				applicationUrl
				applicationPhone
				applicationEmail
				title
			}
		}
	}
`;
const useJobPosts = (id2 = 0) => {
  var _a, _b, _c, _d, _e;
  const result = useQuery(QUERY_JOBS, {
    variables: { id: id2 }
  });
  if (!((_b = (_a = result == null ? void 0 : result.data) == null ? void 0 : _a.jobs) == null ? void 0 : _b.nodes)) {
    return [[], omit$1(result, ["data"])];
  }
  const jobs = ((_e = (_d = (_c = result == null ? void 0 : result.data) == null ? void 0 : _c.jobs) == null ? void 0 : _d.nodes) == null ? void 0 : _e.map((node) => {
    const {
      id: id22,
      title,
      companyName,
      contactEmail,
      contactName,
      compensation,
      startDate,
      companyAddress,
      instructions
    } = node;
    const job = new JobPost({
      id: id22,
      title,
      companyName,
      contactEmail,
      contactName,
      compensation,
      startDate,
      companyAddress,
      instructions
    });
    Object.assign(job, node);
    return job;
  })) ?? [];
  return [jobs, omit$1(result, ["data"])];
};
function Jobs$1() {
  const [jobs, { loading }] = useJobPosts();
  return /* @__PURE__ */ jsx$1(Shell, { title: "Jobs", loading, children: /* @__PURE__ */ jsx$1(JobsView, { jobs }) });
}
function JobView({ job }) {
  const {
    companyName,
    contactEmail,
    contactName,
    contactPhone,
    companyAddress,
    compensation,
    instructions,
    startDate,
    endDate,
    isInternship,
    isUnion,
    description,
    applicationUrl,
    applicationPhone,
    applicationEmail
  } = job || {};
  const parsedCompanyAddress = companyAddress ? parse$1(companyAddress) : "";
  const parsedDescription = description ? parse$1(description) : "";
  const parsedCompensation = compensation ? parse$1(compensation) : "";
  const parsedInstructions = instructions ? parse$1(instructions) : "";
  return /* @__PURE__ */ jsxs(Box, { children: [
    /* @__PURE__ */ jsxs(Wrap, { children: [
      /* @__PURE__ */ jsx$1(Heading, { as: "h2", fontSize: "xl", my: 0, children: companyName }),
      /* @__PURE__ */ jsxs(Flex, { alignItems: "center", gap: 2, children: [
        isInternship && /* @__PURE__ */ jsx$1(Tag, { colorScheme: "yellow", size: "sm", children: "Internship" }),
        isUnion && /* @__PURE__ */ jsx$1(Tag, { colorScheme: "red", size: "sm", children: "Union" })
      ] })
    ] }),
    /* @__PURE__ */ jsxs(Stack, { gap: 6, children: [
      /* @__PURE__ */ jsxs(Flex, { gap: 4, flexWrap: "wrap", children: [
        /* @__PURE__ */ jsx$1(Card, { gap: 0, children: parsedCompanyAddress ? /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiMap, children: /* @__PURE__ */ jsx$1(Tag, { size: "lg", whiteSpace: "pre-wrap", px: 2, py: 1, children: parsedCompanyAddress }) }),
          /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiCalendar, children: /* @__PURE__ */ jsx$1(Tag, { colorScheme: "green", children: `${startDate}${endDate ? ` - ${endDate}` : ""}` }) })
        ] }) : null }),
        /* @__PURE__ */ jsx$1(Card, { flex: 1, children: /* @__PURE__ */ jsxs(Stack, { gap: 2, children: [
          /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiUser, my: 0, children: contactName }),
          /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiMail, my: 0, children: /* @__PURE__ */ jsx$1(Link, { as: Link$1, to: `mailto:${contactEmail}`, my: 0, children: contactEmail }) }),
          contactPhone && /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiPhone, my: 0, children: /* @__PURE__ */ jsx$1(Link, { as: Link$1, to: `tel:${contactPhone}`, my: 0, children: contactPhone }) }),
          parsedCompensation && /* @__PURE__ */ jsx$1(WrapWithIcon, { icon: FiDollarSign, my: 0, children: /* @__PURE__ */ jsx$1(Text, { whiteSpace: "pre-wrap", my: 0, children: parsedCompensation }) })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsx$1(HeadingCenterline, { lineColor: "brand.orange", children: "Job Description" }),
        /* @__PURE__ */ jsx$1(Box, { className: "wp-post-content", children: parsedDescription })
      ] }),
      /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsx$1(HeadingCenterline, { lineColor: "brand.blue", children: "How to apply" }),
        parsedInstructions ? /* @__PURE__ */ jsx$1(Text, { children: parsedInstructions }) : null,
        /* @__PURE__ */ jsxs(ButtonGroup, { colorScheme: "blue", children: [
          applicationUrl ? /* @__PURE__ */ jsx$1(
            Button,
            {
              as: "a",
              href: applicationUrl,
              leftIcon: /* @__PURE__ */ jsx$1(FiExternalLink, {}),
              size: "md",
              target: "_blank",
              rel: "noopener noreferrer",
              children: "Apply Online"
            }
          ) : null,
          applicationPhone ? /* @__PURE__ */ jsxs(Button, { as: "a", href: `tel:${applicationPhone}`, leftIcon: /* @__PURE__ */ jsx$1(FiPhone, {}), size: "md", children: [
            "Call to Apply: ",
            applicationPhone
          ] }) : null,
          applicationEmail ? /* @__PURE__ */ jsxs(
            Button,
            {
              as: "a",
              href: `mailto:${applicationEmail}`,
              leftIcon: /* @__PURE__ */ jsx$1(FiMail, {}),
              size: "md",
              children: [
                "Email to Apply: ",
                applicationEmail
              ]
            }
          ) : null
        ] })
      ] })
    ] })
  ] });
}
function Jobs() {
  const params = useParams();
  const id2 = params.id ? params.id : "";
  const [job, { loading }] = useJobPosts(parseInt(id2));
  const title = !job.length ? "" : job[0].title;
  return /* @__PURE__ */ jsx$1(Shell, { title, loading: !!loading, children: /* @__PURE__ */ jsx$1(JobView, { job: job[0] }) });
}
const QUERY_NETWORK_PARTNERS = gql`
	query QueryNetworkPartners($id: Int = 0) {
		networkPartners(where: { id: $id }, last: 999) {
			nodes {
				id: databaseId
				slug
				title
				featuredImage {
					node {
						featuredImageId: databaseId
						srcSet(size: LARGE)
						title
					}
				}
				excerpt(format: RAW)
				content(format: RENDERED)
			}
		}
	}
`;
const useNetworkPartners = (id2 = 0) => {
  var _a, _b, _c;
  const result = useQuery(QUERY_NETWORK_PARTNERS, {
    variables: { id: id2 }
  });
  if (!((_b = (_a = result == null ? void 0 : result.data) == null ? void 0 : _a.networkPartners) == null ? void 0 : _b.nodes)) {
    return [[], omit$1(result, ["data"])];
  }
  const preparedPartners = ((_c = result.data) == null ? void 0 : _c.networkPartners.nodes.map((partner) => {
    var _a2, _b2, _c2;
    const { id: id22, slug, title, featuredImage, excerpt, content } = partner;
    return new WPPost({
      id: id22,
      slug,
      title,
      featuredImage: new WPAttachment({
        id: (_a2 = featuredImage == null ? void 0 : featuredImage.node) == null ? void 0 : _a2.featuredImageId,
        srcSet: (_b2 = featuredImage == null ? void 0 : featuredImage.node) == null ? void 0 : _b2.srcSet,
        title: (_c2 = featuredImage == null ? void 0 : featuredImage.node) == null ? void 0 : _c2.title
      }),
      excerpt,
      content
    });
  })) || [];
  return [preparedPartners, omit$1(result, ["data"])];
};
function NetworkPartnerList({ ...props }) {
  const [partners, { loading, error }] = useNetworkPartners();
  if (loading)
    return /* @__PURE__ */ jsx$1(Spinner, {});
  if (error)
    return /* @__PURE__ */ jsx$1(ErrorAlert, { message: error.message });
  return /* @__PURE__ */ jsx$1(SimpleGrid, { as: List, spacing: 6, minChildWidth: "300px", maxWidth: "5xl", mx: "auto", ...props, children: /* @__PURE__ */ jsx$1(AnimatePresence, { children: partners.map((partner) => /* @__PURE__ */ jsx$1(
    ListItem,
    {
      as: motion.li,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      exit: { opacity: 0 },
      children: /* @__PURE__ */ jsx$1(
        Link,
        {
          as: Link$1,
          to: `/partners/${partner.slug}`,
          textDecoration: "none",
          _hover: { textDecoration: "none" },
          color: "inherit",
          title: partner.title,
          rel: "bookmark",
          children: /* @__PURE__ */ jsx$1(
            Card,
            {
              variant: "listItem",
              pt: 4,
              pb: 5,
              px: 4,
              mx: 0,
              border: "1px solid",
              borderColor: "gray.200",
              _light: {
                bg: "gray.100",
                color: "text.dark",
                borderColor: "gray.200",
                _hover: { bg: "gray.200" }
              },
              _dark: {
                bg: "gray.700",
                color: "text.light",
                borderColor: "gray.600",
                _hover: { bg: "gray.600" }
              },
              transition: "background-color 150ms ease",
              children: /* @__PURE__ */ jsxs(Box, { children: [
                partner.featuredImage && /* @__PURE__ */ jsx$1(Box, { flex: "0 0 200px", children: /* @__PURE__ */ jsx$1(
                  Image$1,
                  {
                    srcSet: partner.featuredImage.srcSet,
                    alt: `Logo for ${partner.title || ""}`,
                    borderRadius: "md",
                    objectFit: "cover",
                    border: "1px solid",
                    backgroundColor: "gray.50",
                    _light: { borderColor: "gray.200" },
                    _dark: { borderColor: "gray.700" },
                    mb: 4
                  }
                ) }),
                partner.excerpt && /* @__PURE__ */ jsx$1(Text, { variant: "postExcerpt", textAlign: "center", children: parse$1(partner.excerpt) })
              ] })
            }
          )
        }
      )
    },
    partner.id
  )) }) });
}
function NetworkPartnersView() {
  const [light, dark, blue, yellow] = useToken("colors", [
    "bg.light",
    "bg.dark",
    "brand.blue",
    "brand.yellow"
  ]);
  const { colorMode } = useColorMode();
  return /* @__PURE__ */ jsxs(Box, { w: "100vw", position: "relative", left: "-1rem", children: [
    /* @__PURE__ */ jsx$1(
      Box,
      {
        position: "relative",
        width: "full",
        _after: {
          content: '""',
          position: "absolute",
          bottom: 0,
          left: 0,
          right: 0,
          height: "70px",
          background: `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 12' preserveAspectRatio='none'%3E%3Cpolygon fill='${colorMode === "light" ? encodeURIComponent(light) : encodeURIComponent(dark)}' points='0,2 50,8 100,2 100,12 0,12'/%3E%3Cpath fill='${encodeURIComponent(
            yellow
          )}' d='M-2,1.4 L50,7.4 L102,1.4 L102,2.6 L50,8.6 L-2,2.6 Z'/%3E%3C/svg%3E")`,
          backgroundSize: "100% 100%"
        },
        children: /* @__PURE__ */ jsx$1(Box, { w: "full", color: "text.light", children: /* @__PURE__ */ jsx$1(
          PageView,
          {
            postId: 15106,
            px: 4,
            py: 4,
            pb: 20,
            w: "4xl",
            bg: blue,
            textAlign: "center",
            fontSize: "xl",
            maxW: "full"
          }
        ) })
      }
    ),
    /* @__PURE__ */ jsx$1(
      Box,
      {
        position: "relative",
        width: "full",
        py: 8,
        _light: {
          bg: light
        },
        _dark: {
          bg: dark
        },
        children: /* @__PURE__ */ jsx$1(Container, { maxW: { base: "full", md: "5xl" }, px: 4, children: /* @__PURE__ */ jsx$1(NetworkPartnerList, {}) })
      }
    )
  ] });
}
function Partners() {
  console.info("Partners");
  return /* @__PURE__ */ jsx$1(Shell, { maxW: "none", bgColor: "brand.blue", fullWidthTemplate: true, children: /* @__PURE__ */ jsx$1(NetworkPartnersView, {}) });
}
const QUERY_NETWORK_PARTNER_ID = gql`
	query QueryNetworkPartnerIdBySlug($slug: String!) {
		networkPartnerIdBySlug(slug: $slug)
	}
`;
const useNetworkPartnerIdBySlug = (slug) => {
  const result = useQuery(QUERY_NETWORK_PARTNER_ID, {
    variables: {
      slug
    }
  });
  const { networkPartnerIdBySlug: networkPartnerId } = result.data || {};
  return [Number(networkPartnerId), omit$1(result, ["data"])];
};
function NetworkPartnerView({
  postId,
  titleProps,
  ...props
}) {
  const [pages] = useNetworkPartners(Number(postId));
  const [page, setPage] = useState(null);
  useEffect(() => {
    if (pages.length > 0 && !page) {
      setPage(pages[0]);
    }
  }, [pages, page]);
  const content = (page == null ? void 0 : page.content) ? parse$1(page.content) : null;
  return /* @__PURE__ */ jsxs(Container, { variant: "pageContent", className: "wp-post-content", ...props, children: [
    /* @__PURE__ */ jsx$1(Heading, { as: "h1", mb: 4, ...titleProps, children: page == null ? void 0 : page.title }),
    content
  ] });
}
function Partner() {
  const params = useParams();
  const slug = params.slug ? params.slug : "";
  const [networkPartnerId, { loading }] = useNetworkPartnerIdBySlug(slug);
  console.info("Partner", slug);
  return /* @__PURE__ */ jsx$1(Shell, { loading: !!loading, fullWidthTemplate: true, children: networkPartnerId && /* @__PURE__ */ jsx$1(NetworkPartnerView, { postId: networkPartnerId, titleProps: { textAlign: "center" } }) });
}
const QUERY_PAGE_BY_SLUG = gql`
	query QueryPageBySlug($name: String = "") {
		pages(where: { name: $name }) {
			nodes {
				id: databaseId
				content(format: RENDERED)
				title
				uri
			}
		}
	}
`;
const usePageBySlug = (slug) => {
  var _a;
  const result = useQuery(QUERY_PAGE_BY_SLUG, {
    variables: {
      slug
    }
  });
  const { id: id2, title, content, uri } = ((_a = result.data) == null ? void 0 : _a.pages.nodes[0]) || {};
  const preparedPage = new WPPost({
    id: id2,
    title,
    content,
    uri
  });
  return [preparedPage, omit$1(result, ["data"])];
};
function Page() {
  const params = useParams();
  const slug = params.slug ? params.slug : "";
  const [page, { loading }] = usePageBySlug(slug);
  return /* @__PURE__ */ jsx$1(Shell, { loading, fullWidthTemplate: true, children: page && /* @__PURE__ */ jsx$1(PageView, { postId: page.id }) });
}
function Main({ ...props }) {
  const routes = useRoutes([
    {
      path: "/",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(Dashboard, {}) })
    },
    {
      path: "/reset-password",
      element: /* @__PURE__ */ jsx$1(ResetPassword, {})
    },
    {
      path: "/profile/:slug",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(Profile, {}) })
    },
    {
      path: "/profile/edit",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(EditProfile, {}) })
    },
    {
      path: "/results",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(Search, {}) })
    },
    {
      path: "/starred",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(StarredProfiles, {}) })
    },
    {
      path: "/stars",
      element: /* @__PURE__ */ jsx$1(Navigate, { to: "/starred", replace: true })
    },
    {
      path: "/searches",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(SavedSearches, {}) })
    },
    {
      path: "/partners",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(Partners, {}) })
    },
    {
      path: "/partners/:slug",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(Partner, {}) })
    },
    {
      path: "/settings",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(Settings, {}) })
    },
    {
      path: "/help",
      element: /* @__PURE__ */ jsx$1(LoggedIn, { children: /* @__PURE__ */ jsx$1(Help, {}) })
    },
    {
      path: "/login",
      element: /* @__PURE__ */ jsx$1(Login, {})
    },
    {
      path: "/lost-password",
      element: /* @__PURE__ */ jsx$1(LostPassword, {})
    },
    {
      path: "/register",
      element: /* @__PURE__ */ jsx$1(Register, {})
    },
    {
      path: "/jobs",
      element: /* @__PURE__ */ jsx$1(Jobs$1, {})
    },
    {
      path: "/job/:id",
      element: /* @__PURE__ */ jsx$1(Jobs, {})
    },
    {
      path: "/:slug",
      element: /* @__PURE__ */ jsx$1(Page, {})
    },
    {
      path: "*",
      element: /* @__PURE__ */ jsx$1(Notfound, {})
    }
  ]);
  return /* @__PURE__ */ jsx$1(
    Box,
    {
      id: "main",
      w: "full",
      h: "auto",
      py: 2,
      background: "none",
      justifyContent: "center",
      alignItems: "center",
      flex: "1 1 auto",
      ...props,
      children: /* @__PURE__ */ jsx$1(Container, { w: "full", maxW: "none", pt: 0, pb: 4, px: 0, children: routes })
    }
  );
}
const QUERY_FRONTEND_SETTING = gql`
	query FrontendSetting($key: String = "") {
		frontendSetting(key: $key)
	}
`;
const useFrontendSetting = (key) => {
  const result = useQuery(QUERY_FRONTEND_SETTING, {
    variables: {
      key: `frontend_settings_${key}`
    }
  });
  const { frontendSetting } = result.data || {};
  return { value: frontendSetting, result: omit$1(result, ["data"]) };
};
function FooterLink({ href, children }) {
  return /* @__PURE__ */ jsx$1(Link, { href, color: "inherit", isExternal: true, children });
}
function Footer() {
  const { value: footerNotice } = useFrontendSetting("footer_notice");
  const year = (/* @__PURE__ */ new Date()).getFullYear();
  return /* @__PURE__ */ jsx$1(LightMode, { children: /* @__PURE__ */ jsx$1(Box, { w: "full", py: 4, bgColor: "brand.orange", fontSize: "md", children: /* @__PURE__ */ jsxs(Container, { maxW: "5xl", textAlign: "center", children: [
    /* @__PURE__ */ jsx$1(Text, { align: "center", children: footerNotice }),
    /* @__PURE__ */ jsxs(Flex, { justifyContent: "center", alignItems: "center", children: [
      "© ",
      year,
      " ",
      /* @__PURE__ */ jsx$1(FooterLink, { href: "https://maestramusic.org", children: "Maestra Music Inc." }),
      /* @__PURE__ */ jsx$1(RiseStar, { fontSize: "xs" }),
      /* @__PURE__ */ jsx$1(FooterLink, { href: "https://risetheatre.org/terms-conditions", children: "Terms & Conditions" }),
      /* @__PURE__ */ jsx$1(RiseStar, { fontSize: "xs" }),
      /* @__PURE__ */ jsx$1(FooterLink, { href: "https://risetheatre.org/privacy-policy", children: "Privacy Policy" })
    ] }),
    /* @__PURE__ */ jsx$1(Text, { children: /* @__PURE__ */ jsx$1(FooterLink, { href: "https://roundhouse-designs.com", children: "Made by Roundhouse Designs" }) })
  ] }) }) });
}
var wordpress = "";
const QUERY_WP_GLOBAL = gql`
	query WpGlobalQuery {
		wpGlobalStylesheet
	}
`;
const useWp = () => {
  const result = useQuery(QUERY_WP_GLOBAL);
  const { wpGlobalStylesheet = null } = result.data || {};
  return [wpGlobalStylesheet, omit$1(result, ["data"])];
};
const { VITE_DEV_MODE } = { "VITE_FRONTEND_URL": "http://localhost:3000", "VITE_BACKEND_URL": "https://dev.risetheatre.org/graphql", "VITE_RECAPTCHA_SITE_KEY": "6Ld7k6UmAAAAAKtdro6-WCKInHPiJxuIfcUYL_3b", "VITE_RISE_VERSION": "v1.1.9-dev", "VITE_DEV_MODE": "true", "VITE_UW_ACCOUNT": "512EhPw1RR", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": true };
const DevMode = ({ children }) => VITE_DEV_MODE === "true" ? /* @__PURE__ */ jsx$1(Fragment, { children }) : /* @__PURE__ */ jsx$1(Fragment, {});
const __APP_VERSION__ = `v${pkgJSON.version}`;
function App() {
  const { isOpen: drawerIsOpen, onOpen: openDrawer, onClose: closeDrawer } = useDisclosure();
  const headerRef = useRef(null);
  const [headerHeight, setHeaderHeight] = useState(0);
  const [wpGlobalStylesheet] = useWp();
  useEffect(() => {
    if (wpGlobalStylesheet) {
      const styleElement = document.createElement("style");
      styleElement.innerHTML = wpGlobalStylesheet;
      document.head.appendChild(styleElement);
      return () => {
        document.head.removeChild(styleElement);
      };
    }
  }, [wpGlobalStylesheet]);
  useEffect(() => {
    const observer = new ResizeObserver((entries) => {
      for (let entry of entries) {
        const { height } = entry.contentRect;
        setHeaderHeight(height);
      }
    });
    if (headerRef.current) {
      observer.observe(headerRef.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [headerRef.current]);
  return /* @__PURE__ */ jsx$1(SearchContextProvider, { children: /* @__PURE__ */ jsxs(
    Box,
    {
      minH: "-webkit-fill-available",
      _dark: {
        bg: "bg.dark",
        color: "text.light"
      },
      _light: {
        bg: "bg.light",
        color: "text.dark"
      },
      children: [
        /* @__PURE__ */ jsx$1(SearchDrawerContext.Provider, { value: { drawerIsOpen, openDrawer, closeDrawer }, children: /* @__PURE__ */ jsxs(Stack, { h: "100vh", w: "full", overflow: "auto", justifyContent: "space-between", gap: 0, children: [
          /* @__PURE__ */ jsx$1(Header, { ref: headerRef }),
          /* @__PURE__ */ jsx$1(Box, { h: "auto", w: "full", children: /* @__PURE__ */ jsx$1(Main, { pt: `${headerHeight}px` }) }),
          /* @__PURE__ */ jsx$1(Spacer, {}),
          /* @__PURE__ */ jsx$1(Footer, {})
        ] }) }),
        /* @__PURE__ */ jsx$1(DevMode, { children: /* @__PURE__ */ jsxs(
          Flex,
          {
            w: "100vw",
            position: "fixed",
            bottom: 0,
            left: 0,
            justifyContent: "center",
            alignItems: "center",
            gap: 2,
            m: 0,
            px: 4,
            bgColor: "brand.blue",
            fontSize: "2xs",
            children: [
              /* @__PURE__ */ jsx$1(Text, { children: "Development Branch:" }),
              /* @__PURE__ */ jsx$1(chakra.code, { children: __APP_VERSION__ })
            ]
          }
        ) })
      ]
    }
  ) });
}
const { VITE_BACKEND_URL } = { "VITE_FRONTEND_URL": "http://localhost:3000", "VITE_BACKEND_URL": "https://dev.risetheatre.org/graphql", "VITE_RECAPTCHA_SITE_KEY": "6Ld7k6UmAAAAAKtdro6-WCKInHPiJxuIfcUYL_3b", "VITE_RISE_VERSION": "v1.1.9-dev", "VITE_DEV_MODE": "true", "VITE_UW_ACCOUNT": "512EhPw1RR", "BASE_URL": "/", "MODE": "production", "DEV": false, "PROD": true, "SSR": true };
async function render(url) {
  const client = new ApolloClient({
    ssrMode: true,
    link: createUploadLink({
      uri: VITE_BACKEND_URL,
      credentials: "include",
      headers: {
        "X-SSR": "1"
        // Add header to identify SSR requests
      }
    }),
    cache: new InMemoryCache({
      addTypename: true
    }),
    defaultOptions: {
      watchQuery: {
        fetchPolicy: "cache-first"
      }
    }
  });
  const AppTree = /* @__PURE__ */ jsxs(StrictMode, { children: [
    /* @__PURE__ */ jsx$1(ColorModeScript, { initialColorMode: theme.config.initialColorMode }),
    /* @__PURE__ */ jsx$1(StaticRouter, { location: url, children: /* @__PURE__ */ jsx$1(ApolloProvider, { client, children: /* @__PURE__ */ jsxs(ChakraProvider, { resetCSS: true, theme, children: [
      /* @__PURE__ */ jsx$1(Fonts, {}),
      /* @__PURE__ */ jsx$1(App, {})
    ] }) }) })
  ] });
  try {
    await getDataFromTree(AppTree);
    const html = ReactDOMServer.renderToString(AppTree);
    const state2 = JSON.stringify(client.extract());
    console.debug("🎭 SSR Complete:", {
      url,
      stateSize: state2.length,
      queries: client.extract()
    });
    return {
      html,
      state: state2
    };
  } catch (error) {
    console.error("🎭 SSR Error:", error);
    const html = ReactDOMServer.renderToString(AppTree);
    return {
      html,
      state: JSON.stringify({})
    };
  }
}
export {
  render
};
//# sourceMappingURL=entry-server.js.map
